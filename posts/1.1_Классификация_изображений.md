<!--
.. title: Классификация изображений 
.. slug: image-classification
.. date: 2025-03-14 8:00 UTC+03:00
.. tags: CV
.. category: 
.. link: 
.. description: Введение в классификацию изображений, классификатор ближайшего соседа, классификатор k - ближайших соседей, наборы данных для настройки гиперпараметров. 
.. type: text
.. has_math: true
-->

# Классификация изображений 

В этой вводной лекции мы познакомимся с проблемой классификации изображений. 
Решение этой проблемы заключается в подходе, основанном на большом объеме размеченных данных.   

Содержание:  
- Введение в классификацию изображений  
- Классификатор ближайшего соседа  
- Классификатор k - ближайших соседей   
- Наборы данных для настройки гиперпараметров  
- Применение kNN на практике  
- Дополнительные материалы  
   
## Введение в классификацию изображений   
  
__Мотивация__. 
В этом разделе мы рассмотрим задачу классификации изображений. 
Задача заключается в присвоении входному изображению одной метки из фиксированного набора категорий. 
Это одна из основных задач компьютерного зрения, которая, несмотря на свою простоту, имеет множество практических применений. 
Более того, многие другие задачи компьютерного зрения (детекция объектов, сегментация) могут быть сведены к классификации изображений.   
  
__Пример__. 
Например, на изображении ниже модель классификации изображений принимает одно изображение и присваивает вероятности четырём меткам: _{«кошка», «собака», «шляпа», «кружка»}_. 
Как показано на изображении, для компьютера изображение представляет собой один большой трёхмерный массив чисел. 
В этом примере изображение кошки имеет ширину **248** пикселей, высоту **400** пикселей и три цветовых канала: красный, зелёный, синий (или сокращённо *RGB*). 
Таким образом, изображение состоит из **248 x 400 x 3** чисел, или в общей сложности 297 600 чисел. 
Каждое число представляет собой целое число от 0 (чёрный) до 255 (белый). 
Наша задача — превратить эти четверть миллиона чисел в одну метку, например _«кошка»_.  

![](https://cs231n.github.io/assets/classify.png)   

Задача классификации изображений состоит в том, чтобы предсказать одну метку для заданного изображения. 
Так же мы можем предсказать распределение вероятностей для всех меток, что отражает степень нашей уверенности в результате классификации.   Изображения представляют собой трёхмерные массивы целых чисел от 0 до 255 размером «ширина x высота x 3». 
Число 3 обозначает три цветовых канала: красный, зелёный и синий.  

__Проблемы__. 
Поскольку задача распознавания визуального образа (например, кошки) относительно проста для человека, стоит рассмотреть связанные с ней проблемы с точки зрения алгоритма компьютерного зрения. 
Ниже мы приводим (неполный) список проблем, не забывая о том, что изображения представлены в виде трёхмерного массива значений яркости:
- __Изменение точки обзора__. Один экземпляр объекта может быть ориентирован по-разному относительно камеры.
- __Изменение масштаба__. Визуальные классы часто различаются по размеру (размеру в реальном мире, а не только по размеру на изображении).
- __Деформация__. Многие интересующие нас объекты не являются твёрдыми телами и могут сильно деформироваться.
- __Окклюзия__. Интересующие нас объекты могут быть частично скрыты. Иногда видна лишь небольшая часть объекта (всего несколько пикселей).
- __Условия освещения__. Влияние освещения на пиксели очень велико.
- __Фоновый шум__. Интересующие нас объекты могут сливаться с окружающей средой, что затрудняет их идентификацию.
- __Внутриклассовые различия__. Классы, представляющие интерес, часто могут быть относительно обширными, например, _стулья_. Существует множество различных типов этих предметов, каждый из которых имеет отличный от других элементов класса внешний вид.   
  
Хорошая модель классификации изображений должна быть инвариантна к перекрёстному произведению всех этих вариаций, сохраняя при этом чувствительность к межклассовым вариациям.   

***   

![](https://cs231n.github.io/assets/challenges.jpeg)   

***   

__Подход, основанный на данных__. Как бы мы могли написать алгоритм, который сможет классифицировать изображения по отдельным категориям? В отличие от написания алгоритма, например, для сортировки списка чисел, не очевидно, как можно написать алгоритм для распознавания кошек на изображениях. Поэтому вместо того, чтобы пытаться описать каждую из интересующих нас категорий непосредственно в коде, мы воспользуемся подходом, похожим на тот, что вы бы использовали с ребёнком: мы предоставим компьютеру множество примеров каждого класса, а затем разработаем алгоритмы обучения, которые будут изучать эти примеры и узнавать о визуальном представлении каждого класса. Этот подход называется подходом, основанным на данных, поскольку он предполагает сначала накопление обучающего набора данных с размеченными изображениями. Вот пример того, как может выглядеть такой набор данных:   

***   

![](https://cs231n.github.io/assets/trainset.jpg)   

Пример обучающего набора для четырёх визуальных категорий. На практике у нас могут быть тысячи категорий и сотни тысяч изображений для каждой категории.  

***   

__Конвейер классификации изображений__. Мы увидели, что задача классификации изображений состоит в том, чтобы взять массив пикселей, представляющий одно изображение, и присвоить ему метку. Наш полный конвейер можно формализоваться следующим образом:
- __Входные данные__: наши входные данные состоят из набора ___N___ изображений, каждое из которых помечено одним из ___K___ различных классов. Мы называем эти данные _обучающим набором_.
- __Обучение__: наша задача — использовать обучающую выборку, чтобы узнать, как выглядит каждый из классов. Мы называем этот этап _обучением классификатора_ или _обучением модели_.
- __Оценка__: в конце мы оцениваем качество классификатора, задавая ему вопрос о том, какие метки он предскажет для нового набора изображений, которые он никогда раньше не видел. Затем мы сравниваем истинные метки этих изображений с теми, которые предсказал классификатор. Интуитивно мы надеемся, что многие прогнозы совпадут с истинными ответами (которые мы называем _исходными данными_). 
## Классификатор ближайшего Соседа   
  
В качестве первого подхода мы разработаем так называемый __классификатор ближайших соседей__. Этот классификатор не имеет ничего общего со свёрточными нейронными сетями и очень редко используется на практике, но он позволит нам получить представление об основном подходе к задаче классификации изображений.   
  
__Пример набора данных для классификации изображений: CIFAR-10__. Одним из популярных наборов данных для классификации изображений является [набор данных CIFAR-10](https://www.cs.toronto.edu/~kriz/cifar.html). Этот набор данных состоит из 60 000 крошечных изображений высотой и шириной 32 пикселя. Каждое изображение относится к одному из 10 классов (например, _«самолет, автомобиль, птица и т. д.»_). Эти 60 000 изображений разделены на обучающую выборку из 50 000 изображений и тестовую выборку из 10 000 изображений. На изображении ниже вы можете увидеть 10 случайных примеров изображений из каждого из 10 классов:   

***  

![](https://cs231n.github.io/assets/nn.jpg)  

Слева: примеры изображений из набора данных CIFAR-10. Справа: в первом столбце показаны несколько тестовых изображений, а рядом с каждым из них — 10 ближайших соседей из обучающей выборки по пиксельной разнице.   

***  

Предположим, что у нас есть обучающая выборка CIFAR-10 из 50 000 изображений (по 5000 изображений для каждой из 10 категорий), и мы хотим классифицировать оставшиеся 10 000 изображений. Классификатор ближайших соседей возьмёт тестовое изображение, сравнит его с каждым из обучающих изображений и предскажет категорию ближайшего обучающего изображения. На изображении выше и справа вы можете увидеть пример результата такой процедуры для 10 тестовых изображений. Обратите внимание, что только в 3 из 10 изображений являются элементами того же класса, в то время как в остальных 7 примерах возникает ошибка определения класса. Например, в 8-м ряду ближайшим обучающим изображением к голове лошади является красный автомобиль, предположительно из-за сильного чёрного фона. В результате это изображение лошади в данном случае будет ошибочно помечено как автомобиль. 
Возможно, вы заметили, что мы не уточнили, как именно мы сравниваем два изображения, которые в данном случае представляют собой просто два блока размером 32 x 32 x 3. Один из самых простых способов — сравнивать изображения попиксельно и суммировать все различия. Другими словами, если у вас есть два изображения, представленные в виде векторов \\(I_1\\),\\(I_2\\), разумным выбором для их сравнения может быть __расстояние L1__:   
  
$$
d_1 (I_1, I_2) = \sum_{p} \left| I^p_1 - I^p_2 \right|
$$   
  
Где сумма берется по всем пикселям. Вот как выглядит эта процедура:   

***   

![](https://cs231n.github.io/assets/nneg.jpeg)  

Пример использования попиксельных различий для сравнения двух изображений с помощью расстояния **\\(L_1\\)** (в данном примере для одного цветового канала). Два изображения вычитаются поэлементно, а затем все различия суммируются до получения одного числа. Если два изображения идентичны, результат будет равен нулю. Но если изображения сильно отличаются, результат будет большим.   

***  
 
Давайте также посмотрим, как можно реализовать классификатор в коде. Сначала загрузим данные CIFAR-10 в память в виде четырех массивов: обучающие данные/метки и тестовые данные/метки. В приведенном ниже коде `Xtr` хранятся все изображения из обучающей выборки  (объем 50 000 x 32 x 32 x 3), а соответствующий одномерный массив `Ytr` (длиной 50 000) содержит обучающие метки (от 0 до 9):   
  
``` 
Xtr, Ytr, Xte, Yte = load_CIFAR10('data/cifar10/') # a magic function we provide
# flatten out all images to be one-dimensional 
Xtr_rows = Xtr.reshape(Xtr.shape[0], 32 * 32 * 3) # Xtr_rows becomes 50000 x 3072
Xte_rows = Xte.reshape(Xte.shape[0], 32 * 32 * 3) # Xte_rows becomes 10000 x 3072 
```  
  
  
Теперь, когда все изображения вытянуты в ряд, вот как мы можем обучить и оценить классификатор:   
  
```
nn = NearestNeighbor() # create a Nearest Neighbor classifier class
nn.train(Xtr_rows, Ytr) # train the classifier on the training images and labels
Yte_predict = nn.predict(Xte_rows) # predict labels on the test images
# and now print the classification accuracy, which is the average number
# of examples that are correctly predicted (i.e. label matches)
print 'accuracy: %f' % ( np.mean(Yte_predict == Yte) )
```
  
  
Обратите внимание, что в качестве критерия оценки обычно используется __точность__, которая измеряет долю правильных прогнозов. Обратите внимание, что все классификаторы, которые мы создадим, удовлетворяют этому общему API: у них есть `train(X,y)` функция, которая принимает данные и метки для обучения. Внутри класса должна быть построена своего рода модель меток и того, как их можно предсказать на основе данных и `predict(X)` функция, которая принимает новые данные и предсказывает метки. Конечно, мы не стали вдаваться в подробности — в сам классификатор. Вот реализация простого классификатора ближайших соседей с расстоянием **\\(L_1\\)**, которая соответствует этому шаблону:   
  
```
import numpy as np

class NearestNeighbor(object):
def __init__(self):
pass

def train(self, X, y):
""" X is N x D where each row is an example. Y is 1-dimension of size N """
# the nearest neighbor classifier simply remembers all the training data
self.Xtr = X
self.ytr = y

def predict(self, X):
""" X is N x D where each row is an example we wish to predict label for """
num_test = X.shape[0]
# lets make sure that the output type matches the input type
Ypred = np.zeros(num_test, dtype = self.ytr.dtype)

# loop over all test rows
for i in range(num_test):
# find the nearest training image to the i'th test image
# using the L1 distance (sum of absolute value differences)
distances = np.sum(np.abs(self.Xtr - X[i,:]), axis = 1)
min_index = np.argmin(distances) # get the index with smallest distance
Ypred[i] = self.ytr[min_index] # predict the label of the nearest example

return Ypred
```
  
  
Если вы запустите этот код, то увидите, что этот классификатор достигает точности __38,6%__ только на CIFAR-10. Это более впечатляющий результат, чем случайное угадывание (которое дало бы **10%** точности, так как существует 10 классов), но он далёк от результатов человека (которые [оцениваются примерно в 94%](https://karpathy.github.io/2011/04/27/manually-classifying-cifar10/)) или от результатов современных свёрточных нейронных сетей, которые достигают примерно 95%, соответствуя точности человека ([см.  таблицу лидеров](https://www.kaggle.com/c/cifar-10/leaderboard) недавнего соревнования Kaggle по CIFAR-10).  
   
__Выбор расстояния__. Существует множество других способов вычисления, напромер на основании расстояний между векторами. Одним из столь распространённых вариантов может быть использование __расстояния \\(L_2\\)__, которое имеет геометрическую интерпретацию вычисления евклидова расстояния между двумя векторами. Расстояние имеет вид:  
  
$$
d_2 (I_1, I_2) = \sqrt{\sum_{p} \left( I^p_1 - I^p_2 \right)^2}
$$  
  
Другими словами, мы вычисляем разницу по пикселям, как и раньше, но на этот раз возводим их в квадрат, складываем и, наконец, извлекаем квадратный корень. В numpy, используя приведенный выше код, нам нужно заменить только одну строку. Строка, которая вычисляет расстояния:   
  
```
distances = np.sqrt(np.sum(np.square(self.Xtr - X[i,:]), axis = 1))
```
  
  
Обратите внимание, что происходит включение `np.sqrt` вызова выше, но в практическом применении метода ближайшего соседа мы могли бы не использовать операцию извлечения квадратного корня, потому что квадратный корень является _монотонной функцией_. То есть он масштабирует абсолютные значения расстояний, но сохраняет порядок, поэтому ближайшие соседи с ним и без него идентичны. Если бы вы применили классификатор ближайшего соседа к CIFAR-10 с этим расстоянием, вы бы получили __35,4%__ точности (немного ниже, чем результат с расстоянием **\\(L_1\\)**.   
  
__\\(L_1\\) против \\(L_2\\)__. Интересно рассмотреть различия между этими двумя метриками. В частности, расстояние **\\(L_2\\)** гораздо более строгое, чем расстояние **\\(L_1\\)**, когда речь идёт о различиях между двумя векторами. То есть расстояние **\\(L_2\\)** предпочитает множество небольших расхождений одному большому. Расстояния **\\(L_1\\)** и  **\\(L_2\\)** (или, что эквивалентно, нормы  **\\(L_1\\) \\(L_2\\)** различий между парой изображений) являются наиболее часто используемыми частными случаями [p-нормы](https://planetmath.org/vectorpnorm).   
  
## Классификатор k - Ближайшего соседа  
  
Возможно, вы заметили, что странно использовать только метку ближайшего изображения, когда мы хотим сделать прогноз. Действительно, почти всегда можно добиться лучшего результата, используя так называемый __классификатор k-ближайших соседей__. Идея очень проста: вместо того, чтобы искать одно ближайшее изображение в обучающем наборе, мы найдём __k__ ближайших изображений и заставим их "проголосовать" за метку тестового изображения. В частности, когда _k = 1_, мы получаем классификатор ближайших соседей. Интуитивно понятно, что более высокие значения __k__ оказывают сглаживающий эффект, который делает классификатор более устойчивым к ошибкам:   

***  
 
![](https://cs231n.github.io/assets/knn.jpeg)  

Пример разницы между классификатором «ближайший сосед» и классификатором «ближайшие 5 соседей» с использованием двумерных точек и 3 классов (красный, синий, зелёный). Цветные области показывают __границы решений__, создаваемые классификатором с использованием расстояния  \\(L_2\\). Белые области показывают точки, которые классифицируются неоднозначно (т. е. голоса за классы равны как минимум для двух классов). Обратите внимание, что в случае классификатора NN ошибки (например, зелёная точка в середине облака синих точек) создают небольшие островки вероятных неверных прогнозов, в то время как классификатор 5-NN сглаживает эти неровности, что, вероятно, приводит к лучшему __обобщению__ на тестовых данных (не показано). Также обратите внимание, что серые области на изображении 5-NN вызваны равенством голосов ближайших соседей (например, 2 соседа красные, следующие два соседа синие, последний сосед зелёный). 
***   

На практике вы почти всегда будете использовать метод k-ближайших соседей. Но какое значение k следует использовать? Мы рассмотрим эту проблему далее.   
  
## Наборы проверочных данных для настройки гиперпараметров   
  
Классификатор k-ближайших соседей требует настройки параметра _k_. Но какое число подходит лучше всего? Кроме того, мы увидели, что существует множество различных функций расстояния, которые мы могли бы использовать: норма  **\\(L_1\\)**, норма **\\(L_2\\)**, а также множество других вариантов, которые мы даже не рассматривали (например, скалярные произведения). Эти варианты называются __гиперпараметрами__, и они очень часто используются при разработке многих алгоритмов машинного обучения, которые обучаются на данных. Часто не очевидно, какие значения/настройки следует выбрать.   
  
У вас может возникнуть соблазн предложить попробовать множество различных значений и посмотреть, что работает лучше всего. Это хорошая идея, и именно это мы и сделаем, но делать это нужно очень осторожно. В частности, __мы не можем использовать тестовый набор данных для настройки гиперпараметров__. Всякий раз, когда вы разрабатываете алгоритмы машинного обучения, вы должны относиться к тестовому набору данных как к очень ценному ресурсу, к которому, в идеале, не следует прикасаться до самого конца. В противном случае существует реальная опасность того, что вы настроите гиперпараметры так, чтобы они хорошо работали на тестовом наборе данных, но при развёртывании модели показывали значительное снижение производительности. На практике можно сказать, что вы __переобучились__ на тестовом наборе данных. С другой стороны, если вы настраиваете гиперпараметры на тестовом наборе данных, вы фактически используете тестовый набор данных в качестве обучающего, и поэтому производительность, которую вы достигаете на нём, будет слишком оптимистичной по сравнению с тем, что вы можете наблюдать при развёртывании модели. Но если вы используете тестовый набор данных только один раз в конце, он остаётся хорошим показателем для измерения __обобщение__ вашего классификатора (мы подробнее обсудим обобщение позже на занятии).   
  
> Оценивайте тестовый набор только один раз, в самом конце.
  
  
К счастью, существует правильный способ настройки гиперпараметров, и он никак не затрагивает тестовый набор данных. Идея состоит в том, чтобы разделить наш обучающий набор данных на две части: немного меньший обучающий набор данных и то, что мы называем __тестирующим набором данных__. Используя в качестве примера CIFAR-10, мы могли бы, например, использовать 49 000 обучающих изображений для обучения и оставить 1000 для тестирования. Этот набор данных для проверки, по сути, используется в качестве _"поддельного"_ тестового набора для настройки гиперпараметров.   
  
Вот как это может выглядеть в случае CIFAR-10:   
  
```
# assume we have Xtr_rows, Ytr, Xte_rows, Yte as before
# recall Xtr_rows is 50,000 x 3072 matrix
Xval_rows = Xtr_rows[:1000, :] # take first 1000 for validation
Yval = Ytr[:1000]
Xtr_rows = Xtr_rows[1000:, :] # keep last 49,000 for train
Ytr = Ytr[1000:]

# find hyperparameters that work best on the validation set
validation_accuracies = []
for k in [1, 3, 5, 10, 20, 50, 100]:

# use a particular value of k and evaluation on validation data
nn = NearestNeighbor()
nn.train(Xtr_rows, Ytr)
# here we assume a modified NearestNeighbor class that can take a k as input
Yval_predict = nn.predict(Xval_rows, k = k)
acc = np.mean(Yval_predict == Yval)
print 'accuracy: %f' % (acc,)

# keep track of what works on the validation set
validation_accuracies.append((k, acc))
```  
  
  
По завершении этой процедуры мы могли бы построить график, показывающий, какие значения k работают лучше всего. Затем мы бы остановились на этом значении и провели оценку на реальном тестовом наборе данных.   
  
> Разделите обучающую выборку на обучающую и проверочную. Используйте проверочную выборку для настройки всех гиперпараметров. В конце выполните один запуск на тестовой выборке и оцените производительность.

__Перекрестная проверка__. В случаях, когда размер обучающих данных (и, следовательно, проверочных данных) может быть небольшим, люди иногда используют более сложный метод настройки гиперпараметров, называемый __перекрестной проверкой__. Если вернуться к нашему предыдущему примеру, то идея заключается в том, что вместо произвольного выбора первых 1000 точек данных в качестве проверочного набора, а остальных — в качестве обучающего, можно получить более точную и менее зашумлённую оценку того, насколько хорошо работает определённое значение __k__, перебирая различные проверочные наборы и усредняя результаты по ним. Например, при 5-кратной перекрёстной проверке мы разделили бы обучающие данные на 5 равных частей, использовали 4 из них для обучения, а 1 — для проверки. Затем мы бы определили, какая из выборок является контрольной, оценили бы производительность и, наконец, усреднили бы производительность по разным выборкам.   

***   

![](https://cs231n.github.io/assets/cvplot.png)  

Пример 5-кратного выполнения перекрестной проверки для параметра __k__. Для каждого значения __k__ мы тренируемся на 4 сгибах и оцениваем на 5-м. Следовательно, для каждого k мы получаем 5 значений точности для проверочного сгиба (точность отражается на оси y, и каждый результат равен точке). Линия тренда проводится через среднее значение результатов для каждого __k__, а столбики ошибок указывают на стандартное отклонение. Обратите внимание, что в данном конкретном случае перекрёстная проверка показывает, что значение около __k = 7__ лучше всего подходит для этого конкретного набора данных (соответствует пику на графике). Если бы мы использовали более 5 циклов, то могли бы ожидать более плавную (то есть менее шумную) кривую.   

***  
  
__На практике__. На практике люди предпочитают избегать перекрёстной проверки в пользу одного проверочного набора данных, поскольку перекрёстная проверка может быть ресурсозатратной. Обычно люди используют от **50%** до **90%** обучающих данных для обучения и остальную часть для проверки. Однако это зависит от множества факторов: например, если количество гиперпараметров велико, вы можете предпочесть использовать более крупные проверочные наборы данных. Если количество примеров в проверочном наборе невелико (возможно, всего несколько сотен или около того), безопаснее использовать перекрёстную проверку. На практике обычно используется 3-кратная, 5-кратная или 10-кратная перекрёстная проверка.   
  
***  
 
![](https://cs231n.github.io/assets/crossval.jpeg)  

Обычное разделение данных. Выделяются обучающий и тестовый наборы данных. Обучающий набор данных делится на части (например, здесь их 5). Части 1-4 становятся обучающим набором данных. Одна часть (например, часть 5, выделенная здесь жёлтым цветом) называется проверочной частью и используется для настройки гиперпараметров. Перекрёстная проверка идёт дальше и позволяет выбрать, какая часть будет проверочной, отдельно от частей 1-5. Это называется 5-кратной перекрёстной проверкой. В самом конце, когда модель обучена и определены все наилучшие гиперпараметры, модель один раз оценивается на тестовых данных (красный цвет).   

***   
  
__Плюсы и минусы классификатора ближайших соседей.__   
  
Стоит рассмотреть некоторые преимущества и недостатки классификатора «ближайший сосед». Очевидно, что одним из преимуществ является простота реализации и понимания. Кроме того, обучение классификатора не занимает много времени, поскольку всё, что требуется, — это хранить и, возможно, индексировать обучающие данные. Однако мы платим за это вычислительными затратами во время тестирования, поскольку для классификации тестового примера требуется сравнение с каждым обучающим примером. Это неправильно, поскольку на практике мы часто уделяем больше внимания эффективности во время тестирования, чем во время обучения. На самом деле, объемные нейронные сети, которые мы будем разрабатывать в этом классе, смещают этот компромисс в другую крайность: их обучение обходится очень дорого, но после завершения обучения классифицировать новый тестовый пример очень дёшево. Такой режим работы гораздо более желателен на практике.   
  
Кроме того, вычислительная сложность классификатора «ближайший сосед» является активной областью исследований, и существует несколько алгоритмов и библиотек __приблизительного поиска ближайшего соседа__ (_ANN_), которые могут ускорить поиск ближайшего соседа в наборе данных (например, [FLANN](https://github.com/mariusmuja/flann) ). Эти алгоритмы позволяют найти компромисс между точностью поиска ближайшего соседа и его пространственной/временной сложностью во время поиска и обычно полагаются на этап предварительной обработки/индексирования, который включает в себя построение KD-дерева или запуск алгоритма k-средних.  
  
В некоторых случаях классификатор ближайших соседей может быть хорошим выбором (особенно если данные имеют низкую размерность), но он редко подходит для использования в практических задачах классификации изображений. Одна из проблем заключается в том, что изображения — это объекты с высокой размерностью (то есть они часто содержат много пикселей), а расстояния в многомерных пространствах могут быть очень нелогичными. На изображении ниже показано, что сходство на основе пикселей, которое мы описали выше, сильно отличается от сходства с точки зрения восприятия:   

***  

![](https://cs231n.github.io/assets/samenorm.png)   

Расстояния на основе пикселей в многомерных данных (и особенно в изображениях) могут быть очень неинтуитивными. Исходное изображение (слева) и три других изображения рядом с ним, которые находятся на одинаковом расстоянии от него на основе пиксельного расстояния **\\(L_2\\)**. Очевидно, что пиксельное расстояние никак не соответствует перцептивному или семантическому сходству.   

***   

Вот ещё одна визуализация, которая убедит вас в том, что использование разницы в пикселях для сравнения изображений недостаточно. Мы можем использовать метод визуализации под названием [t-SNE](https://lvdmaaten.github.io/tsne/), чтобы взять изображения CIFAR-10 и разместить их в двух измерениях так, чтобы их  парные (локальные) расстояния сохранялись наилучшим образом. В этой визуализации изображения, которые показаны рядом, считаются очень близкими в соответствии с расстоянием **\\(L_2\\)** по пикселям, которое мы разработали выше:   

***   

![](https://cs231n.github.io/assets/pixels_embed_cifar10.jpg)  

Изображения CIFAR-10, размещённые в двух измерениях с помощью *t-SNE*. Изображения, расположенные рядом на этом изображении, считаются близкими на основе пиксельного расстояния **\\(L_2\\)**. Обратите внимание на сильное влияние фона, а не семантических различий между классами. Нажмите [здесь](https://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg), чтобы увидеть увеличенную версию этой визуализации.   

***   

В частности, обратите внимание, что изображения, расположенные друг рядом с другом, в большей степени зависят от общего цветового распределения изображений или типа фона, а не от их семантической идентичности. Например, собаку можно увидеть рядом с лягушкой, потому что они обе находятся на белом фоне. В идеале мы хотели бы, чтобы изображения всех 10 классов образовывали собственные кластеры, чтобы изображения одного класса находились рядом друг с другом независимо от нерелевантных характеристик и вариаций (например, фона). Однако, чтобы добиться этого, нам придётся выйти за рамки необработанных пикселей.   
  
# Краткая сводка   
  
Подводя итог: 
- Мы рассмотрели задачу __классификации изображений__, в которой нам даётся набор изображений, каждое из которых помечено одной категорией. Затем нас просят предсказать эти категории для нового набора тестовых изображений и оценить точность прогнозов.
- Мы представили простой классификатор под названием _«классификатор ближайших соседей»_.  Мы увидели, что существует множество гиперпараметров (например, значение k или тип расстояния, используемого для сравнения примеров), связанных с этим классификатором, и что не существует очевидного способа их выбора.
- Мы увидели, что правильный способ задать эти гиперпараметры — разделить обучающие данные на две части: *обучающий набор* и *поддельный тестовый набор*, который мы называем __набором для проверки__. Мы пробуем разные значения гиперпараметров и оставляем те, которые обеспечивают наилучшую производительность на наборе для проверки.
- Если вас беспокоит нехватка обучающих данных, мы обсудили процедуру под названием __перекрёстная проверка__, которая может помочь уменьшить погрешность при оценке наиболее эффективных гиперпараметров.
- Как только мы находим оптимальные гиперпараметры, мы фиксируем их и проводим одну __оценку__ на реальном тестовом наборе данных.
- Мы увидели, что метод ближайшего соседа может обеспечить нам точность около **40%** на CIFAR-10. Он прост в реализации, но требует хранения всего обучающего набора данных, и его сложно оценивать на тестовых изображениях.
- В итоге мы увидели, что использование расстояний **\\(L_1\\)** или **\\(L_2\\**) по необработанным значениям пикселей нецелесообразно, поскольку эти расстояния сильнее коррелируют с фоном и цветовыми распределениями изображений, чем с их семантическим содержанием.   
  
На следующих лекциях мы приступим к решению этих задач и в конечном итоге придём к решениям, которые обеспечат точность **90%**, позволят полностью отказаться от обучающего набора данных после завершения обучения и позволят оценивать тестовые изображения менее чем за миллисекунду.   
  
## Краткое описание: Применение kNN на практике   
  
Если вы хотите применить *kNN* на практике (надеюсь, не на изображениях или, возможно, только в качестве базовой модели), действуйте следующим образом: 
1. **Предварительная обработка данных**: нормализуйте признаки в ваших данных (например, один пиксель на изображениях), чтобы среднее значение было равно нулю, а дисперсия — единице. Мы рассмотрим это более подробно в следующих разделах и решили не рассматривать нормализацию данных в этом разделе, потому что пиксели на изображениях обычно однородны и не имеют сильно различающихся распределений, что снижает необходимость в нормализации данных.
2. **Если ваши данные имеют очень высокую размерность**, рассмотрите возможность использования метода уменьшения размерности, такого как метод главных компонент ([ссылка на вики-страницу](https://en.wikipedia.org/wiki/Principal_component_analysis), [ссылка на CS229](http://cs229.stanford.edu/notes/cs229-notes10.pdf), [ссылка на блог](https://web.archive.org/web/20150503165118/http://www.bigdataexaminer.com:80/understanding-dimensionality-reduction-principal-component-analysis-and-singular-value-decomposition/), метод независимых компонент ([ссылка на вики-страницу](https://en.wikipedia.org/wiki/Neighbourhood_components_analysis), [ссылка на блог](https://kevinzakka.github.io/2020/02/10/nca/) или даже [случайные проекции](https://scikit-learn.org/stable/modules/random_projection.html).
3. **Разделите обучающие данные случайным образом на обучающую и проверочную выборки**. Как правило, от **70** до **90%** данных обычно попадают в обучающую выборку. Этот параметр зависит от того, сколько у вас гиперпараметров и насколько сильно они влияют на результат. Если нужно оценить множество гиперпараметров, лучше использовать более крупную проверочную выборку для их эффективной оценки. Если вас беспокоит размер проверочной выборки, лучше разделить обучающие данные на части и выполнить перекрёстную проверку. Если вы можете позволить себе потратить больше времени на вычисления, всегда безопаснее использовать перекрёстную проверку (чем больше циклов, тем лучше, но тем дороже).
4. **Обучите и оцените классификатор kNN на проверочных данных** (для всех выборок, если выполняется перекрёстная проверка) для множества вариантов k (например, чем больше, тем лучше) и для разных типов расстояний (**\\(L_1\\) и \\(L_2\\)** — хорошие кандидаты)
5. **Если ваш классификатор kNN работает слишком долгo**, рассмотрите возможность использования библиотеки приближённых ближайших соседей (например, [FLANN](https://github.com/mariusmuja/flann) для ускорения поиска (за счёт некоторой потери точности).
6. **Обратите внимание на гиперпараметры**, которые дали наилучшие результаты. Возникает вопрос, следует ли использовать весь набор обучающих данных с наилучшими гиперпараметрами, поскольку оптимальные гиперпараметры могут измениться, если вы добавите проверочные данные в набор обучающих данных (поскольку размер данных увеличится). На практике лучше не использовать проверочные данные в итоговом классификаторе и считать их потерянными при оценке гиперпараметров. Оцените наилучшую модель на тестовом наборе данных. Сообщите о точности тестового набора данных и объявите результат производительностью классификатора *kNN* на ваших данных.  
  
# Дополнительные материалы   
  
Вот несколько (необязательных) ссылок, которые могут показаться вам интересными для дальнейшего чтения:
- [Несколько полезных фактов о машинном обучении](https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf), особенно раздел 6, но рекомендуется к прочтению вся статья.
- [Распознавание и изучение категорий объектов](https://people.csail.mit.edu/torralba/shortCourseRLOC/index.html), краткий курс по категоризации объектов на ICCV 2005.
