<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Сверточные сети. Введение | Заметки по ML, DL</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="../../rss.xml">
<link rel="canonical" href="https://mldl.ru/posts/convnets-1/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Андрей Лабинцев">
<link rel="prev" href="../backpropagation/" title="Обратное распространение ошибки" type="text/html">
<link rel="next" href="../convnets-2/" title="Предобработка, инициализация весов, функции потерь" type="text/html">
<meta property="og:site_name" content="Заметки по ML, DL">
<meta property="og:title" content="Сверточные сети. Введение">
<meta property="og:url" content="https://mldl.ru/posts/convnets-1/">
<meta property="og:description" content="Сверточные сети. Введение
Сожержание: 
- Краткое вступление без мозговых аналогий
- Моделирование одного нейрона
    + Биологическая мотивация и связи
    + Одиночный нейрон как линейный классификатор">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-03-08T19:42:16+03:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Источник</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Сверточные сети. Введение</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Андрей Лабинцев
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2025-03-08T19:42:16+03:00" itemprop="datePublished" title="2025-03-08 19:42">2025-03-08 19:42</time></a>
            </p>
            
        <p class="sourceline"><a href="index.md" class="sourcelink">Источник</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <h2>Сверточные сети. Введение</h2>
<p>Сожержание: 
- <a href=".">Краткое вступление без мозговых аналогий</a>
- <a href=".">Моделирование одного нейрона</a>
    + <a href=".">Биологическая мотивация и связи</a>
    + <a href=".">Одиночный нейрон как линейный классификатор</a>
    + <a href=".">Часто используемые функции активации</a>
- <a href=".">Архитектуры нейронных сетей</a>
    + <a href=".">Многоуровневая организация</a>
    + <a href=".">Пример вычисления с прямой связью</a>
    + <a href=".">Представительская власть</a>
    + <a href=".">Настройка количества слоев и их размеров</a>
- <a href=".">Краткие сведения</a>
- <a href=".">Дополнительные ссылки</a>  </p>
<h2>Краткое вступление</h2>
<p>Можно представить нейронные сети, не прибегая к аналогам с мозгом. В разделе о линейной классификации мы вычисляли баллы для различных визуальных категорий по изображению с помощью формулы <strong>s=Wx</strong>, где <strong>W</strong> была матрицей и <strong>x</strong> был вектор входных данных, содержащий все пиксельные данные изображения. В случае CIFAR-10 <strong>x</strong> является вектором-столбцом <strong>[3072x1]</strong>, и <strong>W</strong>. Это матрица <strong>[10x3072]</strong>, так что выходные данные представляют собой вектор из 10 оценок по классам.  </p>
<p>Примерная нейронная сеть вместо этого вычисляла бы <strong>\( s = \( W_2 \max(0, W_1 x) \)</strong>. Здесь, <strong>\(W_1\)</strong> может быть, например, матрицей <strong>[100x3072]</strong>, преобразующей изображение в 100-мерный промежуточный вектор. Функция <strong>\(max(0,-) \)</strong> это нелинейность, котрая применяется поэлементно. Существует несколько вариантов нелинейности (которые мы рассмотрим ниже), но этот вариант является распространённым и просто приравнивает все значения ниже нуля к нулю. Наконец, матрица <strong>\(W_2\)</strong> тогда будет иметь размер <strong>[10x100]</strong>, так что мы снова получим 10 чисел, которые мы интерпретируем как оценки классов. Обратите внимание, что нелинейность имеет решающее значение с точки зрения вычислений — если бы мы её не использовали, то две матрицы можно было бы объединить в одну, и, следовательно, прогнозируемые оценки классов снова были бы линейной функцией входных данных. Нелинейность — это то, что даёт нам <strong>колебания</strong>. Параметры <strong>W2,W1</strong>. Они обучаются с помощью стохастического градиентного спуска, а их градиенты вычисляются с помощью правила дифференцирования (и обратного распространения ошибки).  </p>
<p>Аналогично трехслойная нейронная сеть могла бы выглядеть следующим образом  <strong>\( s = W_3 \max(0, W_2 \max(0, W_1 x)) \)</strong>, где все <strong>\(W_3, W_2, W_1\)</strong>- это параметры, которые необходимо изучить. Размеры промежуточных скрытых векторов являются гиперпараметрами сети, и мы рассмотрим, как их можно задать позже. Теперь давайте посмотрим, как можно интерпретировать эти вычисления с точки зрения нейронов/сети.  </p>
<h2>Моделирование одного нейрона</h2>
<p>Изначально область нейронных сетей была в первую очередь ориентирована на моделирование биологических нейронных систем, но с тех пор она расширилась и стала заниматься разработкой и достижением хороших результатов в задачах машинного обучения. Тем не менее, мы начнём наше обсуждение с очень краткого и общего описания биологической системы, которая послужила источником вдохновения для значительной части этой области.  </p>
<h3>Биологическая мотивация и связи</h3>
<p>Основной вычислительной единицей мозга является <strong>нейрон</strong>. В нервной системе человека насчитывается около 86 миллиардов нейронов, и они соединены примерно с <strong>10^14</strong> — <strong>10^15</strong> <strong>синапсами</strong>. На схеме ниже показан схематичный рисунок биологического нейрона (сверху) и распространённая математическая модель (снизу). Каждый нейрон получает входные сигналы от своих <strong>дендритов</strong> и выдаёт выходные сигналы по своему (единственному) <strong>аксону</strong>. В конечном итоге аксон разветвляется и соединяется через синапсы с дендритами других нейронов. В вычислительной модели нейрона сигналы, которые проходят по аксонам (например, <strong>\(x_0\)</strong> взаимодействуют мультипликативно (например, <strong>\(w_0 x_0\)</strong> с дендритами другого нейрона в зависимости от силы синапса (например, <strong>\(w_0\)</strong>. Идея заключается в том, что синаптические силы (веса <strong>w</strong>) являются обучаемыми и контролируют силу влияния (и его направление: возбуждающее (положительный вес) или тормозящее (отрицательный вес) одного нейрона на другой. В базовой модели дендриты передают сигнал в тело клетки, где он суммируется. Если итоговая сумма превышает определённый порог, нейрон может <em>сработать</em>, отправив импульс по своему аксону. В вычислительной модели мы предполагаем, что точное время срабатывания импульсов не имеет значения и что информация передаётся только частотой срабатывания. Основываясь на этой интерпретации, это <em>частотного кода</em>, мы моделируем <em>частоту срабатывания</em> нейрона с помощью <strong>функции активации f</strong>, которая представляет собой частоту импульсов вдоль аксона. Исторически сложилось так, что в качестве функции активации часто используется <strong>сигмоидальная функция σ</strong>, поскольку она принимает вещественные входные данные (силу сигнала после суммирования) и преобразует их в диапазон от 0 до 1. Подробнее об этих функциях активации мы поговорим далее в этом разделе.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/neuron.png"><br><img alt="" src="https://cs231n.github.io/assets/nn1/neuron_model.jpeg"><br>
  Карикатурное изображение биологического нейрона (<strong>сверху</strong>) и его математическая модель (<strong>снизу</strong>).  </p>
<hr>
<p>Пример кода для прямого распространения сигнала по одному нейрону может выглядеть следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="k">class</span> <span class="n">Neuron</span>(<span class="n">object</span>):
  <span class="c1"># ... </span>
  <span class="n">def</span> <span class="n">forward</span>(<span class="nb">self</span>, <span class="n">inputs</span>):
    <span class="s">""" assume inputs and weights are 1-D numpy arrays and bias is a number """</span>
    <span class="n">cell_body_sum</span> = <span class="n">np</span>.<span class="nb">sum</span>(<span class="n">inputs</span> * <span class="nb">self</span>.<span class="n">weights</span>) + <span class="nb">self</span>.<span class="n">bias</span>
    <span class="n">firing_rate</span> = <span class="mf">1.0</span> / (<span class="mf">1.0</span> + <span class="n">math</span>.<span class="nb">exp</span>(-<span class="n">cell_body_sum</span>)) <span class="c1"># sigmoid activation function</span>
    <span class="k">return</span> <span class="n">firing_rate</span>
</pre></div>

<p>Другими словами, каждый нейрон выполняет скалярное произведение входных данных и своих весов, добавляет смещение и применяет нелинейность (или функцию активации), в данном случае сигмоидальную ** sigmoid \(\sigma(x) = 1/(1+e^{-x})\)**. Более подробно о различных функциях активации мы расскажем в конце этого раздела.  </p>
<p><strong>Грубая модель</strong>. Важно подчеркнуть, что эта модель биологического нейрона является очень грубой: например, существует множество различных типов нейронов, каждый из которых обладает своими свойствами. Дендриты в биологических нейронах выполняют сложные нелинейные вычисления. Синапсы — это не просто один вес, это сложная нелинейная динамическая система. Известно, что точное время выходных импульсов во многих системах имеет большое значение, что позволяет предположить, что приближение кода скорости может не работать. Из-за всех этих и многих других упрощений будьте готовы к тому, что любой, кто разбирается в нейробиологии, будет возмущаться, если вы проведёте аналогию между нейронными сетями и реальным мозгом. Если вам интересно, ознакомьтесь с этим <a href="https://physics.ucsd.edu/neurophysics/courses/physics_171/annurev.neuro.28.061604.135703.pdf">обзором</a> (в формате pdf) или с этим <a href="http://www.sciencedirect.com/science/article/pii/S0959438814000130">обзором</a>, опубликованным недавно.  </p>
<h3>Одиночный нейрон как линейный классификатор</h3>
<p>Математическая форма прямого вычисления модели нейрона может показаться вам знакомой. Как мы видели на примере линейных классификаторов, нейрон может «любить» (активация близка к единице) или «не любить» (активация близка к нулю) определённые линейные области своего входного пространства. Следовательно, с помощью подходящей функции потерь на выходе нейрона мы можем превратить один нейрон в линейный классификатор:  </p>
<p><strong>Бинарный классификатор Softmax</strong>. Например, мы можем интерпретировать <strong>\(\sigma(\sum_i * w_i * x_i + b)\ )</strong>,как вероятность_ одного из классов <strong>\(P(y_i = 1 \mid x_i; w) \)</strong>. Вероятность появления другого класса была бы равна <strong>\(P(y_i = 0 \mid x_i; w) = 1 - P(y_i = 1 \mid x_i; w) \)</strong>, так как их сумма должна быть равна единице. С помощью этой интерпретации мы можем сформулировать функцию потерь перекрёстной энтропии, как мы видели в разделе «Линейная классификация», и оптимизация этой функции приведёт к созданию бинарного классификатора Softmax (также известного как <em>логистическая регрессия</em>). Поскольку сигмоидальная функция принимает значения от 0 до 1, прогнозы этого классификатора основаны на том, превышает ли выходное значение нейрона <strong>0,5</strong>.  </p>
<p><strong>Бинарный классификатор SVM</strong>. В качестве альтернативы мы могли бы добавить к выходу нейрона функцию потерь с максимальным зазором и обучить его как бинарную машину опорных векторов.  </p>
<p><strong>Интерпретация регуляризации</strong>. В этом биологическом контексте потеря регуляризации в обоих случаях SVM/Softmax может быть интерпретирована как постепенное забывание, поскольку она приводит к уменьшению всех синаптических весов <strong>w</strong> приближается к нулю после каждого обновления параметра.  </p>
<blockquote>
<p>Один нейрон можно использовать для реализации бинарного классификатора (например, бинарного классификатора Softmax или бинарного классификатора SVM)  </p>
</blockquote>
<h3>Часто используемые функции активации</h3>
<p>Каждая функция активации (или <em>нелинейность</em>) принимает одно число и выполняет над ним определённую фиксированную математическую операцию. На практике вы можете столкнуться с несколькими функциями активации: </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/sigmoid.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/nn1/tanh.jpeg"><br><strong>Сверху</strong>: сигмоидальная нелинейность сжимает действительные числа до диапазона <strong>[0,1]</strong>.<br><strong>Справа</strong>: нелинейность tanh сжимает действительные числа до диапазона <strong>[-1,1]</strong>.  </p>
<hr>
<p><strong>Сигмоида</strong>. Сигмоидальная нелинейность имеет математическую форму <strong>\(\sigma(x) = 1 / (1 + e^{-x})\)</strong>. Она показана на изображении выше слева. Как упоминалось в предыдущем разделе, она принимает вещественное число и «сжимает» его до диапазона <strong>от 0 до 1</strong>. В частности, большие отрицательные числа становятся равными <strong>0</strong>, а большие положительные числа становятся равными <strong>1</strong>. Сигмоидальная функция часто использовалась в прошлом, так как её можно интерпретировать как частоту срабатывания нейрона: от полного отсутствия срабатывания (<strong>0</strong>) до полного срабатывания с предполагаемой максимальной частотой (<strong>1</strong>). На практике сигмоидальная нелинейность в последнее время вышла из моды и используется редко. У неё есть два основных недостатка:<br>
- <em>Сигмоиды насыщаются и уничтожают градиенты</em>. Очень нежелательное свойство сигмоидального нейрона заключается в том, что, когда активация нейрона насыщается на одном из концов <strong>0</strong> или <strong>1</strong>, градиент в этих областях почти равен нулю. Напомним, что во время обратного распространения ошибки этот (локальный) градиент будет умножен на градиент выхода этого нейрона для всей задачи. Поэтому, если локальный градиент очень мал, он фактически «уничтожит» градиент, и почти никакой сигнал не пройдёт через нейрон к его весам и рекурсивно к его данным. Кроме того, необходимо соблюдать особую осторожность при инициализации весов сигмоидальных нейронов, чтобы предотвратить перегрузку. Например, если начальные веса слишком велики, то большинство нейронов будут перегружены, и сеть едва ли будет обучаться.<br>
- <em>Сигмоидальные выходные данные не центрированы по нулю</em>. Это нежелательно, так как нейроны на более поздних уровнях обработки в нейронной сети (подробнее об этом позже) будут получать данные, не центрированные по нулю. Это влияет на динамику во время градиентного спуска, потому что если данные, поступающие в нейрон, всегда положительные (например, <strong>x&gt;0</strong> поэлементно в <strong>\(f = w^Tx + b\)</strong>)), тогда градиент по весам <strong>w</strong> во время обратного распространения ошибки все значения станут либо положительными, либо отрицательными (в зависимости от градиента всего выражения <strong>f</strong>). Это может привести к нежелательной зигзагообразной динамике в обновлении градиентов весовых коэффициентов. Однако обратите внимание, что после суммирования этих градиентов по пакету данных окончательное обновление весовых коэффициентов может иметь разные знаки, что несколько смягчает эту проблему. Таким образом, это неудобство, но его последствия менее серьёзны по сравнению с проблемой насыщенной активации, описанной выше.  </p>
<p><strong>Tanh</strong>. Нелинейность tanh показана на изображении выше снизу. Она сжимает вещественное число до диапазона <strong>[-1, 1]</strong>. Как и в случае с сигмоидальным нейроном, его активация насыщается, но, в отличие от сигмоидального нейрона, его выходная величина смещена относительно нуля. Поэтому на практике <em>нелинейность tanh всегда предпочтительнее сигмоидальной нелинейности</em>. Также обратите внимание, что нейрон tanh — это просто масштабированный сигмоидальный нейрон, из-за чего, в частности, верно следующее: <strong>\( \tanh(x) = 2 \sigma(2x) -1  \)</strong>.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/relu.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/nn1/alexplot.jpeg"></p>
<p><strong>Сверху</strong>: функция активации выпрямленной линейной единицы (<em>ReLU</em>), которая равна нулю, когда <strong>x &lt; 0</strong>, а затем линейна с наклоном <strong>1</strong>, когда <strong>x &gt; 0</strong>. <br><strong>Снизу</strong>: график из статьи <a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">Крижевски и др.</a> (pdf), показывающий 6-кратное улучшение сходимости с модулем ReLU по сравнению с модулем tanh.  </p>
<hr>
<p><strong>ReLU</strong>. Выпрямленный линейный блок стал очень популярным в последние несколько лет. Он вычисляет функцию <strong>\(f(x) = \max(0, x)\)</strong>. Другими словами, активация просто ограничивается нулём (см. изображение выше сверху). У использования <em>ReLU</em> есть несколько плюсов и минусов:</p>
<ul>
<li>(+) Было обнаружено, что она значительно ускоряет (например, в 6 раз в <a href="http://www.cs.toronto.edu/~fritz/absps/imagenet.pdf">Крижевски и др.</a>) сходимость стохастического градиентного спуска по сравнению с сигмоидальными/тангенциальными функциями. Утверждается, что это связано с её линейной, ненасыщаемой формой.</li>
<li>(+) По сравнению с нейронами tanh/сигмоидными нейронами, которые требуют дорогостоящих операций (экспоненциальных и т. д.), <em>ReLU</em> можно реализовать, просто установив пороговое значение для матрицы активации равным нулю.</li>
<li>(-) К сожалению, блоки <em>ReLU</em> могут быть нестабильными во время обучения и могут <em>«умирать»</em> . Например, большой градиент, проходящий через нейрон ReLU, может привести к обновлению весов таким образом, что нейрон больше никогда не активируется ни для одной точки данных. Если это произойдёт, то градиент, проходящий через блок, с этого момента будет равен нулю. То есть блоки <em>ReLU</em> могут необратимо <em>«умирать»</em> во время обучения, поскольку они могут быть отброшены от множества данных. Например, если скорость обучения установлена слишком высокой, вы можете обнаружить, что до <strong>40%</strong> вашей сети могут быть <em>«мёртвыми»</em> (то есть нейроны, которые никогда не активируются на протяжении всего набора обучающих данных). При правильной настройке скорости обучения эта проблема возникает реже.  </li>
</ul>
<p><strong>Протекающий ReLU</strong>. Протекающий <em>ReLU</em> — это одна из попыток решить проблему <em>«умирающего</em> <em>ReLU»</em>. Вместо того чтобы быть равной нулю при <strong>x &lt; 0</strong>, функция просачивающегося <em>ReLU</em> будет иметь небольшой положительный наклон (около <strong>0,01</strong>). То есть функция вычисляет <strong>\(f(x) = \mathbb{1}(x &lt; 0) (\alpha x) + \mathbb{1}(x&gt;=0) (x) \) where \(\alpha\)</strong>, где <strong>α</strong>- это небольшая константа. Некоторые люди сообщают об успехах с использованием этой формы функции активации, но результаты не всегда стабильны. Наклон в отрицательной области также может быть параметром каждого нейрона, как в случае с нейронами <em>PReLU</em>, представленными в работе <a href="http://arxiv.org/abs/1502.01852">«Глубокое погружение в выпрямители»</a> Кайминга Хэ и др., 2015. Однако в настоящее время неясно, насколько стабильны преимущества при выполнении разных задач.  </p>
<p><strong>Maxout</strong>. Были предложены другие типы устройств, которые не имеют функциональной формы <strong>\(f(w^Tx + b)\)</strong>, где нелинейность применяется к скалярному произведению весов и данных. Одним из относительно популярных вариантов является нейрон Maxout (введённый недавно <a href="https://arxiv.org/abs/1302.4389">Goodfellowи др.</a>), который обобщает ReLU и его неидеальную версию. Нейрон Maxout вычисляет функцию <strong>\(\max(w_1^Tx+b_1, w_2^Tx + b_2)\)</strong>. Обратите внимание, что и <em>ReLU</em>, и <em>Leaky</em> <em>ReLU</em> являются частным случаем этой формы (например, для <em>ReLU</em> мы имеем <strong>\(w_1, b_1 = 0\)</strong>). Таким образом, нейрон Maxout обладает всеми преимуществами блока <em>ReLU</em> (линейный режим работы, отсутствие насыщения) и не имеет его недостатков (умирающий <em>ReLU</em>). Однако, в отличие от нейронов <em>ReLU</em>, он удваивает количество параметров для каждого отдельного нейрона, что приводит к большому общему количеству параметров.  </p>
<p>На этом мы завершаем обсуждение наиболее распространённых типов нейронов и их функций активации. В качестве последнего комментария: очень редко в одной сети сочетаются разные типы нейронов, хотя в этом нет принципиальных проблем.  </p>
<p><strong>TLDR</strong>: <em>«Какой тип нейронов мне следует использовать?»</em> Используйте нелинейность <em>ReLU</em>, будьте осторожны с темпами обучения и, возможно, отслеживайте долю «мёртвых» нейронов в сети. Если вас это беспокоит, попробуйте <em>Leaky</em> <em>ReLU</em> или Maxout. Никогда не используйте сигмоид. Попробуйте tanh, но будьте готовы к тому, что он будет работать хуже, чем <em>ReLU</em>/<em>Maxout</em>.  </p>
<h2>Архитектуры нейронных сетей</h2>
<h3>Многоуровневая организация</h3>
<p><strong>Нейронные сети как нейроны в графах</strong>. Нейронные сети моделируются как совокупности нейронов, соединённых в ациклический граф. Другими словами, выходные данные одних нейронов могут становиться входными данными для других нейронов. Циклы недопустимы, так как это привело бы к бесконечному циклу при прямом проходе сети. Вместо аморфных скоплений соединённых нейронов модели нейронных сетей часто состоят из отдельных слоёв нейронов. Для обычных нейронных сетей наиболее распространённым типом слоёв является <strong>слой с полной связью</strong>, в котором нейроны между двумя соседними слоями полностью соединены попарно, но нейроны в пределах одного слоя не имеют общих связей. Ниже приведены два примера топологий нейронных сетей, в которых используется набор слоёв с полной связью:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/neural_net.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/nn1/neural_net2.jpeg"><br><strong>Сверху</strong>: двухслойная нейронная сеть (один скрытый слой из 4 нейронов (или единиц) и один выходной слой из 2 нейронов) с тремя входами. <strong>Снизу</strong>: трёхслойная нейронная сеть с тремя входами, двумя скрытыми слоями по 4 нейрона в каждом и одним выходным слоем. Обратите внимание, что в обоих случаях между нейронами разных слоёв есть связи (синапсы), но не внутри слоя.  </p>
<hr>
<p><strong>Соглашения об именовании</strong>. Обратите внимание, что, когда мы говорим о N-слойной нейронной сети, мы не учитываем входной слой. Таким образом, однослойная нейронная сеть — это сеть без скрытых слоёв (входные данные напрямую преобразуются в выходные). В этом смысле иногда можно услышать, что логистическая регрессия или метод опорных векторов — это просто частный случай однослойных нейронных сетей. Вы также можете услышать, что эти сети называют <em>«искусственными нейронными сетями»</em> (ИНС) или <em>«многослойными перцептронами»</em> (МПП). Многим не нравятся аналогии между нейронными сетями и реальным мозгом, и они предпочитают называть нейроны <em>единицами</em>.  </p>
<p><strong>Выходной слой</strong>. В отличие от всех остальных слоёв нейронной сети, нейроны выходного слоя чаще всего не имеют функции активации (или можно считать, что у них линейная функция активации). Это связано с тем, что последний выходной слой обычно используется для представления оценок классов (например, при классификации), которые являются произвольными действительными числами, или для представления некоторой действительной цели (например, при регрессии).  </p>
<p><strong>Размер нейронных сетей</strong>. Два показателя, которые обычно используются для измерения размера нейронных сетей, — это количество нейронов или, чаще, количество параметров. Рассмотрим две сети на рисунке выше:
- В первой сети (слева) <strong>4 + 2 = 6</strong> нейронов (не считая входных данных), <strong>(3 x 4) + (4 x 2) = 20</strong> весовых коэффициентов и <strong>4 + 2 = 6</strong> смещений, всего 26 обучаемых параметров.
- Во второй сети (<strong>справа</strong>) <strong>4 + 4 + 1 = 9</strong> нейронов, <strong>(3 x 4) + (4 x 4) + (4 x 1) = 12 + 16 + 4 = 32</strong> весовых коэффициента и <strong>4 + 4 + 1 = 9</strong> смещений, всего <strong>41 обучаемый параметр</strong>.  </p>
<p>Для сравнения: современные свёрточные нейронные сети содержат порядка 100 миллионов параметров и обычно состоят примерно из 10–20 слоёв (отсюда <em>глубокое обучение</em>). Однако, как мы увидим, количество <em>эффективных</em> связей значительно больше из-за совместного использования параметров. Подробнее об этом в модуле «Свёрточные нейронные сети».  </p>
<h3>Пример вычисления с прямой связью</h3>
<p><em>Повторное матричное умножение в сочетании с функцией активации</em>. Одна из основных причин, по которой нейронные сети организованы в виде слоёв, заключается в том, что такая структура позволяет очень просто и эффективно оценивать нейронные сети с помощью матричных векторных операций. Если рассматривать трёхслойную нейронную сеть на приведённой выше схеме, то входными данными будет вектор <strong>[3x1]</strong>. Все весовые коэффициенты для слоя можно хранить в одной матрице. Например, веса первого скрытого слоя <code>W1</code> будут иметь размер <strong>[4x3]</strong>, а смещения для всех нейронов будут находиться в векторе <code>b1</code> размером <strong>[4x1]</strong>. Здесь каждый нейрон имеет свои веса в строке <code>W1</code>, поэтому умножение матрицы на вектор <code>np.dot(W1,x)</code> вычисляет активации всех нейронов в этом слое. Аналогично, <code>W2</code> будет матрицей <strong>[4x4]</strong>, которая хранит связи второго скрытого слоя, а <code>W3</code> — матрицей <strong>[1x4]</strong> для последнего (выходного) слоя. Полный прямой проход этой трёхслойной нейронной сети — это просто три матричных умножения, объединённых с применением функции активации:  </p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">forward</span><span class="o">-</span><span class="nv">pass</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="mi">3</span><span class="o">-</span><span class="nv">layer</span><span class="w"> </span><span class="nv">neural</span><span class="w"> </span><span class="nv">network</span>:
<span class="nv">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">lambda</span><span class="w"> </span><span class="nv">x</span>:<span class="w"> </span><span class="mi">1</span>.<span class="mi">0</span><span class="o">/</span><span class="ss">(</span><span class="mi">1</span>.<span class="mi">0</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">np</span>.<span class="nv">exp</span><span class="ss">(</span><span class="o">-</span><span class="nv">x</span><span class="ss">))</span><span class="w"> </span>#<span class="w"> </span><span class="nv">activation</span><span class="w"> </span><span class="nv">function</span><span class="w"> </span><span class="ss">(</span><span class="nv">use</span><span class="w"> </span><span class="nv">sigmoid</span><span class="ss">)</span>
<span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">np</span>.<span class="k">random</span>.<span class="nv">randn</span><span class="ss">(</span><span class="mi">3</span>,<span class="w"> </span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span>#<span class="w"> </span><span class="k">random</span><span class="w"> </span><span class="nv">input</span><span class="w"> </span><span class="nv">vector</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">three</span><span class="w"> </span><span class="nv">numbers</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span><span class="nv">x1</span><span class="ss">)</span>
<span class="nv">h1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">f</span><span class="ss">(</span><span class="nv">np</span>.<span class="nv">dot</span><span class="ss">(</span><span class="nv">W1</span>,<span class="w"> </span><span class="nv">x</span><span class="ss">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">b1</span><span class="ss">)</span><span class="w"> </span>#<span class="w"> </span><span class="nv">calculate</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">hidden</span><span class="w"> </span><span class="nv">layer</span><span class="w"> </span><span class="nv">activations</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span><span class="nv">x1</span><span class="ss">)</span>
<span class="nv">h2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">f</span><span class="ss">(</span><span class="nv">np</span>.<span class="nv">dot</span><span class="ss">(</span><span class="nv">W2</span>,<span class="w"> </span><span class="nv">h1</span><span class="ss">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">b2</span><span class="ss">)</span><span class="w"> </span>#<span class="w"> </span><span class="nv">calculate</span><span class="w"> </span><span class="nv">second</span><span class="w"> </span><span class="nv">hidden</span><span class="w"> </span><span class="nv">layer</span><span class="w"> </span><span class="nv">activations</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span><span class="nv">x1</span><span class="ss">)</span>
<span class="nv">out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">np</span>.<span class="nv">dot</span><span class="ss">(</span><span class="nv">W3</span>,<span class="w"> </span><span class="nv">h2</span><span class="ss">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nv">b3</span><span class="w"> </span>#<span class="w"> </span><span class="nv">output</span><span class="w"> </span><span class="nv">neuron</span><span class="w"> </span><span class="ss">(</span><span class="mi">1</span><span class="nv">x1</span><span class="ss">)</span>
</pre></div>

<p>В приведённом выше коде <code>W1,W2,W3,b1,b2,b3</code> — это обучаемые параметры сети. Обратите внимание, что вместо одного входного вектора-столбца переменная <code>x</code> может содержать целую выборку обучающих данных (где каждый входной пример будет столбцом <code>x</code>), и тогда все примеры будут эффективно обрабатываться параллельно. Обратите внимание, что последний слой нейронной сети обычно не имеет функции активации (например, он представляет собой (числовое) значение класса в задаче классификации).  </p>
<blockquote>
<p>Прямой проход полносвязного слоя соответствует одному умножению матриц, за которым следует смещение и функция активации.  </p>
</blockquote>
<h3>Представительская власть</h3>
<p>Один из способов взглянуть на нейронные сети с полносвязными слоями заключается в том, что они определяют семейство функций, параметры которых задаются весовыми коэффициентами сети. Возникает естественный вопрос: какова репрезентативная мощность этого семейства функций? В частности, существуют ли функции, которые нельзя смоделировать с помощью нейронной сети?  </p>
<p>Оказывается, что нейронные сети, содержащие хотя бы один скрытый слой, являются универсальными аппроксиматорами. То есть можно показать (например, см. <a href="http://www.dartmouth.edu/~gvc/Cybenko_MCSS.pdf">«Аппроксимацию суперпозициями сигмоидальных функций»</a> 1989 года (pdf) или это <a href="http://neuralnetworksanddeeplearning.com/chap4.html">интуитивное объяснение</a> Майкла Нильсена), что для любой непрерывной функции <strong>f(x)</strong> и некоторые <strong>ϵ&gt;0</strong>, существует Нейронная сеть <strong>g(x)_ с одним скрытым слоем (с разумным выбором нелинейности, например, сигмоидальной) таким образом, что </strong>∀x,∣f(x)−g(x)∣&lt;ϵ__. Другими словами, нейронная сеть может аппроксимировать любую непрерывную функцию.  </p>
<p>Если для аппроксимации любой функции достаточно одного скрытого слоя, зачем использовать больше слоёв и углубляться в детали? Ответ заключается в том, что тот факт, что двухслойная нейронная сеть является универсальным аппроксиматором, хоть и выглядит красиво с математической точки зрения, на практике является относительно слабым и бесполезным утверждением. В одномерном пространстве функция «сумма пиков индикаторов» <strong>\(g(x) = \sum_i c_i \mathbb{1}(a_i &lt; x &lt; b_i)\)</strong>, где <strong>\(a,b,c\)</strong>. Векторы параметров также являются универсальным аппроксиматором, но никто не предлагает использовать эту функциональную форму в машинном обучении. Нейронные сети хорошо работают на практике, потому что они компактно выражают красивые, плавные функции, которые хорошо согласуются со статистическими свойствами данных, с которыми мы сталкиваемся на практике, а также легко обучаются с помощью наших алгоритмов оптимизации (например, градиентного спуска). Точно так же тот факт, что более глубокие сети (с несколькими скрытыми слоями) могут работать лучше, чем сети с одним скрытым слоем, является эмпирическим наблюдением, несмотря на то, что их репрезентативная мощность одинакова.  </p>
<p>Кстати, на практике часто бывает так, что 3-слойные нейронные сети превосходят 2-слойные, но ещё большее количество слоёв (4, 5, 6) редко приносит большую пользу. Это резко контрастирует с свёрточными сетями, где глубина оказалась чрезвычайно важным компонентом для хорошей системы распознавания (например, порядка 10 обучаемых слоёв). Один из аргументов в пользу этого наблюдения заключается в том, что изображения имеют иерархическую структуру (например, лица состоят из глаз, которые состоят из контуров и т. д.), поэтому несколько уровней обработки интуитивно понятны для этой области данных.  </p>
<p>Полная история, конечно, гораздо сложнее и является предметом многочисленных недавних исследований. Если вас интересуют эти темы, мы рекомендуем вам прочитать:
 - <a href="http://www.deeplearningbook.org/">Книга «Глубокое обучение»</a> Бенджио, Гудфеллоу, Курвиля, в частности <a href="http://www.deeplearningbook.org/contents/mlp.html">глава 6.4</a>.
 - <a href="http://arxiv.org/abs/1312.6184">Действительно ли Глубокие сети должны быть глубокими?</a>
 - <a href="http://arxiv.org/abs/1412.6550">ФитНеты: Советы для тонких глубоких Сеток</a>  </p>
<h3>Настройка количества слоев и их размеров</h3>
<p>Как мы решаем, какую архитектуру использовать, когда сталкиваемся с практической задачей? Следует ли нам использовать несколько скрытых слоёв? Один скрытый слой? Два скрытых слоя? Насколько большим должен быть каждый слой? Во-первых, обратите внимание, что по мере увеличения размера и количества слоёв в нейронной сети <strong>ёмкость</strong> сети увеличивается. То есть пространство представимых функций растёт, поскольку нейроны могут взаимодействовать для выражения множества различных функций. Например, предположим, что у нас есть задача бинарной классификации в двух измерениях. Мы могли бы обучить три отдельные нейронные сети, каждая из которых имеет один скрытый слой определённого размера, и получить следующие классификаторы:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/layer_sizes.jpeg"><br>
 Более крупные нейронные сети могут представлять более сложные функции. Данные показаны в виде кружков, окрашенных в соответствии с их классом, а под ними показаны области принятия решений обученной нейронной сетью. Вы можете поиграть с этими примерами в этой <a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/classify2d.html">демо-версии ConvNetsJS</a>.  </p>
<hr>
<p>На приведённой выше схеме мы видим, что нейронные сети с большим количеством нейронов могут выполнять более сложные функции. Однако это одновременно и благо (поскольку мы можем научиться классифицировать более сложные данные), и проклятие (поскольку легче переобучиться на обучающих данных). <strong>Переобучение</strong> происходит, когда модель с высокой способностью к обучению подстраивается под шум в данных, а не под (предполагаемую) основную закономерность. Например, модель с 20 скрытыми нейронами подстраивается под все обучающие данные, но за счёт разделения пространства на множество непересекающихся красных и зелёных областей принятия решений. Модель с 3 скрытыми нейронами способна классифицировать данные только в общих чертах. Она моделирует данные как два сгустка и интерпретирует несколько красных точек внутри зелёного кластера как <strong>выбросы</strong> (шум). На практике это может привести к лучшему <strong>обобщению</strong> на тестовом наборе данных.  </p>
<p>Исходя из нашего обсуждения выше, можно сделать вывод, что нейронные сети меньшего размера предпочтительнее, если данные недостаточно сложны, чтобы предотвратить переобучение. Однако это неверно — существует множество других предпочтительных способов предотвращения переобучения в нейронных сетях, которые мы обсудим позже (например, регуляризация <strong>\(L_2\)</strong>, отсев, входной шум). На практике всегда лучше использовать эти методы для контроля переобучения, а не количество нейронов.  </p>
<p>Тонкая причина этого заключается в том, что небольшие сети сложнее обучать с помощью локальных методов, таких как градиентный спуск: очевидно, что у их функций потерь относительно мало локальных минимумов, но оказывается, что многие из этих минимумов легче достигаются и являются плохими (то есть с высокими потерями). И наоборот, более крупные нейронные сети содержат значительно больше локальных минимумов, но эти минимумы оказываются гораздо лучше с точки зрения фактических потерь. Поскольку нейронные сети являются невыпуклыми, их свойства трудно изучать математически, но были предприняты некоторые попытки понять эти целевые функции, например, в недавней статье <a href="http://arxiv.org/abs/1412.0233">«Поверхности потерь в многослойных сетях»</a>. На практике вы обнаружите, что если вы обучаете небольшую сеть, то конечные потери могут сильно варьироваться — в некоторых случаях вам везёт, и вы сходитесь к хорошему результату, но в некоторых случаях вы застреваете в одном из плохих минимумов. С другой стороны, если вы обучите большую сеть, вы начнёте находить множество различных решений, но разброс в итоговых потерях будет намного меньше. Другими словами, все решения примерно одинаково хороши и в меньшей степени зависят от случайной инициализации.  </p>
<p>Повторюсь, сила регуляризации — предпочтительный способ контроля переобучения нейронной сети. Мы можем рассмотреть результаты, полученные при трёх различных настройках:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/reg_strengths.jpeg"><br>
Влияние силы регуляризации: каждая из приведённых выше нейронных сетей имеет 20 скрытых нейронов, но изменение силы регуляризации делает области окончательного принятия решений более плавными при более высокой регуляризации. Вы можете поиграть с этими примерами в <a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/classify2d.html">демонстрационной версии ConvNetsJS</a>.  </p>
<hr>
<p>Вывод заключается в том, что вам не следует использовать более мелкие сети, потому что вы боитесь переобучения. Вместо этого вам следует использовать настолько большую нейронную сеть, насколько позволяет ваш вычислительный бюджет, и применять другие методы регуляризации для контроля переобучения.  </p>
<h2>Краткие сведения</h2>
<p>Подводя итог:
- Мы представили очень грубую модель биологического <strong>нейрона</strong>.
- Мы рассмотрели несколько типов <strong>функций активации</strong>, которые используются на практике, и наиболее распространённым из них является ReLU.
- Мы представили <strong>нейронные сети</strong>, в которых нейроны соединены <strong>полностью связанными слоями</strong>, где нейроны в соседних слоях имеют полные парные связи, но нейроны внутри слоя не соединены.
- Мы увидели, что эта многоуровневая архитектура позволяет очень эффективно оценивать нейронные сети на основе матричных умножений, объединённых с применением функции активации.
- Мы увидели, что нейронные сети являются <strong>универсальными аппроксиматорами функций</strong>, но мы также обсудили тот факт, что это свойство мало связано с их повсеместным использованием. Они используются потому, что делают определённые «правильные» предположения о функциональных формах функций, которые встречаются на практике.
- Мы обсудили тот факт, что более крупные сети всегда будут работать лучше, чем сети меньшего размера, но их более высокая пропускная способность должна соответствующим образом регулироваться с помощью более сильной регуляризации (например, более высокого затухания весов), иначе они могут переобучаться. В следующих разделах мы рассмотрим другие формы регуляризации (особенно отсев).  </p>
<h2>Дополнительные ссылки</h2>
<ul>
<li>
<a href="http://www.deeplearning.net/tutorial/mlp.html">deeplearning.net учебное пособие</a> с Theano</li>
<li>
<a href="http://cs.stanford.edu/people/karpathy/convnetjs/">ConvNetJS</a> демонстрации для интуиции</li>
<li><a href="http://neuralnetworksanddeeplearning.com/chap1.html">Учебные пособия Майкла Нильсена</a></li>
</ul>
</div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../backpropagation/" rel="prev" title="Обратное распространение ошибки">Предыдущая запись</a>
            </li>
            <li class="next">
                <a href="../convnets-2/" rel="next" title="Предобработка, инициализация весов, функции потерь">Следующая запись</a>
            </li>
        </ul></nav></aside><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script></article><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
