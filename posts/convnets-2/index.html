<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Предобработка, инициализация весов, функции потерь | Заметки по ML, DL</title>
<link href="../../assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="../../rss.xml">
<link rel="canonical" href="https://mldl.ru/posts/convnets-2/">
<!--[if lt IE 9]><script src="../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Андрей Лабинцев">
<link rel="prev" href="../convnets-1/" title="Сверточные сети. Введение" type="text/html">
<link rel="next" href="../convnets-3/" title="Обучение нейронных сетей" type="text/html">
<meta property="og:site_name" content="Заметки по ML, DL">
<meta property="og:title" content="Предобработка, инициализация весов, функции потерь">
<meta property="og:url" content="https://mldl.ru/posts/convnets-2/">
<meta property="og:description" content="Предобработка, инициализация весов, функции потерь
Содержание:
- Настройка данных и модели
    + Предварительная обработка данных
    + Инициализация веса
    + Нормализация партии
    + Регуляризация">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2025-03-09T19:42:16+03:00">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href="../../">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav">
<li class="nav-item">
    <a href="index.md" id="sourcelink" class="nav-link">Источник</a>
    </li>


                    
            </ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="../../archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="../../categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Предобработка, инициализация весов, функции потерь</a></h1>

        <div class="metadata">
            <p class="byline author vcard p-author h-card"><span class="byline-name fn p-name" itemprop="author">
                    Андрей Лабинцев
            </span></p>
            <p class="dateline">
            <a href="." rel="bookmark">
            <time class="published dt-published" datetime="2025-03-09T19:42:16+03:00" itemprop="datePublished" title="2025-03-09 19:42">2025-03-09 19:42</time></a>
            </p>
            
        <p class="sourceline"><a href="index.md" class="sourcelink">Источник</a></p>

        </div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <h2>Предобработка, инициализация весов, функции потерь</h2>
<p>Содержание:
- <a href=".">Настройка данных и модели</a>
    + <a href=".">Предварительная обработка данных</a>
    + <a href=".">Инициализация веса</a>
    + <a href=".">Нормализация партии</a>
    + <a href=".">Регуляризация</a> (L2/L1/Maxnorm/Dropout)
- <a href=".">Функции потерь</a>
- <a href=".">Краткая сводка</a>  </p>
<h2>Настройка данных и модели</h2>
<p>В предыдущем разделе мы представили модель нейрона, который вычисляет скалярное произведение с помощью нелинейности, и нейронные сети, которые объединяют нейроны в слои. Вместе эти решения определяют новую форму <strong>функции оценки</strong>, которую мы расширили по сравнению с простым линейным отображением, которое мы рассматривали в разделе «Линейная классификация». В частности, нейронная сеть выполняет последовательность линейных отображений с вложенными нелинейностями. В этом разделе мы обсудим дополнительные решения, касающиеся предварительной обработки данных, инициализации весов и функций потерь.  </p>
<h3>Предварительная обработка данных</h3>
<p>Существует три распространённые формы предварительной обработки данных в матрице данных <code>X</code>, где мы будем предполагать, что <code>X</code> имеет размер <code>[N x D]</code> (<code>N</code> — количество данных, <code>D</code> — их размерность).  </p>
<p><strong>Вычитание среднего значения</strong> — наиболее распространённая форма предварительной обработки. Она заключается в вычитании среднего значения для каждого отдельного признака в данных и имеет геометрическую интерпретацию центрирования облака данных вокруг начала координат по каждому измерению. В <strong>numpy</strong> эта операция будет реализована следующим образом: (<code>X -= np.mean(X, axis = 0)</code>. В случае с изображениями для удобства можно вычесть одно значение из всех пикселей (например, <code>X -= np.mean(X)</code>), либо сделать это отдельно для трёх цветовых каналов.  </p>
<p><strong>Нормализация</strong> — это приведение размерностей данных к примерно одинаковому масштабу. Существует два распространённых способа достижения такой нормализации:
- Один из них — разделить каждую размерность на её стандартное отклонение после центрирования по нулю: (<code>X /= np.std(X, axis = 0)</code>). 
- Другой способ предварительной обработки — нормализовать каждую размерность так, чтобы минимальное и максимальное значения по каждой размерности составляли -1 и 1 соответственно. Имеет смысл применять эту предварительную обработку только в том случае, если у вас есть основания полагать, что разные входные параметры имеют разные масштабы (или единицы измерения), но они должны быть примерно одинаково важны для алгоритма обучения. В случае изображений относительные масштабы пикселей уже примерно одинаковы (и находятся в диапазоне от 0 до 255), поэтому нет необходимости выполнять этот дополнительный этап предварительной обработки.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn2/prepro1.jpeg"><br>
Общий конвейер предварительной обработки данных. <strong>Слева</strong>: исходные данные, 2-мерные входные данные. <strong>В центре</strong>: данные центрируются по нулевому значению путём вычитания среднего значения в каждом измерении. Облако данных теперь центрировано относительно начала координат. <strong>Справа</strong>: каждое измерение дополнительно масштабируется с помощью стандартного отклонения. Красные линии указывают на границы данных — в центре они разной длины, а справа — одинаковой.  </p>
<hr>
<p><strong>Метод главных компонент и отбеливание</strong> — это ещё одна форма предварительной обработки. В этом процессе данные сначала центрируются, как описано выше. Затем мы можем вычислить ковариационную матрицу, которая показывает корреляционную структуру данных:  </p>
<div class="code"><pre class="code literal-block"><span class="c1"># Assume input data matrix X of size [N x D]</span>
<span class="n">X</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">axis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="c1"># zero-center the data (important)</span>
<span class="n">cov</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="c1"># get the data covariance matrix</span>
</pre></div>

<p>Элемент (i,j) ковариационной матрицы данных содержит ковариацию между i-м и j-м измерениями данных. В частности, диагональ этой матрицы содержит дисперсии. Кроме того, ковариационная матрица является симметричной и <a href="http://en.wikipedia.org/wiki/Positive-definite_matrix#Negative-definite.2C_semidefinite_and_indefinite_matrices">положительно определённой</a>. Мы можем вычислить разложение ковариационной матрицы данных по методу сингулярного разложения:  </p>
<div class="code"><pre class="code literal-block">U,S,V = np.linalg.svd(cov)
</pre></div>

<p>где столбцы <code>U</code> являются собственными векторами, а <code>S</code> — одномерным массивом сингулярных значений. Чтобы устранить корреляцию в данных, мы проецируем исходные (но центрированные по нулю) данные на собственный базис:  </p>
<div class="code"><pre class="code literal-block">Xrot = np.dot(X, U) # decorrelate the data
</pre></div>

<p>Обратите внимание, что столбцы <code>U</code> представляют собой набор ортогональных векторов (норма которых равна 1 и которые ортогональны друг другу), поэтому их можно рассматривать как базисные векторы. Таким образом, проекция соответствует повороту данных в <code>X</code> таким образом, чтобы новые оси были собственными векторами. Если бы мы вычислили ковариационную матрицу <code>Xrot</code>, то увидели бы, что теперь она диагональная. Преимущество <code>np.linalg.svd</code> в том, что в возвращаемом значении <code>U</code> столбцы собственных векторов отсортированы по собственным значениям. Мы можем использовать это для уменьшения размерности данных, используя только несколько главных собственных векторов и отбрасывая измерения, в которых данные не имеют дисперсии. Это также иногда называют <a href="http://en.wikipedia.org/wiki/Principal_component_analysis">анализом главных компонент (PCA)</a> для уменьшения размерности:  </p>
<div class="code"><pre class="code literal-block">Xrot_reduced = np.dot(X, U[:,:100]) # Xrot_reduced becomes [N x 100]
</pre></div>

<p>После этой операции мы уменьшили исходный набор данных размером [N x D] до размера [N x 100], сохранив 100 измерений данных, которые содержат наибольшую дисперсию. Очень часто можно добиться очень хорошей производительности, обучая линейные классификаторы или нейронные сети на наборах данных, уменьшенных с помощью метода главных компонент, что позволяет сэкономить место и время.  </p>
<p>Последнее преобразование, которое вы можете увидеть на практике, — это <strong>отбеливание</strong>. Операция отбеливания преобразует данные в собственный базис и делит каждое измерение на собственное значение, чтобы нормализовать масштаб. Геометрическая интерпретация этого преобразования заключается в том, что если исходные данные представляют собой многомерную гауссову функцию, то отбелённые данные будут представлять собой гауссову функцию с нулевым средним значением и единичной ковариационной матрицей. Этот шаг будет выглядеть следующим образом:  </p>
<div class="code"><pre class="code literal-block"># whiten the data:
# divide by the eigenvalues (which are square roots of the singular values)
Xwhite = Xrot / np.sqrt(S + 1e-5)  
</pre></div>

<p><em>Предупреждение: усиливается шум</em>. Обратите внимание, что мы добавляем <strong>1e-5</strong> (или небольшую константу), чтобы предотвратить деление на ноль. Одним из недостатков этого преобразования является то, что оно может сильно усиливать шум в данных, поскольку растягивает все измерения (включая несущественные измерения с небольшой дисперсией, которые в основном являются шумом) до одинакового размера на входе. На практике это можно смягчить более сильным сглаживанием (т. е. увеличив <strong>1e-5</strong> до большего числа).  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn2/prepro2.jpeg"></p>
<p>PCA / Отбеливание. <strong>Слева</strong>: оригинальная игрушка, 2-мерные входные данные. <strong>Посередине</strong>: после выполнения PCA. Данные центрируются на нуле, а затем поворачиваются в собственный базис ковариационной матрицы данных. Это декоррелирует данные (ковариационная матрица становится диагональной). <strong>Справа</strong>: каждое измерение дополнительно масштабируется по собственным значениям, преобразуя матрицу ковариации данных в единичную матрицу. Геометрически это соответствует растяжению и сжатию данных в изотропный гауссовский большой объект.  </p>
<hr>
<p>Мы также можем попытаться визуализировать эти преобразования с помощью изображений CIFAR-10. Обучающий набор CIFAR-10 имеет размер 50 000 x 3072, где каждое изображение растягивается в вектор-строку размером 3072. Затем мы можем вычислить ковариационную матрицу [3072 x 3072] и вычислить её разложение по методу сингулярного значения (что может быть относительно затратным). Как выглядят вычисленные собственные векторы визуально? Возможно, вам поможет изображение:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn2/cifar10pca.jpeg"><br><strong>Слева</strong>: пример набора из 49 изображений. <strong>2-е слева</strong>: 144 главных собственных вектора из 3072. Главные собственные векторы объясняют большую часть дисперсии данных, и мы видим, что они соответствуют более низким частотам на изображениях. <strong>2-е справа</strong>: 49 изображений, уменьшенных с помощью метода главных компонент с использованием 144 показанных здесь собственных векторов. То есть вместо того, чтобы представлять каждое изображение в виде 3072-мерного вектора, где каждый элемент — это яркость конкретного пикселя в определённом месте и на определённом канале, каждое изображение выше представлено только 144-мерным вектором, где каждый элемент показывает, какая часть каждого собственного вектора составляет изображение. Чтобы увидеть, какая информация об изображении содержится в этих 144 числах, мы должны вернуться к «пиксельному» базису из 3072 чисел. Поскольку <strong>U</strong> — это поворот, этого можно добиться, умножив на <code>U.transpose()[:144,:]</code>, а затем, визуализировав полученные 3072 числа в виде изображения, вы можете заметить, что изображения немного размыты, что отражает тот факт, что верхние собственные векторы захватывают более низкие частоты. Однако большая часть информации всё равно сохраняется. <strong>Справа</strong>: визуализация «белого» представления, в котором дисперсия по каждому из 144 измерений сжата до одинаковой длины. Здесь 144 «белых» числа возвращаются к пикселям изображения путём умножения на <code>U.transpose()[:144,:]</code>. Более низкие частоты (на которые изначально приходилось больше всего дисперсии) теперь незначительны, а более высокие частоты (на которые изначально приходилось относительно мало дисперсии) становятся более выраженными.  </p>
<hr>
<p><strong>На практике</strong>. Мы упоминаем метод главных компонент/отбеливание в этих заметках для полноты картины, но эти преобразования не используются в свёрточных сетях. Однако очень важно центрировать данные по нулевому значению, и часто также выполняется нормализация каждого пикселя.  </p>
<p><strong>Распространённая ошибка</strong>. Важно отметить, что любая статистика предварительной обработки (например, среднее значение данных) должна рассчитываться только на обучающих данных, а затем применяться к проверочным/тестовым данным. Например, вычисление среднего значения и вычитание его из каждого изображения во всём наборе данных, а затем разделение данных на обучающие/проверочные/тестовые, было бы ошибкой. Вместо этого среднее значение должно рассчитываться только на обучающих данных, а затем вычитаться из всех разделов (обучающих/проверочных/тестовых).  </p>
<h3>Инициализация веса</h3>
<p>Мы рассмотрели, как построить архитектуру нейронной сети и как предварительно обработать данные. Прежде чем приступить к обучению сети, необходимо инициализировать её параметры.  </p>
<p><strong>Ловушка: инициализация всех весов нулями</strong>. Давайте начнём с того, чего делать не следует. Обратите внимание, что мы не знаем, каким должно быть конечное значение каждого веса в обученной сети, но при правильной нормализации данных разумно предположить, что примерно половина весов будет положительной, а половина — отрицательной. Тогда разумной идеей может быть установка всех начальных весов в нулевое значение, что, как мы ожидаем, будет «наилучшим предположением». Это оказалось ошибкой, потому что если каждый нейрон в сети вычисляет один и тот же результат, значит все они также будут вычислять одни и те же градиенты во время обратного распространения ошибки и подвергаться одним и тем же обновлениям параметров. Другими словами, если веса нейронов инициализированы одинаково, то между ними не будет асимметрии.  </p>
<p><strong>Небольшие случайные числа</strong>. Поэтому мы по-прежнему хотим, чтобы весовые коэффициенты были очень близки к нулю, но, как мы уже говорили выше, не равнялись нулю. В качестве решения принято инициализировать весовые коэффициенты нейронов небольшими числами и называть это <em>нарушением симметрии</em>. Идея заключается в том, что изначально все нейроны случайны и уникальны, поэтому они будут вычислять разные обновления и интегрироваться в сеть как её различные части. Реализация для одной весовой матрицы может выглядеть так: <code>W = 0.01* np.random.randn(D,H)</code>, где <code>randn</code> — выборки из гауссианы с нулевым средним и единичным стандартным отклонением. При такой формулировке вектор весов каждого нейрона инициализируется как случайный вектор, выбранный из многомерной гауссианы, поэтому нейроны ориентированы в случайном направлении во входном пространстве. Также можно использовать небольшие числа, выбранные из равномерного распределения, но на практике это, по-видимому, относительно мало влияет на конечную производительность.  </p>
<p><em>Предупреждение</em>: не обязательно, что меньшие числа будут работать лучше. Например, слой нейронной сети с очень маленькими весами во время обратного распространения ошибки будет вычислять очень маленькие градиенты для своих данных (поскольку этот градиент пропорционален значению весов). Это может значительно уменьшить «сигнал градиента», проходящий через сеть в обратном направлении, и стать проблемой для глубоких сетей.  </p>
<p><strong>Калибровка дисперсии с помощью 1/sqrt(n)</strong>. Одна из проблем, связанных с вышеописанным предложением, заключается в том, что дисперсия выходных данных случайно инициализированного нейрона растёт с увеличением количества входных данных. Оказывается, мы можем нормализовать дисперсию выходных данных каждого нейрона до 1, масштабируя его вектор весов на квадратный корень из <em>количества входов</em> (т. е. количества входных данных). То есть рекомендуемая эвристика заключается в инициализации вектора весов каждого нейрона следующим образом: <code>w = np.random.randn(n) / sqrt(n)</code>, где <code>n</code> — количество входных данных. Это гарантирует, что все нейроны в сети изначально имеют примерно одинаковое распределение выходных данных, и эмпирически улучшает скорость сходимости.  </p>
<p><strong>Схема вывода выглядит следующим образом</strong>:Рассмотрим внутренний продукт <strong>\(s = \sum_i^n w_i x_i\)</strong> между весами <strong>w</strong> и входные данные <strong>x</strong>, что даёт исходную активацию нейрона до нелинейности. Мы можем изучить дисперсию <strong>s</strong>:  </p>
<p>$$
\begin{align}
\text{Var}(s) &amp;= \text{Var}(\sum_i^n w_ix_i) \\
&amp;= \sum_i^n \text{Var}(w_ix_i) \\
&amp;= \sum_i^n [E(w_i)]^2\text{Var}(x_i) + [E(x_i)]^2\text{Var}(w_i) + \text{Var}(x_i)\text{Var}(w_i) \\
&amp;= \sum_i^n \text{Var}(x_i)\text{Var}(w_i) \\
&amp;= \left( n \text{Var}(w) \right) \text{Var}(x)
\end{align}
$$  </p>
<p>где на первых двух этапах мы использовали <a href="http://en.wikipedia.org/wiki/Variance"> свойства дисперсии</a> . На третьем этапе мы предположили, что входные данные и веса имеют нулевое среднее значение, поэтому <strong>\(E[x_i] = E[w_i] = 0\)</strong>. Обратите внимание, что в общем случае это не так: например, блоки ReLU будут иметь положительное среднее значение. На последнем этапе мы предположили, что все <strong>\(w_i, x_i\)</strong> являются одинаково распределёнными. Из этого вывода следует, что если мы хотим <strong>s</strong> иметь ту же дисперсию, что и все его входные данные <strong>x</strong>, тогда во время инициализации мы должны убедиться, что дисперсия каждого веса <strong>w</strong> является <strong>1/n</strong>. Следовательно при учете <strong>\(\text{Var}(aX) = a^2\text{Var}(X)\)</strong>) для случайной величины <strong>X</strong> и скаляра <strong>a</strong> говорит о необходимости взять единичный гауссовское распределение, а затем масштабировать его <strong>\(a = \sqrt{1/n}\)</strong>, чтобы внести свой вклад в его дисперсию <strong>1/n</strong>. Это дает инициализацию <code>w = np.random.randn(n) / sqrt(n)</code>.  </p>
<p>Аналогичный анализ проводится в статье <a href="http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdf">«Понимание сложности обучения глубоких нейронных сетей прямого распространения»</a> Глоро и др. В этой статье авторы в итоге рекомендуют инициализацию в виде <strong>Var(w)=2/(nin+nout)</strong>, где <strong>\(n_in\), \(n_out)\</strong> - это количество единиц в предыдущем слое и в следующем слое. Это основано на компромиссе и эквивалентном анализе градиентов обратного распространения. В более поздней статье на эту тему <a href="http://arxiv-web3.library.cornell.edu/abs/1502.01852">«Глубокое изучение выпрямителей: превосходные результаты на уровне человека при классификации ImageNet»</a> Хе и др. выводится инициализация специально для нейронов ReLU, и делается вывод, что дисперсия нейронов в сети должна быть <strong>2.0/n</strong>. Это даёт инициализацию <code>w = np.random.randn(n) * sqrt(2.0/n)</code> и является текущей рекомендацией для использования на практике в конкретном случае нейронных сетей с нейронами ReLU.  </p>
<p><strong>Разреженная инициализация</strong>. Другой способ решить проблему некалиброванных дисперсий — установить все весовые матрицы в нулевое значение, но для нарушения симметрии каждый нейрон случайным образом соединяется (с весами, выбранными из небольшого гауссовского распределения, как описано выше) с фиксированным количеством нейронов под ним. Типичное количество нейронов, с которыми можно соединиться, может составлять всего 10.  </p>
<p><strong>Инициализация смещений</strong>. Можно и часто бывает нужно инициализировать смещения равными нулю, поскольку асимметрия устраняется с помощью небольших случайных чисел в весовых коэффициентах. Для нелинейностей ReLU некоторые предпочитают использовать небольшое постоянное значение, например <strong>0,01</strong>, для всех смещений, потому что это гарантирует, что все блоки ReLU срабатывают в начале и, следовательно, получают и передают некоторый градиент. Однако неясно, обеспечивает ли это стабильное улучшение (на самом деле некоторые результаты указывают на то, что это ухудшает производительность), и чаще всего используется просто инициализация с нулевым смещением.  </p>
<p>На практике в настоящее время рекомендуется использовать блоки ReLU и <code>w = np.random.randn(n) * sqrt(2.0/n)</code> в соответствии с <a href="http://arxiv-web3.library.cornell.edu/abs/1502.01852">Хе и др.</a>.  </p>
<h3>Нормализация партии</h3>
<p><strong>Нормализация с помощью пакетов</strong>. Недавно разработанная Иоффе и Сегеди техника под названием <a href="http://arxiv.org/abs/1502.03167">«Нормализация с помощью пакетов»</a> избавляет от многих проблем, связанных с правильной инициализацией нейронных сетей, поскольку в начале обучения активации во всей сети принудительно распределяются по единичному гауссовскому распределению. Основное наблюдение заключается в том, что это возможно, потому что нормализация — это простая дифференцируемая операция. При реализации этой техники обычно вставляется слой <strong>BatchNorm</strong> сразу после полносвязных слоёв (или свёрточных слоёв, как мы вскоре увидим) и перед нелинейностями. Мы не будем подробно останавливаться на этом методе, поскольку он хорошо описан в статье по ссылке, но отметим, что использование пакетной нормализации в нейронных сетях стало очень распространённой практикой. На практике сети, использующие пакетную нормализацию, значительно более устойчивы к неправильной инициализации. Кроме того, пакетную нормализацию можно интерпретировать как предварительную обработку на каждом слое сети, но интегрированную в саму сеть дифференцируемым образом. Здорово!  </p>
<h3>Регуляризация</h3>
<p>Существует несколько способов контроля возможностей нейронных сетей для предотвращения переобучения:  </p>
<p><strong>Регуляризация L2</strong> — это, пожалуй, самая распространённая форма регуляризации. Её можно реализовать, штрафуя за квадраты значений всех параметров непосредственно в целевой функции. То есть для каждого веса <strong>w</strong> в сети мы добавляем термин <strong>\(\frac{1}{2} \lambda w^2\)</strong> к цели, где <strong>λ</strong> является силой регуляризации. Обычно наблюдается фактор <strong>\(\frac{1}{2}\)</strong> впереди, потому что тогда градиент этого члена по отношению к параметру <strong>w</strong> это просто <strong>λw</strong> вместо <strong>2λw</strong>.Регуляризация <strong>\(L_2\)</strong> интуитивно понятна: она сильно штрафует векторы с пиковыми значениями и отдаёт предпочтение векторам с размытыми значениями. Как мы обсуждали в разделе «Линейная классификация», из-за мультипликативных взаимодействий между весами и входными данными это позволяет сети использовать все входные данные понемногу, а не некоторые из них — по максимуму. Наконец, обратите внимание, что при обновлении параметров методом градиентного спуска использование регуляризации <strong>\(L_2\)</strong> в конечном итоге означает, что каждый вес уменьшается линейно: <code>W += -lambda * W</code> по направлению к нулю.  </p>
<p><strong>Регуляризация L1</strong> — ещё одна относительно распространённая форма регуляризации, при которой для каждого веса <strong>w</strong> мы добавляем термин <strong>λ∣w∣</strong> к цели. Можно комбинировать регуляризацию <strong>\(L_1\)</strong> с регуляризацией <strong>\(L_2\)</strong>: <strong>\(\lambda_1 \mid w \mid + \lambda_2 w^2\)</strong> (это называется <a href="http://web.stanford.edu/~hastie/Papers/B67.2%20%282005%29%20301-320%20Zou%20&amp;%20Hastie.pdf">регуляризацией эластичной сети</a>). Регуляризация <strong>\(L_1\)</strong> обладает интригующим свойством: она приводит к тому, что весовые векторы во время оптимизации становятся разреженными (то есть очень близкими к нулю). Другими словами, нейроны с регуляризацией <strong>\(L_1\)</strong> в конечном итоге используют только разреженное подмножество наиболее важных входных данных и становятся почти невосприимчивыми к «зашумлённым» входным данным. Для сравнения, конечные весовые векторы при регуляризации <strong>\(L_2\)</strong> обычно представляют собой размытые, небольшие числа. На практике, если вас не интересует явный выбор признаков, можно ожидать, что регуляризация <strong>\(L_2\)</strong> будет работать лучше, чем регуляризация <strong>\(L_1\)</strong>.  </p>
<p><strong>Ограничения по максимальной норме</strong>. Другой формой регуляризации является установление абсолютной верхней границы для величины вектора весов каждого нейрона и использование проецируемого градиентного спуска для обеспечения соблюдения ограничения. На практике это соответствует обычному обновлению параметров, а затем обеспечению соблюдения ограничения путём ограничения вектора весов <strong>\(\vec{w}\)</strong> каждого нейрона, чтобы удовлетворить <strong>\(\Vert \vec{w} \Vert_2 &lt; c\)</strong>. Типичные значения <strong>c</strong>. Они составляют порядка 3 или 4. Некоторые пользователи сообщают об улучшениях при использовании этой формы регуляризации. Одно из её привлекательных свойств заключается в том, что сеть не может «взрывообразно» расти, даже если скорость обучения установлена слишком высокой, потому что обновления всегда ограничены.  </p>
<p><strong>Выпадение</strong> — чрезвычайно эффективный, простой и недавно представленный метод регуляризации, описанный Шриваставой и др. в <a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">«Выпадении: простом способе предотвращения переобучения нейронных сетей»</a> <em>(pdf)</em>, который дополняет другие методы (<strong>\(L_1\)</strong>, <strong>\(L_2\)</strong>, <em>maxnorm</em>). Во время обучения выпадение реализуется путём активации нейрона только с некоторой вероятностью <strong>p</strong> (гиперпараметр), или в противном случае установив его равным нулю.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn2/dropout.jpeg"></p>
<p>Рисунок, взятый из <a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">статьи о выпадении</a>, иллюстрирует эту идею. Во время обучения выпадение можно интерпретировать как выборку нейронной сети из полной нейронной сети и обновление параметров выбранной сети только на основе входных данных. (Однако экспоненциальное количество возможных выбранных сетей не является независимым, поскольку они имеют общие параметры.) Во время тестирования выпадение не применяется, а интерпретируется как оценка усреднённого прогноза по экспоненциально большому ансамблю всех подсетей (подробнее об ансамблях в следующем разделе).  </p>
<hr>
<p>Выпадение в примере трёхслойной нейронной сети будет реализовано следующим образом:  </p>
<p>```
 """ Vanilla Dropout: Not recommended implementation (see notes below) """</p>
<p>p = 0.5 # probability of keeping a unit active. higher = less dropout</p>
<p>def train_step(X):
  """ X contains the data """</p>
<p># forward pass for example 3-layer neural network
  H1 = np.maximum(0, np.dot(W1, X) + b1)
  U1 = np.random.rand(<em>H1.shape) &lt; p # first dropout mask
  H1 </em>= U1 # drop!
  H2 = np.maximum(0, np.dot(W2, H1) + b2)
  U2 = np.random.rand(<em>H2.shape) &lt; p # second dropout mask
  H2 </em>= U2 # drop!
  out = np.dot(W3, H2) + b3</p>
<p># backward pass: compute gradients... (not shown)
  # perform parameter update... (not shown)</p>
<p>def predict(X):
  # ensembled forward pass
  H1 = np.maximum(0, np.dot(W1, X) + b1) * p # NOTE: scale the activations
  H2 = np.maximum(0, np.dot(W2, H1) + b2) * p # NOTE: scale the activations
  out = np.dot(W3, H2) + b3
  ```  </p>
<p>В приведённом выше коде внутри функции <code>train_step</code> мы дважды применили отсев: на первом скрытом слое и на втором скрытом слое. Отсев также можно применить непосредственно на входном слое, в этом случае мы также создадим бинарную маску для входных данных <code>X</code>. Обратный проход остаётся неизменным, но, конечно, должен учитывать созданные маски <code>U1,U2</code>.  </p>
<p>Важно отметить, что в функции <code>predict</code> мы больше не отбрасываем значения, а выполняем масштабирование выходных значений скрытого слоя с помощью <strong>p</strong>.Это важно, потому что во время тестирования все нейроны видят все свои входные данные, поэтому мы хотим, чтобы выходные данные нейронов во время тестирования были идентичны ожидаемым выходным данным во время обучения. Например, в случае <strong>p=0.5</strong>. Нейроны должны вдвое уменьшить свои выходные данные во время тестирования, чтобы получить те же выходные данные, что и во время обучения (в среднем). Чтобы понять это, рассмотрим выходные данные нейрона <strong>x</strong> (до отбрасывания). При отбрасывании ожидаемый результат от этого нейрона станет <strong>px+(1−p)0</strong>, потому что выходной сигнал нейрона с вероятностью будет равен нулю <strong>1−p</strong>. Во время тестирования, когда мы поддерживаем постоянную активность нейрона, мы должны корректировать <strong>x→px</strong>, чтобы сохранить ожидаемый результат. Также можно показать, что выполнение этого ослабления во время тестирования может быть связано с процессом перебора всех возможных бинарных масок (и, следовательно, всех экспоненциально большого количества подсетей) и вычисления их совокупного прогноза.  </p>
<p>Нежелательным свойством представленной выше схемы является то, что мы должны масштабировать активации по <strong>p</strong> во время тестирования. Поскольку производительность во время тестирования очень важна, всегда предпочтительнее использовать <strong>инвертированное отбрасывание</strong>, при котором масштабирование выполняется во время обучения, а прямой проход во время тестирования остаётся нетронутым. Кроме того, это удобно тем, что код прогнозирования может оставаться нетронутым, если вы решите изменить место применения отбрасывания или отказаться от него. Инвертированное отбрасывание выглядит следующим образом:  </p>
<p>```
 """ 
Inverted Dropout: Recommended implementation example.
We drop and scale at train time and don't do anything at test time.
"""</p>
<p>p = 0.5 # probability of keeping a unit active. higher = less dropout</p>
<p>def train_step(X):
  # forward pass for example 3-layer neural network
  H1 = np.maximum(0, np.dot(W1, X) + b1)
  U1 = (np.random.rand(<em>H1.shape) &lt; p) / p # first dropout mask. Notice /p!
  H1 </em>= U1 # drop!
  H2 = np.maximum(0, np.dot(W2, H1) + b2)
  U2 = (np.random.rand(<em>H2.shape) &lt; p) / p # second dropout mask. Notice /p!
  H2 </em>= U2 # drop!
  out = np.dot(W3, H2) + b3</p>
<p># backward pass: compute gradients... (not shown)
  # perform parameter update... (not shown)</p>
<p>def predict(X):
  # ensembled forward pass
  H1 = np.maximum(0, np.dot(W1, X) + b1) # no scaling necessary
  H2 = np.maximum(0, np.dot(W2, H1) + b2)
  out = np.dot(W3, H2) + b3
  ``` </p>
<p>После первого появления метода отсева было проведено множество исследований, направленных на то, чтобы понять, в чём заключается его эффективность на практике и как он соотносится с другими методами регуляризации. Рекомендуем ознакомиться с дополнительной литературой для заинтересованных читателей:<br>
- <a href="http://www.cs.toronto.edu/~rsalakhu/papers/srivastava14a.pdf">Статья о выпадении из курса</a> Шриваставы и др., 2014.
- <a href="http://papers.nips.cc/paper/4882-dropout-training-as-adaptive-regularization.pdf">Выборочное обучение как адаптивная регуляризация</a>: «мы показываем, что регуляризация с помощью вычеркивания эквивалентна регуляризации <strong>\(L_2\)</strong> первого порядка, применяемой после масштабирования признаков с помощью оценки обратной диагональной информационной матрицы Фишера».  </p>
<p><strong>Тема шума при прямом проходе</strong>. Выпадение относится к более общей категории методов, которые вводят стохастическое поведение при прямом проходе сети. Во время тестирования шум усредняется <em>аналитически</em> (как в случае с выпадением при умножении на <strong>p</strong>) или <em>численно</em> (например, с помощью выборки, выполняя несколько прямых проходов с разными случайными решениями, а затем усредняя их). Примером других исследований в этом направлении является <a href="http://cs.nyu.edu/~wanli/dropc/">DropConnect</a>, где во время прямого прохода случайный набор весовых коэффициентов устанавливается в ноль. В качестве предвосхищения отметим, что свёрточные нейронные сети также используют эту тему с помощью таких методов, как стохастическое объединение, дробное объединение и увеличение данных. Мы подробно рассмотрим эти методы позже.  </p>
<p><strong>Регуляризация смещения</strong>. Как мы уже упоминали в разделе о линейной классификации, обычно не рекомендуется регуляризировать параметры смещения, поскольку они не взаимодействуют с данными посредством мультипликативных взаимодействий и, следовательно, не влияют на конечную цель. Однако в практических приложениях (при надлежащей предварительной обработке данных) регуляризация смещения редко приводит к значительному ухудшению производительности. Вероятно, это связано с тем, что по сравнению со всеми весовыми параметрами коэффициентов смещения очень мало, поэтому классификатор может «позволить себе» использовать коэффициенты смещения, если они нужны ему для уменьшения потерь данных.  </p>
<p><strong>Послойная регуляризация</strong>. Не очень распространена регуляризация разных слоёв с разной степенью (за исключением, возможно, выходного слоя). В литературе опубликовано относительно мало результатов, связанных с этой идеей.  </p>
<p><strong>На практике</strong>: чаще всего используется единая глобальная сила регуляризации <strong>\(L_2\)</strong>, которая проходит перекрестную проверку. Также часто применяется комбинация с отбрасыванием данных после всех слоев. Значение <strong>p=0.5</strong> это разумное значение по умолчанию, но его можно настроить на основе данных проверки.  </p>
<h2>Функции потерь</h2>
<p>Мы обсудили часть целевой функции, отвечающую за регуляризацию, которую можно рассматривать как штраф за определённую меру сложности модели. Вторая часть целевой функции — это <em>потеря данных</em>, которая в задаче обучения с учителем измеряет соответствие между прогнозом (например, оценками классов при классификации) и истинным значением. Потеря данных представляет собой среднее значение потерь данных для каждого отдельного примера. То есть, <strong>\(L = \frac{1}{N} \sum_i L_i\) where \(N\)</strong>, где <strong>N</strong> - количество обучающих данных. Давайте сократим <strong>\(f = f(x_i; W)\)</strong> активация выходного слоя в нейронной сети. Существует несколько типов задач, которые вы можете решить на практике:
- <strong>Классификация</strong> — это случай, который мы подробно обсуждали. Здесь мы предполагаем наличие набора примеров и одной правильной метки (из фиксированного набора) для каждого примера. Одной из двух наиболее часто встречающихся функций стоимости в этой задаче является SVM (<em>например, формулировка Уэстона Уоткинса</em>):<br>
$$<br>
L_i = \sum_{j\neq y_i} \max(0, f_j - f_{y_i} + 1)
$$<br>
Как мы вкратце упомянули, некоторые люди сообщают о более высокой производительности при использовании квадратичной функции потерь (т. е. вместо <strong>\(\max(0, f_j - f_{y_i} + 1)^2\)</strong>). Вторым распространенным выбором является <strong>классификатор Softmax</strong>, который использует кросс-энтропийные потери:<br>
$$<br>
L_i = -\log\left(\frac{e^{f_{y_i}}}{ \sum_j e^{f_j} }\right)
$$   </p>
<p><strong>Проблема: большое количество классов</strong>. Когда набор меток очень велик (например, слова в английском словаре или <strong>ImageNet</strong>, содержащий 22 000 категорий), вычисление полной вероятности по <strong>методу Softmax</strong> становится дорогостоящим. Для некоторых приложений популярны приближённые версии. Например, в задачах обработки естественного языка может быть полезно использовать <em>иерархический Softmax</em> (см. одно из объяснений <a href="http://arxiv.org/pdf/1310.4546.pdf">здесь</a> (pdf)).</p>
<p><em>Иерархический Softmax</em> раскладывает слова на метки в виде дерева. Затем каждая метка представляется в виде пути по дереву, и в каждом узле дерева обучается <strong>классификатор Softmax</strong>, чтобы различать левую и правую ветви. Структура дерева сильно влияет на производительность и, как правило, зависит от задачи.  </p>
<ul>
<li>
<strong>Классификация атрибутов</strong>. Оба приведённых выше примера предполагают, что существует единственный правильный ответ <strong>\(y_i\)</strong>. Но что , если <strong>\(y_i\)</strong>- это бинарный вектор, в котором каждый пример может иметь или не иметь определённый атрибут, и где атрибуты не исключают друг друга? Например, изображения <strong>Вконтакте</strong> можно рассматривать как помеченные определённым подмножеством хэштегов из большого набора всех хэштегов, и изображение может содержать несколько хэштегов. Разумным подходом в этом случае будет создание бинарного классификатора для каждого отдельного атрибута. Например, бинарный классификатор для каждой категории отдельно будет иметь вид:<br>
$$
L_i = \sum_j \max(0, 1 - y_{ij} f_j)
$$<br>
где сумма по всем категориям <strong>\(j\)</strong> и <strong>\(y_{ij}\)</strong> равно <strong>+1</strong> или <strong>-1</strong> в зависимости от того, помечен ли i-й пример j-м атрибутом, а вектор оценки <strong>\(f_j\)</strong> будет положительным, если класс прогнозируется как присутствующий, и отрицательным в противном случае. Обратите внимание, что потери накапливаются, если положительный пример имеет оценку меньше <strong>+1</strong> или если отрицательный пример имеет оценку больше <strong>-1</strong>.<br>
Альтернативой этому подходу было бы обучение классификатора логистической регрессии для каждого атрибута по отдельности. Бинарный классификатор логистической регрессии имеет только два класса <em>(0, 1)</em> и вычисляет вероятность класса <strong>1</strong> следующим образом:<br>
$$
P(y = 1 \mid x; w, b) = \frac{1}{1 + e^{-(w^Tx +b)}} = \sigma (w^Tx + b)
$$<br>
Поскольку сумма вероятностей классов <em>1 и 0</em> равна единице, вероятность класса <strong>0</strong> равна <strong>\(P(y = 0 \mid x; w, b) = 1 - P(y = 1 \mid x; w,b)\)</strong>. Таким образом, пример классифицируется как положительный <strong>(y = 1)</strong>, если <strong>\(\sigma (w^Tx + b) &gt; 0.5\)</strong>, или что эквивалентно , если оценка <strong>\(w^Tx +b &gt; 0\)</strong>. Затем функция потерь максимизирует эту вероятность. Вы можете убедиться, что это сводится к минимизации отрицательного логарифма правдоподобия:<br>
$$
L_i = -\sum_j y_{ij} \log(\sigma(f_j)) + (1 - y_{ij}) \log(1 - \sigma(f_j))
$$<br>
где этикетки <strong>\(y_{ij}\)</strong> считаются равными либо <em>1 (положительному), либо 0 (отрицательному)</em>, и  <strong>\(\sigma(\cdot)\)</strong>. Это сигмоидальная функция. Приведённое выше выражение может показаться пугающим, но градиент на <strong>f</strong> на самом деле он чрезвычайно прост и интуитивно понятен: <strong>\(\partial{L_i} / \partial{f_j} = \sigma(f_j) - y_{ij}\)</strong> (поскольку вы можете перепроверить себя, взяв производные).  </li>
<li>
<strong>Регрессия</strong> — это задача прогнозирования величин с действительными значениями, таких как цена дома или длина чего-либо на изображении. Для решения этой задачи обычно вычисляют потери между прогнозируемой величиной и истинным ответом, а затем измеряют норму <strong>\(L_2\)</strong> в квадрате или норму <strong>\(L_1\)</strong> разности. Норма <strong>\(L_2\)</strong> в квадрате вычисляет потери для одного примера в виде:<br>
$$
L_i = \Vert f - y_i \Vert_2^2
$$<br>
Причина, по которой норма <strong>\(L_2\)</strong> возводится в квадрат в целевой функции, заключается в том, что градиент становится намного проще, не меняя оптимальные параметры, поскольку возведение в квадрат — это монотонная операция. Норма <strong>\(L_1\)</strong> вычисляется путём суммирования абсолютных значений по каждому измерению:<br>
$$
L_i = \Vert f - y_i \Vert_1 = \sum_j \mid f_j - (y_i)<em>j \mid
$$<br>
_где сумма__ <strong>\(\sum_j\)</strong> это сумма по всем параметрам желаемого прогноза, если прогнозируется более одной величины. Рассмотрим только j-й параметр i-го примера и обозначим разницу между истинным и прогнозируемым значением как <strong>\(\delta_{ij}\)</strong>, градиент для этого измерения (т.е. <strong>\(\partial{L_i} / \partial{f_j}\))</strong>) легко выводится как либо <strong>\(\delta_{ij}\)</strong> с нормой <strong>\(L_2\)</strong>, или <strong>\(sign(\delta_{ij})\)</strong>.То есть градиент оценки будет либо прямо пропорционален разнице в ошибках, либо будет фиксированным и унаследует только знак разницы.<br>
_Предупреждение</em>: важно отметить, что функцию потерь <strong>\(L_2\)</strong> гораздо сложнее оптимизировать, чем более стабильную функцию потерь, такую как <strong>Softmax</strong>.  </li>
</ul>
<p>Интуитивно понятно, что для этого требуется очень хрупкое и специфическое свойство сети, чтобы она выдавала ровно одно правильное значение для каждого входного сигнала (и его расширений). Обратите внимание, что это не относится к <strong>Softmax</strong>, где точное значение каждого балла менее важно: важно только, чтобы их величины были соответствующими. Кроме того, функция потерь <strong>\(L_2\)</strong> менее устойчива, поскольку выбросы могут приводить к огромным градиентам. Столкнувшись с проблемой регрессии, сначала подумайте, абсолютно ли недостаточно квантовать выходные данные по ячейкам. Например, если вы прогнозируете звездный рейтинг продукта, возможно, гораздо лучше использовать <em>5 независимых классификаторов</em> для оценок в 1-5 звезд вместо потери регрессии. Классификация имеет дополнительное преимущество в том, что она может дать вам распределение по результатам регрессии, а не только по одному результату без указания его достоверности. Если вы уверены, что классификация не подходит, используйте <strong>\(L_2\)</strong>, но будьте осторожны: например, <strong>\(L_2\)</strong> более нестабилен, и применять отсев в сети (особенно на слое непосредственно перед потерей <strong>\(L_2\)</strong>) — не лучшая идея.  </p>
<blockquote>
<p>Сталкиваясь с задачей регрессии, в первую очередь подумайте, действительно ли она необходима. Вместо этого по возможности дискретизируйте выходные данные и выполняйте классификацию по ним.</p>
</blockquote>
<ul>
<li>
<strong>Структурированное прогнозирование</strong>. Структурированные потери относятся к случаю, когда метками могут быть произвольные структуры, такие как графы, деревья или другие сложные объекты. Обычно также предполагается, что пространство структур очень велико и его нелегко перебрать. Основная идея структурированных потерь SVM заключается в том, чтобы требовать запас между правильной структурой и <strong>\(y_i\)</strong> и набравшая наибольшее количество баллов неправильная структура. Эту проблему не принято решать как простую задачу неограниченной оптимизации с градиентным спуском. Вместо этого обычно разрабатываются специальные решатели, позволяющие воспользоваться конкретными упрощающими допущениями структурного пространства. Мы кратко упоминаем проблему, но считаем, что специфика выходит за рамки данного класса.  </li>
</ul>
<h2>Краткая сводка</h2>
<p>Подводя итог:
- Рекомендуется предварительно обработать данные, чтобы их среднее значение было равно нулю, и нормализовать их масштаб до <strong>[-1, 1]</strong> по каждому признаку
- Инициализируйте веса, извлекая их из гауссова распределения со стандартным отклонением <strong>\(\sqrt{2/n}\), where \(n\)</strong>, где <strong>n</strong> - это количество входов в нейрон. Например, в NumPy: <code>w = np.random.randn(n) * sqrt(2.0/n)</code>.
- Используйте регуляризацию <strong>\(L_2\)</strong> и отсев (перевернутая версия)
- Используйте пакетную нормализацию
- Мы обсудили различные задачи, которые вы можете выполнять на практике, и наиболее распространённые функции потерь для каждой задачи  </p>
<p>Теперь мы предварительно обработали данные, настроили и инициализировали модель. В следующем разделе мы рассмотрим процесс обучения и его динамику.</p>
    </div>
    <aside class="postpromonav"><nav><ul class="pager hidden-print">
<li class="previous">
                <a href="../convnets-1/" rel="prev" title="Сверточные сети. Введение">Предыдущая запись</a>
            </li>
            <li class="next">
                <a href="../convnets-3/" rel="next" title="Обучение нейронных сетей">Следующая запись</a>
            </li>
        </ul></nav></aside><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script></article><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="../../assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
