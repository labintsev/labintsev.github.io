<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="Заметки по machine learning, deep learning.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Заметки по ML, DL (1 страница со старыми записями) | Заметки по ML, DL</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="rss.xml">
<link rel="canonical" href="https://mldl.ru/index-1.html">
<link rel="prev" href="." type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/linear-classifier/" class="u-url">Линейный классификатор </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/linear-classifier/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-05T19:42:16+03:00" itemprop="datePublished" title="2025-03-05 19:42">2025-03-05 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Линейный классификатор</h2>
<p>Содержание: 
- <a href="posts/linear-classifier/#%D0%BB%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%B0%D1%8F-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F">Линейная классификация</a>
- <a href="posts/linear-classifier/#%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5-%D1%81%D0%BE%D0%BF%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9-%D1%81-%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B0%D0%BC%D0%B8-%D0%BC%D0%B5%D1%82%D0%BE%D0%BA">Параметризованное сопоставление изображений с оценками меток</a>
- <a href="posts/linear-classifier/#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%86%D0%B8%D1%8F-%D0%BB%D0%B8%D0%BD%D0%B5%D0%B9%D0%BD%D0%BE%D0%B3%D0%BE-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%B0">Интерпретация линейного классификатора</a>
- <a href="posts/linear-classifier/#%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F-%D0%BF%D0%BE%D1%82%D0%B5%D1%80%D1%8C">Функция потерь</a>
- <a href="posts/linear-classifier/#%D0%BF%D0%BE%D1%82%D0%B5%D1%80%D1%8F-%D0%BC%D0%B0%D1%88%D0%B8%D0%BD%D1%8B-%D0%BC%D1%83%D0%BB%D1%8C%D1%82%D0%B8%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2%D0%BE%D0%B3%D0%BE-%D0%BE%D0%BF%D0%BE%D1%80%D0%BD%D0%BE%D0%B3%D0%BE-%D0%B2%D0%B5%D0%BA%D1%82%D0%BE%D1%80%D0%B0">Потеря машины мультиклассового опорного вектора</a>
- <a href="posts/linear-classifier/#%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D1%81%D0%BE%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F">Практические соображения</a>
- <a href="posts/linear-classifier/#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-softmax">Классификатор Softmax</a>
- <a href="posts/linear-classifier/#svm-%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2-softmax">SVM против Softmax</a>
- <a href="posts/linear-classifier/#%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F-%D0%B2%D0%B5%D0%B1-%D0%B4%D0%B5%D0%BC%D0%BE%D0%BD%D1%81%D1%82%D1%80%D0%B0%D1%86%D0%B8%D1%8F">Интерактивная веб-демонстрация</a>
- <a href="posts/linear-classifier/#%D0%BA%D1%80%D0%B0%D1%82%D0%BA%D0%B0%D1%8F-%D1%81%D0%B2%D0%BE%D0%B4%D0%BA%D0%B0">Краткая сводка</a>
- <a href="posts/linear-classifier/#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B">Дополнительные материалы</a></p>
<h3>Линейная классификация</h3>
<p>В предыдущем разделе мы рассмотрели задачу классификации изображений, которая заключается в присвоении изображению одного из фиксированного набора категорий. Кроме того, мы описали классификатор k-ближайших соседей (kNN), который присваивает изображениям метки, сравнивая их с (помеченными) изображениями из обучающей выборки. Как мы увидели, у kNN есть ряд недостатков:
- Классификатор должен запоминать все обучающие данные и сохранять их для последующего сравнения с тестовыми данными. Это неэффективно с точки зрения использования памяти, поскольку размер наборов данных может легко достигать гигабайтов.
- Классификация тестового изображения обходится дорого, поскольку требует сравнения со всеми обучающими изображениями.  </p>
<p><strong>Обзор</strong>. Теперь мы собираемся разработать более эффективный подход к классификации изображений, который в конечном итоге естественным образом распространится на нейронные сети и свёрточные нейронные сети. Этот подход будет состоять из двух основных компонентов: <strong>функции оценки</strong>, которая преобразует исходные данные в оценки классов, и <strong>функции потерь</strong>, которая количественно оценивает соответствие между прогнозируемыми оценками и истинными метками. Затем мы сформулируем это, как задачу оптимизации, в которой мы минимизируем функцию потерь по отношению к параметрам функции оценки.   </p>
<h3>Параметризованное сопоставление изображений с оценками меток</h3>
<p>Первым компонентом этого подхода является определение функции оценки, которая сопоставляет значения пикселей изображения со значениями уверенности для каждого класса. Мы рассмотрим этот подход на конкретном примере. Как и прежде, предположим, что у нас есть набор обучающих изображений $x_i \ in R^D $ каждый из которых связан с меткой  $ y_i $. Здесь $i=1 ... N $ и $y_i \in { 1 ... K } $. </p>
<p>То есть у нас есть <strong>N</strong> примеров (каждый из которых имеет размерность <strong>D</strong>) и <strong>K</strong> различных категорий. Например, в CIFAR-10 у нас есть обучающий набор из <strong>N</strong> = 50 000 изображений, каждое из которых имеет <strong>D</strong> = 32 x 32 x 3 = 3072 пикселя, и <strong>K</strong> = 10, так как существует 10 различных классов (собака, кошка, автомобиль и т. д.). Теперь мы определим функцию оценки $f: R^D \mapsto R^K$, которое сопоставляет пиксели необработанного изображения с оценками класса.   </p>
<p><strong>Линейный классификатор</strong>. В этом модуле мы начнём с, пожалуй, самой простой из возможных функций — линейного отображения:  </p>
<p>$$
f(x_i, W, b) = W x_i + b
$$   </p>
<p>В приведенном выше уравнении мы предполагаем, что изображение $x_i$ все его пиксели сглаживаются до одного вектора-столбца размером [D x 1] . Матрица <strong>W</strong> (размером [K x D]) и вектор <strong>b</strong> (размером [K x 1]) являются <strong>параметрами</strong> функции. В CIFAR-10 $x_i$ содержит все пиксели в i-м изображении, объединённые в один столбец [3072 x 1], <strong>W</strong> имеет размер [10 x 3072], а <strong>b</strong> имеет размер [10 x 1], то есть в функцию поступает 3072 числа (исходные значения пикселей), а выходит 10 чисел (оценки классов). Параметры в <strong>W</strong> часто называют весами, а <strong>b</strong> называют <strong>вектором смещения</strong>, потому что он влияет на выходные оценки, но не взаимодействует с фактическими данными $x_i$. Однако вы часто будете слышать, как люди используют термины веса и параметры как взаимозаменяемые. 
Есть несколько вещей, на которые следует обратить внимание:
- Во-первых, обратите внимание, что умножение одной матрицы $W x_1$. Фактически выполняется параллельная оценка 10 отдельных классификаторов (по одному для каждого класса), где каждый классификатор представляет собой строку <strong>W</strong>.
- Обратите также внимание, что мы думаем о входных данных $ (x_i, y_i) $
Мы считаем, что они заданы и неизменны, но мы можем управлять параметрами <strong>W</strong>, <strong>b</strong>. Наша цель — настроить их таким образом, чтобы вычисленные оценки соответствовали истинным меткам во всём обучающем наборе данных. Мы подробно рассмотрим, как это сделать, но интуитивно понятно, что мы хотим, чтобы оценка правильного класса была выше, чем оценка неправильных классов.
- Преимущество этого подхода заключается в том, что обучающие данные используются для определения параметров <strong>W</strong>, <strong>b</strong>, но после завершения обучения мы можем отбросить весь обучающий набор данных и оставить только полученные параметры. Это связано с тем, что новое тестовое изображение можно просто передать в функцию и классифицировать на основе вычисленных показателей.
- Наконец, обратите внимание, что классификация тестового изображения включает в себя одно матричное умножение и сложение, что значительно быстрее, чем сравнение тестового изображения со всеми обучающими изображениями. </p>
<blockquote>
<p>Предвосхищая вопрос: свёрточные нейронные сети будут сопоставлять пиксели изображения со значениями точно так же, как показано выше, но сопоставление ( f ) будет более сложным и будет содержать больше параметров.</p>
</blockquote>
<h3>Интерпретация линейного классификатора</h3>
<p>Обратите внимание, что линейный классификатор вычисляет оценку класса как взвешенную сумму всех значений пикселей по всем трём цветовым каналам. В зависимости от того, какие именно значения мы задаём для этих весов, функция может любить или не любить (в зависимости от знака каждого веса) определённые цвета в определённых местах изображения. Например, можно представить, что класс «корабль» может быть более вероятным, если по краям изображения много синего (что, скорее всего, соответствует воде). Можно было бы ожидать, что классификатор «корабль» будет иметь множество положительных весовых коэффициентов для синего канала (присутствие синего повышает оценку корабля) и отрицательные весовые коэффициенты для красного/зелёного каналов (присутствие красного/зелёного понижает оценку корабля). </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/imagemap.jpg"><br>
Пример сопоставления изображения с баллами по классам. Для наглядности предположим, что изображение состоит всего из 4 пикселей (4 монохромных пикселя, в этом примере мы не рассматриваем цветовые каналы для краткости) и что у нас есть 3 класса (красный (кошка), зелёный (собака), синий (корабль)). (Уточнение: в частности, цвета здесь просто обозначают 3 класса и не связаны с каналами RGB.) Мы растягиваем пиксели изображения в столбец и выполняем умножение матриц, чтобы получить баллы по каждому классу. Обратите внимание, что этот конкретный набор весовых коэффициентов W совсем не хорош: весовые коэффициенты присваивают нашему изображению кошки очень низкий балл. В частности, этот набор весовых коэффициентов, похоже, убеждён, что видит собаку. </p>
<hr>
<p><strong>Аналогия изображений с многомерными точками</strong>. Поскольку изображения растягиваются в многомерные векторы-столбцы, мы можем интерпретировать каждое изображение как отдельную точку в этом пространстве (например, каждое изображение в CIFAR-10 — это точка в 3072-мерном пространстве размером 32x32x3 пикселя). Аналогично, весь набор данных — это (помеченный) набор точек.   </p>
<p>Поскольку мы определили оценку каждого класса как взвешенную сумму всех пикселей изображения, оценка каждого класса является линейной функцией в этом пространстве. Мы не можем визуализировать 3072-мерное пространство, но если мы представим, что все эти измерения сведены к двум, то сможем попытаться визуализировать, что может делать классификатор: </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/pixelspace.jpeg"><br>
Мультяшное представление пространства изображений, где каждое изображение представляет собой одну точку, а три классификатора визуализированы. На примере классификатора автомобилей (красным цветом) красная линия показывает все точки в пространстве, которые получают нулевой балл за класс автомобилей. Красная стрелка показывает направление увеличения, поэтому все точки справа от красной линии имеют положительные (и линейно возрастающие) баллы, а все точки слева — отрицательные (и линейно убывающие) баллы. </p>
<hr>
<p>Как мы видели выше, каждый ряд <strong>W</strong> является классификатором для одного из классов. Геометрическая интерпретация этих чисел заключается в том, что при изменении одного из столбцов <strong>W</strong> соответствующая линия в пиксельном пространстве будет поворачиваться в разных направлениях. Смещение <strong>b</strong>. С другой стороны, наши классификаторы позволяют переводить строки. В частности, обратите внимание, что без коэффициентов смещения подстановка <strong>$ x_i = 0 $</strong> всегда будет давать нулевой результат независимо от весов, поэтому все линии будут вынуждены пересекать начало координат.   </p>
<p><strong>Интерпретация линейных классификаторов как сопоставление шаблонов</strong>. Другая интерпретация весовых коэффициентов <strong>W</strong> заключается в том, что каждая строка <strong>W</strong> соответствует <em>шаблону</em> (или, как его иногда называют, <em>прототипу</em>) для одного из классов. Оценка каждого класса для изображения затем получается путём сравнения каждого шаблона с изображением с помощью <em>скалярного произведения</em> (или <em>точечного произведения</em>) по очереди, чтобы найти наиболее подходящий. В этой терминологии линейный классификатор выполняет сопоставление шаблонов, которые он изучает. Другой способ взглянуть на это — представить, что мы по-прежнему используем метод ближайшего соседа, но вместо тысяч обучающих изображений мы используем только одно изображение для каждого класса (хотя мы его изучим, и оно не обязательно должно быть одним из изображений в обучающем наборе), и в качестве расстояния мы используем (отрицательное) скалярное произведение вместо расстояния L1 или L2. </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/templates.jpg"><br>
Немного забегая вперёд: пример изученных весовых коэффициентов в конце обучения для CIFAR-10. Обратите внимание, что, например, шаблон корабля содержит много синих пикселей, как и ожидалось. Таким образом, этот шаблон будет давать высокий балл при сопоставлении с изображениями кораблей в океане с помощью скалярного произведения. </p>
<hr>
<p>Кроме того, обратите внимание, что шаблон лошади, по-видимому, содержит двухголовую лошадь, что связано с тем, что в наборе данных есть лошади, смотрящие как влево, так и вправо. Линейный классификатор <em>объединяет</em> эти два вида лошадей в данных в один шаблон. Аналогичным образом, классификатор автомобилей, по-видимому, объединил несколько видов в один шаблон, который должен распознавать автомобили со всех сторон и всех цветов. В частности, этот шаблон оказался красным, что указывает на то, что в наборе данных CIFAR-10 больше красных автомобилей, чем автомобилей любого другого цвета. Линейный классификатор слишком слаб, чтобы правильно распознавать автомобили разных цветов, но, как мы увидим позже, нейронные сети позволят нам выполнить эту задачу. Забегая немного вперёд, скажу, что нейронная сеть сможет создавать промежуточные нейроны в своих скрытых слоях, которые смогут распознавать определённые типы автомобилей (например, зелёный автомобиль, поворачивающий налево, синий автомобиль, поворачивающий вперёд, и т. д.), а нейроны на следующем слое смогут объединять их в более точную оценку автомобиля с помощью взвешенной суммы отдельных детекторов автомобилей.   </p>
<p><strong>Уловка с предвзятостью</strong>. Прежде чем двигаться дальше, мы хотим упомянуть распространённую упрощающую уловку для представления двух параметров <strong>W</strong>,<strong>b</strong> как один. Напомним, что мы определили функцию оценки как:   </p>
<p>$$
f(x_i, W, b) = W x_i + b
$$</p>
<p>По мере изучения материала становится немного сложнее отслеживать два набора параметров (смещения <strong>b</strong> и веса <strong>W</strong>) по отдельности. Часто используемый приём заключается в объединении двух наборов параметров в одну матрицу, которая содержит их оба, путём расширения вектора $ x_i $ с одним дополнительным измерением, которое всегда сохраняет константу 1 - <em>измерение смещения</em> по умолчанию. С дополнительным измерением новая функция оценки упростится до простого умножения матриц: 
$$
f(x_i, W) = W x_i
$$
С нашим примером CIFAR-10, $ x_i $ теперь [3073 x 1] вместо [3072 x 1] — (с дополнительным измерением, содержащим константу 1), и <strong>W</strong> теперь имеет значение [10 x 3073] вместо [10 x 3072]. Дополнительный столбец, который <strong>W</strong> теперь соответствует смещению <strong>b</strong>. Иллюстрация могла бы помочь прояснить ситуацию: </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/wb.jpeg"><br>
Иллюстрация трюка с предвзятостью. Выполнение матричного умножения с последующим добавлением вектора смещения (слева) эквивалентно добавлению размера смещения с константой 1 ко всем входным векторам и расширению весовой матрицы на 1 столбец - столбец смещения (справа). Таким образом, если мы предварительно обработаем наши данные, добавив единицы ко всем векторам, нам нужно будет выучить только одну матрицу весов вместо двух матриц, которые содержат веса и отклонения. </p>
<hr>
<p><strong>Предварительная обработка данных изображения</strong>. В качестве примечания: в приведённых выше примерах мы использовали необработанные значения пикселей (которые находятся в диапазоне [0…255]). В машинном обучении очень распространена практика нормализации входных признаков (в случае изображений каждый пиксель считается признаком). В частности, важно <strong>центрировать данные</strong>, вычитая среднее значение из каждого признака. В случае с изображениями это соответствует вычислению <em>среднего значения изображения</em> по обучающим изображениям и вычитанию его из каждого изображения, чтобы получить изображения, в которых пиксели находятся в диапазоне примерно от [-127 до 127]. Далее обычно выполняется предварительная обработка, при которой каждый входной признак масштабируется так, чтобы его значения находились в диапазоне от [-1 до 1]. Из них, пожалуй, более важным является центрирование относительно нуля, но нам придётся подождать с его обоснованием, пока мы не поймём динамику градиентного спуска.   </p>
<h3>Функция потерь</h3>
<p>В предыдущем разделе мы определили функцию преобразования значений пикселей в оценки классов, которая параметризуется набором весовых коэффициентов <strong>W</strong>. Более того, мы увидели, что у нас нет контроля над данными $(x_i, y_i)$ (это фиксировано и задано), но мы можем управлять этими весами и хотим установить их так, чтобы прогнозируемые оценки классов соответствовали исходным меткам в обучающих данных. 
Например, если вернуться к примеру с изображением кошки и её оценками для классов «кошка», «собака» и «корабль», то мы увидим, что конкретный набор весов в этом примере был не очень хорошим: мы ввели пиксели, изображающие кошку, но оценка кошки получилась очень низкой (-96,8) по сравнению с другими классами (оценка собаки 437,9, а оценка корабля 61,95). Мы будем измерять степень нашего недовольства такими результатами, как этот, с помощью <strong>функции потерь</strong> (иногда также называемой <strong>функцией затрат</strong> или <strong>целевой функцией</strong>). Интуитивно понятно, что потери будут высокими, если мы плохо справляемся с классификацией обучающих данных, и низкими, если мы хорошо справляемся.  </p>
<h4>Потеря машины мультиклассового опорного вектора</h4>
<p>Существует несколько способов определения параметров функции потерь. В качестве первого примера мы рассмотрим часто используемую функцию потерь, называемую <strong>многоклассовой функцией потерь машины опорных векторов</strong> (SVM). Функция потерь SVM настроена таким образом, что SVM «хочет», чтобы правильный класс для каждого изображения имел оценку выше, чем у неправильных классов, на некоторую фиксированную величину <strong>Δ</strong>. Обратите внимание, что иногда полезно очеловечить функции потерь, как мы сделали выше: SVM «хочет» определённого результата в том смысле, что этот результат приведёт к меньшим потерям (что хорошо).   </p>
<p>Теперь давайте уточним. Напомним, что для i-го примера нам даны пиксели изображения $ x_i $ и этикетка $ y_i $ которая определяет индекс правильного класса. Функция оценки принимает пиксели и вычисляет вектор $ f(x_i, W) $ оценок за класс, которые мы будем сокращать до <strong>s</strong> (сокращение от «баллы»). Например, балл за j-й класс — это j-й элемент: $ s_j = f(x_i, W)_j $. Потери многоклассового SVM для i-го примера формализуются следующим образом:   </p>
<p>$$
L_i = Σ_{j\neq y_i} max(0, s_j - s_{y_i} + \Delta)
$$ </p>
<p><strong>Пример</strong>. Давайте разберём это на примере, чтобы понять, как это работает. Предположим, что у нас есть три класса, которые получают оценки <strong>s=[13,−7,11]</strong>, и что первый класс является истинным классом (т.е. $ y_i = 0 $ ). Также предположим, что <strong>Δ</strong> (гиперпараметр, о котором мы вскоре поговорим подробнее) равен 10. Приведенное выше выражение суммирует все неправильные классы ($ j \neq y_i $), таким образом, мы получаем два термина:   </p>
<p>$$
L_i = max(0, -7 - 13 + 10) + \max(0, 11 - 13 + 10)
$$ </p>
<p>Вы видите, что первый член даёт ноль, так как [-7 - 13 + 10] даёт отрицательное число, которое затем округляется до ннля с помощью <strong>max(0,−)</strong>
функция. Мы получаем нулевые потери для этой пары, потому что оценка правильного класса (13) была больше, чем оценка неправильного класса (-7), как минимум на 10. На самом деле разница составляла 20, что намного больше 10, но SVM интересует только то, что разница составляет не менее 10; любая дополнительная разница, превышающая 10, ограничивается нулём с помощью операции <em>max</em>. Второй член вычисляет [11 - 13 + 10], что даёт 8. То есть, даже если правильный класс имел более высокий балл, чем неправильный (13 &gt; 11), он не был выше желаемого значения в 10 баллов. Разница составила всего 2, поэтому проигрыш равен 8 (т. Е. Насколько выше должна быть разница, чтобы соответствовать марже). Таким образом, функция SVM loss запрашивает оценку правильного класса $ y_i = 0 $ быть больше, чем неправильные оценки класса, по крайней мере, на <strong>Δ</strong> (дельта). Если это не так, мы понесём убытки.   </p>
<p>Обратите внимание, что в этом конкретном модуле мы работаем с линейными функциями оценки ( $ f(x_i; W) = W x_i $ ), поэтому мы также можем переписать функцию потерь в этой эквивалентной форме:   </p>
<p>$$
L_i = Σ_{j\neq y_i} max(0, w_j^T x_i - w_{y_i}^T x_i + \Delta)
$$  </p>
<p>где $ w_j$ является j-й строкой <strong>W</strong> преобразован в столбец. Однако это не обязательно будет так, если мы начнём рассматривать более сложные формы функции оценки <strong>f</strong>.   </p>
<p>Последний термин, который мы упомянем, прежде чем закончить этот раздел, — это нулевой порог <strong>max(0,−)</strong>. Эта функция часто называется <strong>потерей от перегиба</strong>. Иногда можно услышать, что вместо этого люди используют SVM с квадратичной потерей от перегиба (или L2-SVM), которая имеет вид <strong>$max(0,−) ^ 2$</strong>
это сильнее6 сказывается на нарушении границ (квадратично, а не линейно). Неквадратичная версия является более стандартной, но в некоторых наборах данных квадратичная функция потерь может работать лучше. Это можно определить во время перекрестной проверки.   </p>
<blockquote>
<p>Функция потерь количественно определяет наше недовольство прогнозами на обучающем наборе</p>
</blockquote>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/margin.jpg"></p>
<p>Многоклассовая машина опорных векторов «хочет», чтобы оценка правильного класса была выше, чем у всех остальных классов, как минимум на величину дельты. Если оценка какого-либо класса находится в красной области (или выше), то будет накоплен убыток. В противном случае убыток будет равен нулю. Наша цель — найти веса, которые одновременно удовлетворят этому ограничению для всех примеров в обучающих данных и обеспечат минимально возможный общий убыток.  </p>
<hr>
<p><strong>Регуляризация</strong>. Есть одна ошибка с функцией потерь, которую мы представили выше. Предположим, что у нас есть набор данных и набор параметров <strong>W</strong>, которые правильно классифицируют каждый пример (т.е. все оценки таковы, что все поля соблюдены, и <strong>$L_i = 0)\</strong> для всех i). Проблема в том, что этот набор <strong>W</strong> не обязательно уникален: может быть много похожих <strong>W</strong>, которые правильно классифицируют примеры. Один из простых способов увидеть это заключается в том, что если некоторые параметры <strong>W</strong> правильно классифицируют все примеры (так что потери равны нулю для каждого примера), то любое кратное этим параметрам <strong>λW</strong>, где <strong>λ&gt;1</strong> также даст нулевой убыток, потому что это преобразование равномерно растягивает все величины счета и, следовательно, их абсолютные разности. Например, если разница в оценках между правильным классом и ближайшим неправильным классом равна 15, то умножение всех элементов <strong>W</strong> на 2 даст новую разницу 30.  </p>
<p>Другими словами, мы хотим закодировать некоторое предпочтение для определенного набора весов <strong>W</strong> по сравнению с другими, чтобы устранить эту двусмысленность. Мы можем сделать это, расширив функцию потерь штрафом за регуляризацию <strong>R(W)</strong>. Наиболее распространенным штрафом за регуляризацию является квадрат нормы <strong>L2</strong>, который препятствует использованию больших весов с помощью квадратичного штрафа по всем параметрам:  </p>
<p>$$
R(W) = \sum_k\sum_l W_{k,l}^2
$$  </p>
<p>В приведенном выше выражении мы суммируем все возведенные в квадрат элементы <strong>W</strong>
Обратите внимание, что функция регуляризации не зависит от данных, она зависит только от весовых коэффициентов. Включение штрафа за регуляризацию завершает формирование полной функции потерь многоклассовой машины опорных векторов, которая состоит из двух компонентов: <strong>потерь данных</strong> (которые представляют собой средние потери <strong>$Li$</strong> по всем примерам) и <strong>потери от регуляризации</strong>. То есть полная потеря многоклассового SVM становится:  </p>
<p>$$
L =  \underbrace{ \frac{1}{N} \sum_i L_i }<em>\text{потеря данных} + \underbrace{ \lambda R(W) }</em>\text{потеря регуляризации} \\
$$  </p>
<p>Или расширить это в его полной форме:  </p>
<p>$$
L = \frac{1}{N} \sum_i \sum_{j\neq y_i} \left[ \max(0, f(x_i; W)<em y_i>j - f(x_i; W)</em>^2
$$  } + \Delta) \right] + \lambda \sum_k\sum_l W_{k,l</p>
<p>Где <strong>N</strong>— это количество обучающих примеров. Как видите, мы добавляем штраф за регуляризацию к функции потерь, взвешенной с помощью гиперпараметра <strong>λ</strong>.
Не существует простого способа задать этот гиперпараметр, и обычно он определяется методом перекрёстной проверки.   </p>
<p>Помимо мотивации, которую мы привели выше, существует множество желательных свойств, связанных с включением штрафа за регуляризацию, к которым мы вернёмся в следующих разделах. Например, оказывается, что включение штрафа L2 приводит к привлекательному свойству <strong>максимального запаса прочности</strong> в SVM (если вам интересно, см. <a href="http://cs229.stanford.edu/notes/cs229-notes3.pdf">CS229</a> для получения полной информации).  </p>
<p>Наиболее привлекательным свойством является то, что штрафные санкции за большие веса, как правило, улучшают обобщение, поскольку это означает, что ни один входной параметр сам по себе не может оказывать очень сильное влияние на оценки. Например, предположим, что у нас есть некоторый входной вектор <strong>$x=[1,1,1,1] ))</strong> и два весовых вектора__$w1=[1,0,0,0] $<strong>, </strong>$w2=[0,25,0,25,0,25,0,25]  $__. Затем $w_1^Tx = w_2^Tx = 1$. Таким образом, оба вектора весов приводят к одному и тому же скалярному произведению, но штраф L2 $w_1$ равно 1.0, в то время как штраф L2 равен $w_2$ составляет всего 0,5. Следовательно, согласно штрафу L2, вектор весов $w_2$ это предпочтительнее, так как достигается меньшая потеря при регуляризации. Интуитивно понятно, что это происходит потому, что веса в $w_2$ являются более компактными и менее размытыми. Поскольку штраф L2 предпочитает более компактные и менее размытые векторы весов, итоговому классификатору рекомендуется учитывать все входные параметры в небольших количествах, а не несколько входных параметров в очень больших количествах. Как мы увидим далее в этом курсе, этот эффект может улучшить обобщающую способность классификаторов на тестовых изображениях и привести к меньшему <em>переобучению</em>.  </p>
<p>Обратите внимание, что смещения не оказывают такого же эффекта, поскольку, в отличие от весовых коэффициентов, они не контролируют силу влияния входного параметра. Поэтому обычно нормализуют только весовые коэффициенты <strong>W</strong> но не из - за предубеждений <strong>b</strong>. Однако на практике это часто оказывается несущественным. Наконец, обратите внимание, что из-за штрафа за регуляризацию мы никогда не сможем добиться потери точности, равной 0,0, во всех примерах, потому что это возможно только в патологических условиях <strong>W=0</strong>.  </p>
<p><strong>Код</strong>. Вот функция потерь (без регуляризации), реализованная на Python как в не векторизованной, так и в полувекторной форме:  </p>
<div class="code"><pre class="code literal-block"><span class="n">def</span><span class="w"> </span><span class="n">L_i</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="err">:</span>
<span class="w">  </span><span class="ss">"""</span>
<span class="ss">  unvectorized version. Compute the multiclass svm loss for a single example (x,y)</span>
<span class="ss">  - x is a column vector representing an image (e.g. 3073 x 1 in CIFAR-10)</span>
<span class="ss">    with an appended bias dimension in the 3073-rd position (i.e. bias trick)</span>
<span class="ss">  - y is an integer giving index of correct class (e.g. between 0 and 9 in CIFAR-10)</span>
<span class="ss">  - W is the weight matrix (e.g. 10 x 3073 in CIFAR-10)</span>
<span class="ss">  """</span>
<span class="w">  </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">see</span><span class="w"> </span><span class="n">notes</span><span class="w"> </span><span class="n">about</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="n">later</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="k">section</span>
<span class="w">  </span><span class="n">scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">W</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="k">size</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="k">class</span>
<span class="w">  </span><span class="n">correct_class_score</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scores</span><span class="o">[</span><span class="n">y</span><span class="o">]</span>
<span class="w">  </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">W</span><span class="p">.</span><span class="n">shape</span><span class="o">[</span><span class="n">0</span><span class="o">]</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">classes</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="n">loss_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">D</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="k">iterate</span><span class="w"> </span><span class="k">over</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">wrong</span><span class="w"> </span><span class="n">classes</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nl">y</span><span class="p">:</span>
<span class="w">      </span><span class="err">#</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="k">class</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="n">loop</span><span class="w"> </span><span class="k">over</span><span class="w"> </span><span class="n">incorrect</span><span class="w"> </span><span class="n">classes</span>
<span class="w">      </span><span class="k">continue</span>
<span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">accumulate</span><span class="w"> </span><span class="n">loss</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="n">th</span><span class="w"> </span><span class="n">example</span>
<span class="w">    </span><span class="n">loss_i</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">scores</span><span class="o">[</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">correct_class_score</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delta</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">loss_i</span>

<span class="n">def</span><span class="w"> </span><span class="n">L_i_vectorized</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="err">:</span>
<span class="w">  </span><span class="ss">"""</span>
<span class="ss">  A faster half-vectorized implementation. half-vectorized</span>
<span class="ss">  refers to the fact that for a single example the implementation contains</span>
<span class="ss">  no for loops, but there is still one loop over the examples (outside this function)</span>
<span class="ss">  """</span>
<span class="w">  </span><span class="n">delta</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span>
<span class="w">  </span><span class="n">scores</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">W</span><span class="p">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="k">compute</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">margins</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">classes</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">vector</span><span class="w"> </span><span class="k">operation</span>
<span class="w">  </span><span class="n">margins</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">scores</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">delta</span><span class="p">)</span>
<span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">y</span><span class="o">-</span><span class="n">th</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="n">scores</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">scores</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="n">canceled</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">gave</span><span class="w"> </span><span class="n">delta</span><span class="p">.</span><span class="w"> </span><span class="n">We</span><span class="w"> </span><span class="n">want</span>
<span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">ignore</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">y</span><span class="o">-</span><span class="n">th</span><span class="w"> </span><span class="k">position</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">only</span><span class="w"> </span><span class="n">consider</span><span class="w"> </span><span class="n">margin</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="nf">max</span><span class="w"> </span><span class="n">wrong</span><span class="w"> </span><span class="k">class</span>
<span class="w">  </span><span class="n">margins</span><span class="o">[</span><span class="n">y</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="n">loss_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">margins</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">loss_i</span>

<span class="n">def</span><span class="w"> </span><span class="n">L</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="err">:</span>
<span class="w">  </span><span class="ss">"""</span>
<span class="ss">  fully-vectorized implementation :</span>
<span class="ss">  - X holds all the training examples as columns (e.g. 3073 x 50,000 in CIFAR-10)</span>
<span class="ss">  - y is array of integers specifying correct class (e.g. 50,000-D array)</span>
<span class="ss">  - W are weights (e.g. 10 x 3073)</span>
<span class="ss">  """</span>
<span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">evaluate</span><span class="w"> </span><span class="n">loss</span><span class="w"> </span><span class="k">over</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">examples</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">without</span><span class="w"> </span><span class="k">using</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">loops</span>
<span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="nf">left</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">exercise</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">reader</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">assignment</span>
<span class="w">  </span><span class="err">```</span>

<span class="n">Из</span><span class="w"> </span><span class="n">этого</span><span class="w"> </span><span class="n">раздела</span><span class="w"> </span><span class="n">можно</span><span class="w"> </span><span class="n">сделать</span><span class="w"> </span><span class="n">вывод</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">функция</span><span class="w"> </span><span class="n">потерь</span><span class="w"> </span><span class="n">SVM</span><span class="w"> </span><span class="n">использует</span><span class="w"> </span><span class="n">особый</span><span class="w"> </span><span class="n">подход</span><span class="w"> </span><span class="n">к</span><span class="w"> </span><span class="n">измерению</span><span class="w"> </span><span class="n">того</span><span class="p">,</span><span class="w"> </span><span class="n">насколько</span><span class="w"> </span><span class="n">прогнозы</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">основе</span><span class="w"> </span><span class="n">обучающих</span><span class="w"> </span><span class="n">данных</span><span class="w"> </span><span class="n">соответствуют</span><span class="w"> </span><span class="n">истинным</span><span class="w"> </span><span class="n">значениям</span><span class="p">.</span><span class="w"> </span><span class="n">Кроме</span><span class="w"> </span><span class="n">того</span><span class="p">,</span><span class="w"> </span><span class="n">делать</span><span class="w"> </span><span class="n">хорошие</span><span class="w"> </span><span class="n">прогнозы</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">основе</span><span class="w"> </span><span class="n">обучающего</span><span class="w"> </span><span class="n">набора</span><span class="w"> </span><span class="n">данных</span><span class="w"> </span><span class="n">равносильно</span><span class="w"> </span><span class="n">минимизации</span><span class="w"> </span><span class="n">функции</span><span class="w"> </span><span class="n">потерь</span><span class="p">.</span><span class="w">  </span>

<span class="o">&gt;</span><span class="n">Теперь</span><span class="w"> </span><span class="n">нам</span><span class="w"> </span><span class="n">нужно</span><span class="w"> </span><span class="n">придумать</span><span class="w"> </span><span class="n">способ</span><span class="w"> </span><span class="n">найти</span><span class="w"> </span><span class="n">веса</span><span class="p">,</span><span class="w"> </span><span class="n">которые</span><span class="w"> </span><span class="n">минимизируют</span><span class="w"> </span><span class="n">потери</span><span class="p">.</span><span class="w">  </span>

<span class="err">##</span><span class="w"> </span><span class="n">Практические</span><span class="w"> </span><span class="n">соображения</span><span class="w">  </span>

<span class="n">__Устанавливаем</span><span class="w"> </span><span class="n">дельту__</span><span class="p">.</span><span class="w"> </span><span class="n">Обратите</span><span class="w"> </span><span class="n">внимание</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">затронули</span><span class="w"> </span><span class="n">гиперпараметр</span><span class="w"> </span><span class="n">__Δ__</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">его</span><span class="w"> </span><span class="n">настройка</span><span class="p">.</span><span class="w"> </span><span class="n">Какое</span><span class="w"> </span><span class="n">значение</span><span class="w"> </span><span class="n">следует</span><span class="w"> </span><span class="n">установить</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">нужно</span><span class="w"> </span><span class="n">ли</span><span class="w"> </span><span class="n">проводить</span><span class="w"> </span><span class="n">перекрестную</span><span class="w"> </span><span class="n">проверку</span><span class="vm">?</span><span class="w"> </span><span class="n">Оказывается</span><span class="p">,</span><span class="w"> </span><span class="n">этот</span><span class="w"> </span><span class="n">гиперпараметр</span><span class="w"> </span><span class="n">можно</span><span class="w"> </span><span class="n">смело</span><span class="w"> </span><span class="n">устанавливать</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">__Δ</span><span class="o">=</span><span class="mf">1.0</span><span class="n">_</span><span class="w"> </span><span class="n">во</span><span class="w"> </span><span class="n">всех</span><span class="w"> </span><span class="n">случаях</span><span class="p">.</span><span class="w"> </span><span class="n">Гиперпараметры</span><span class="w"> </span><span class="n">__Δ__</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="nl">__λ__</span><span class="p">:</span><span class="w"> </span><span class="n">кажется</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">это</span><span class="w"> </span><span class="n">два</span><span class="w"> </span><span class="n">разных</span><span class="w"> </span><span class="n">гиперпараметра</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">самом</span><span class="w"> </span><span class="n">деле</span><span class="w"> </span><span class="n">они</span><span class="w"> </span><span class="n">оба</span><span class="w"> </span><span class="n">управляют</span><span class="w"> </span><span class="n">одним</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">тем</span><span class="w"> </span><span class="n">же</span><span class="w"> </span><span class="nl">компромиссом</span><span class="p">:</span><span class="w"> </span><span class="n">компромиссом</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="n">потерей</span><span class="w"> </span><span class="n">данных</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">потерей</span><span class="w"> </span><span class="n">от</span><span class="w"> </span><span class="n">регуляризации</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">целевой</span><span class="w"> </span><span class="n">функции</span><span class="p">.</span><span class="w"> </span><span class="n">Ключ</span><span class="w"> </span><span class="n">к</span><span class="w"> </span><span class="n">пониманию</span><span class="w"> </span><span class="n">этого</span><span class="w"> </span><span class="n">заключается</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">том</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">величина</span><span class="w"> </span><span class="n">весовых</span><span class="w"> </span><span class="n">коэффициентов</span><span class="w"> </span><span class="n">__W__</span><span class="w"> </span><span class="n">оказывает</span><span class="w"> </span><span class="n">непосредственное</span><span class="w"> </span><span class="n">влияние</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">баллы</span><span class="w"> </span><span class="p">(</span><span class="n">и</span><span class="p">,</span><span class="w"> </span><span class="n">следовательно</span><span class="p">,</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">их</span><span class="w"> </span><span class="n">разницу</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">по</span><span class="w"> </span><span class="n">мере</span><span class="w"> </span><span class="n">уменьшения</span><span class="w"> </span><span class="n">всех</span><span class="w"> </span><span class="n">значений</span><span class="w"> </span><span class="n">внутри</span><span class="w"> </span><span class="n">__W__</span><span class="w"> </span><span class="n">разница</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">баллах</span><span class="w"> </span><span class="n">будет</span><span class="w"> </span><span class="n">уменьшаться</span><span class="p">,</span><span class="w"> </span><span class="n">а</span><span class="w"> </span><span class="n">по</span><span class="w"> </span><span class="n">мере</span><span class="w"> </span><span class="n">увеличения</span><span class="w"> </span><span class="n">весов</span><span class="w"> </span><span class="n">разница</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">баллах</span><span class="w"> </span><span class="n">будет</span><span class="w"> </span><span class="n">увеличиваться</span><span class="p">.</span><span class="w"> </span><span class="n">Таким</span><span class="w"> </span><span class="n">образом</span><span class="p">,</span><span class="w"> </span><span class="n">точное</span><span class="w"> </span><span class="n">значение</span><span class="w"> </span><span class="n">разницы</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="n">баллами</span><span class="w"> </span><span class="p">(</span><span class="n">например</span><span class="p">,</span><span class="w"> </span><span class="n">__Δ</span><span class="o">=</span><span class="mi">1</span><span class="n">__</span><span class="w"> </span><span class="p">,</span><span class="w"> </span><span class="n">или</span><span class="w"> </span><span class="n">__Δ</span><span class="o">=</span><span class="mi">100</span><span class="n">__</span><span class="p">)</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">некотором</span><span class="w"> </span><span class="n">смысле</span><span class="w"> </span><span class="n">бессмысленно</span><span class="p">,</span><span class="w"> </span><span class="n">потому</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">веса</span><span class="w"> </span><span class="n">могут</span><span class="w"> </span><span class="n">произвольно</span><span class="w"> </span><span class="n">уменьшать</span><span class="w"> </span><span class="n">или</span><span class="w"> </span><span class="n">увеличивать</span><span class="w"> </span><span class="n">разницу</span><span class="p">.</span><span class="w"> </span><span class="n">Следовательно</span><span class="p">,</span><span class="w"> </span><span class="n">единственный</span><span class="w"> </span><span class="n">реальный</span><span class="w"> </span><span class="n">компромисс</span><span class="w"> </span><span class="n">заключается</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">том</span><span class="p">,</span><span class="w"> </span><span class="n">насколько</span><span class="w"> </span><span class="n">сильно</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">позволяем</span><span class="w"> </span><span class="n">весам</span><span class="w"> </span><span class="n">увеличиваться</span><span class="w"> </span><span class="p">(</span><span class="n">с</span><span class="w"> </span><span class="n">помощью</span><span class="w"> </span><span class="n">силы</span><span class="w"> </span><span class="n">регуляризации</span><span class="w"> </span><span class="n">__λ__</span><span class="p">).</span><span class="w">  </span>

<span class="n">__Связь</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">бинарной</span><span class="w"> </span><span class="n">машиной</span><span class="w"> </span><span class="n">опорных</span><span class="w"> </span><span class="n">векторов__</span><span class="p">.</span><span class="w"> </span><span class="n">Возможно</span><span class="p">,</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">пришли</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">этот</span><span class="w"> </span><span class="n">курс</span><span class="p">,</span><span class="w"> </span><span class="n">уже</span><span class="w"> </span><span class="n">имея</span><span class="w"> </span><span class="n">опыт</span><span class="w"> </span><span class="n">работы</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">бинарными</span><span class="w"> </span><span class="n">машинами</span><span class="w"> </span><span class="n">опорных</span><span class="w"> </span><span class="n">векторов</span><span class="p">,</span><span class="w"> </span><span class="n">где</span><span class="w"> </span><span class="n">потери</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="n">го</span><span class="w"> </span><span class="n">примера</span><span class="w"> </span><span class="n">можно</span><span class="w"> </span><span class="n">записать</span><span class="w"> </span><span class="nl">как</span><span class="p">:</span><span class="w">  </span>

<span class="err">$$</span>
<span class="n">L_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="err">\</span><span class="nf">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y_i</span><span class="w"> </span><span class="n">w</span><span class="o">^</span><span class="n">Tx_i</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">R</span><span class="p">(</span><span class="n">W</span><span class="p">)</span>
<span class="err">$$</span><span class="w">  </span>

<span class="n">где</span><span class="w"> </span><span class="n">__C__</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">гиперпараметром</span><span class="p">,</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="err">$</span><span class="n">y_i</span><span class="w"> </span><span class="err">\</span><span class="ow">in</span><span class="w"> </span><span class="err">\\{</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="w"> </span><span class="err">\\}</span><span class="w"> </span><span class="err">$</span><span class="p">.</span><span class="w"> </span><span class="n">Вы</span><span class="w"> </span><span class="n">можете</span><span class="w"> </span><span class="n">убедиться</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">представленная</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">этом</span><span class="w"> </span><span class="n">разделе</span><span class="w"> </span><span class="n">формулировка</span><span class="w"> </span><span class="n">содержит</span><span class="w"> </span><span class="n">бинарный</span><span class="w"> </span><span class="n">SVM</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">качестве</span><span class="w"> </span><span class="n">частного</span><span class="w"> </span><span class="n">случая</span><span class="p">,</span><span class="w"> </span><span class="n">когда</span><span class="w"> </span><span class="n">есть</span><span class="w"> </span><span class="n">только</span><span class="w"> </span><span class="n">два</span><span class="w"> </span><span class="n">класса</span><span class="p">.</span><span class="w"> </span><span class="n">То</span><span class="w"> </span><span class="n">есть</span><span class="p">,</span><span class="w"> </span><span class="n">если</span><span class="w"> </span><span class="n">бы</span><span class="w"> </span><span class="n">у</span><span class="w"> </span><span class="n">нас</span><span class="w"> </span><span class="n">было</span><span class="w"> </span><span class="n">только</span><span class="w"> </span><span class="n">два</span><span class="w"> </span><span class="n">класса</span><span class="p">,</span><span class="w"> </span><span class="n">то</span><span class="w"> </span><span class="n">потери</span><span class="w"> </span><span class="n">сводились</span><span class="w"> </span><span class="n">бы</span><span class="w"> </span><span class="n">к</span><span class="w"> </span><span class="n">бинарному</span><span class="w"> </span><span class="n">SVM</span><span class="p">,</span><span class="w"> </span><span class="n">показанному</span><span class="w"> </span><span class="n">выше</span><span class="p">.</span><span class="w"> </span><span class="n">Кроме</span><span class="w"> </span><span class="n">того</span><span class="p">,</span><span class="w"> </span><span class="n">__C__</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">этой</span><span class="w"> </span><span class="n">формулировке</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">__λ__</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">нашей</span><span class="w"> </span><span class="n">формулировке</span><span class="w"> </span><span class="n">контролируется</span><span class="w"> </span><span class="n">один</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">тот</span><span class="w"> </span><span class="n">же</span><span class="w"> </span><span class="n">компромисс</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">они</span><span class="w"> </span><span class="n">связаны</span><span class="w"> </span><span class="n">через</span><span class="w"> </span><span class="n">взаимное</span><span class="w"> </span><span class="n">отношение</span><span class="w"> </span><span class="err">$</span><span class="n">C</span><span class="w"> </span><span class="err">\</span><span class="n">propto</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="mi">1</span><span class="err">}{\</span><span class="n">lambda</span><span class="err">}$</span><span class="p">.</span><span class="w">  </span>

<span class="nl">__Примечание</span><span class="p">:</span><span class="w"> </span><span class="n">оптимизация</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">прямой</span><span class="w"> </span><span class="n">форме__</span><span class="p">.</span><span class="w"> </span><span class="n">Если</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">пришли</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">этот</span><span class="w"> </span><span class="n">курс</span><span class="p">,</span><span class="w"> </span><span class="n">уже</span><span class="w"> </span><span class="n">имея</span><span class="w"> </span><span class="n">представление</span><span class="w"> </span><span class="n">о</span><span class="w"> </span><span class="n">SVM</span><span class="p">,</span><span class="w"> </span><span class="n">то</span><span class="p">,</span><span class="w"> </span><span class="n">возможно</span><span class="p">,</span><span class="w"> </span><span class="n">слышали</span><span class="w"> </span><span class="n">о</span><span class="w"> </span><span class="n">ядрах</span><span class="p">,</span><span class="w"> </span><span class="n">двойственных</span><span class="w"> </span><span class="n">задачах</span><span class="p">,</span><span class="w"> </span><span class="n">алгоритме</span><span class="w"> </span><span class="n">SMO</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">т</span><span class="p">.</span><span class="w"> </span><span class="n">д</span><span class="p">.</span><span class="w"> </span><span class="n">В</span><span class="w"> </span><span class="n">этом</span><span class="w"> </span><span class="n">курсе</span><span class="w"> </span><span class="p">(</span><span class="n">как</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">случае</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">нейронными</span><span class="w"> </span><span class="n">сетями</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">целом</span><span class="p">)</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">всегда</span><span class="w"> </span><span class="n">будем</span><span class="w"> </span><span class="n">работать</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">задачами</span><span class="w"> </span><span class="n">оптимизации</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">их</span><span class="w"> </span><span class="n">прямой</span><span class="w"> </span><span class="n">форме</span><span class="w"> </span><span class="n">без</span><span class="w"> </span><span class="n">ограничений</span><span class="p">.</span><span class="w"> </span><span class="n">Многие</span><span class="w"> </span><span class="n">из</span><span class="w"> </span><span class="n">этих</span><span class="w"> </span><span class="n">задач</span><span class="w"> </span><span class="n">технически</span><span class="w"> </span><span class="n">не</span><span class="w"> </span><span class="n">являются</span><span class="w"> </span><span class="n">дифференцируемыми</span><span class="w"> </span><span class="p">(</span><span class="n">например</span><span class="p">,</span><span class="w"> </span><span class="n">функция</span><span class="w"> </span><span class="nf">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="n">не</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">дифференцируемой</span><span class="p">,</span><span class="w"> </span><span class="n">потому</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">имеет</span><span class="w"> </span><span class="n">излом</span><span class="w"> </span><span class="n">при</span><span class="w"> </span><span class="n">x</span><span class="o">=</span><span class="n">y</span><span class="p">),</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">практике</span><span class="w"> </span><span class="n">это</span><span class="w"> </span><span class="n">не</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">проблемой</span><span class="p">,</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">обычно</span><span class="w"> </span><span class="n">используется</span><span class="w"> </span><span class="n">субградиент</span><span class="p">.</span><span class="w">  </span>

<span class="nl">Примечание</span><span class="p">:</span><span class="w"> </span><span class="n">другие</span><span class="w"> </span><span class="n">многоклассовые</span><span class="w"> </span><span class="n">формулировки</span><span class="w"> </span><span class="n">SVM</span><span class="p">.</span><span class="w"> </span><span class="n">Стоит</span><span class="w"> </span><span class="n">отметить</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">многоклассовая</span><span class="w"> </span><span class="n">формулировка</span><span class="w"> </span><span class="n">SVM</span><span class="p">,</span><span class="w"> </span><span class="n">представленная</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">этом</span><span class="w"> </span><span class="n">разделе</span><span class="p">,</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">одним</span><span class="w"> </span><span class="n">из</span><span class="w"> </span><span class="n">немногих</span><span class="w"> </span><span class="n">способов</span><span class="w"> </span><span class="n">формулировки</span><span class="w"> </span><span class="n">SVM</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">нескольких</span><span class="w"> </span><span class="n">классов</span><span class="p">.</span><span class="w"> </span><span class="n">Другой</span><span class="w"> </span><span class="n">часто</span><span class="w"> </span><span class="n">используемой</span><span class="w"> </span><span class="n">формой</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">SVM</span><span class="w"> </span><span class="n">_</span><span class="err">«</span><span class="n">один</span><span class="w"> </span><span class="n">против</span><span class="w"> </span><span class="n">всех</span><span class="err">»</span><span class="n">_</span><span class="w"> </span><span class="p">(</span><span class="n">OVA</span><span class="p">),</span><span class="w"> </span><span class="n">которая</span><span class="w"> </span><span class="n">обучает</span><span class="w"> </span><span class="n">независимый</span><span class="w"> </span><span class="n">бинарный</span><span class="w"> </span><span class="n">SVM</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">каждого</span><span class="w"> </span><span class="n">класса</span><span class="w"> </span><span class="n">по</span><span class="w"> </span><span class="n">сравнению</span><span class="w"> </span><span class="n">со</span><span class="w"> </span><span class="n">всеми</span><span class="w"> </span><span class="n">остальными</span><span class="w"> </span><span class="n">классами</span><span class="p">.</span><span class="w"> </span><span class="n">С</span><span class="w"> </span><span class="n">ней</span><span class="w"> </span><span class="n">связана</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">реже</span><span class="w"> </span><span class="n">встречается</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">практике</span><span class="w"> </span><span class="n">стратегия</span><span class="w"> </span><span class="n">_</span><span class="err">«</span><span class="n">все</span><span class="w"> </span><span class="n">против</span><span class="w"> </span><span class="n">всех</span><span class="err">»</span><span class="n">_</span><span class="w"> </span><span class="p">(</span><span class="n">AVA</span><span class="p">).</span><span class="w"> </span><span class="n">Наша</span><span class="w"> </span><span class="n">формулировка</span><span class="w"> </span><span class="n">основана</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">версии</span><span class="w"> </span><span class="o">[</span><span class="n">Weston and Watkins 1999</span><span class="o">]</span><span class="p">(</span><span class="nl">https</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="p">.</span><span class="n">elen</span><span class="p">.</span><span class="n">ucl</span><span class="p">.</span><span class="n">ac</span><span class="p">.</span><span class="n">be</span><span class="o">/</span><span class="n">Proceedings</span><span class="o">/</span><span class="n">esann</span><span class="o">/</span><span class="n">esannpdf</span><span class="o">/</span><span class="n">es1999</span><span class="o">-</span><span class="mf">461.</span><span class="n">pdf</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pdf</span><span class="p">),</span><span class="w"> </span><span class="n">которая</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">более</span><span class="w"> </span><span class="n">мощной</span><span class="w"> </span><span class="n">версией</span><span class="p">,</span><span class="w"> </span><span class="n">чем</span><span class="w"> </span><span class="n">OVA</span><span class="w"> </span><span class="p">(</span><span class="n">в</span><span class="w"> </span><span class="n">том</span><span class="w"> </span><span class="n">смысле</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">можете</span><span class="w"> </span><span class="n">создавать</span><span class="w"> </span><span class="n">многоклассовые</span><span class="w"> </span><span class="n">наборы</span><span class="w"> </span><span class="n">данных</span><span class="p">,</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">которых</span><span class="w"> </span><span class="n">эта</span><span class="w"> </span><span class="n">версия</span><span class="w"> </span><span class="n">может</span><span class="w"> </span><span class="n">обеспечить</span><span class="w"> </span><span class="n">нулевую</span><span class="w"> </span><span class="n">потерю</span><span class="w"> </span><span class="n">данных</span><span class="p">,</span><span class="w"> </span><span class="n">а</span><span class="w"> </span><span class="n">OVA</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="n">нет</span><span class="p">.</span><span class="w"> </span><span class="n">Если</span><span class="w"> </span><span class="n">интересно</span><span class="p">,</span><span class="w"> </span><span class="n">подробности</span><span class="w"> </span><span class="n">можно</span><span class="w"> </span><span class="n">найти</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">статье</span><span class="p">).</span><span class="w"> </span><span class="n">Последняя</span><span class="w"> </span><span class="n">формулировка</span><span class="p">,</span><span class="w"> </span><span class="n">которую</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">можете</span><span class="w"> </span><span class="n">увидеть</span><span class="p">,</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="n">это</span><span class="w"> </span><span class="n">_структурированный_</span><span class="w"> </span><span class="n">SVM</span><span class="p">,</span><span class="w"> </span><span class="n">который</span><span class="w"> </span><span class="n">максимизирует</span><span class="w"> </span><span class="n">разницу</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="n">оценкой</span><span class="w"> </span><span class="n">правильного</span><span class="w"> </span><span class="n">класса</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">оценкой</span><span class="w"> </span><span class="n">наиболее</span><span class="w"> </span><span class="n">близкого</span><span class="w"> </span><span class="n">к</span><span class="w"> </span><span class="n">нему</span><span class="w"> </span><span class="n">неправильного</span><span class="w"> </span><span class="n">класса</span><span class="p">.</span><span class="w"> </span><span class="n">Понимание</span><span class="w"> </span><span class="n">различий</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="n">этими</span><span class="w"> </span><span class="n">формулировками</span><span class="w"> </span><span class="n">выходит</span><span class="w"> </span><span class="n">за</span><span class="w"> </span><span class="n">рамки</span><span class="w"> </span><span class="n">данного</span><span class="w"> </span><span class="n">курса</span><span class="p">.</span><span class="w"> </span><span class="n">Версия</span><span class="p">,</span><span class="w"> </span><span class="n">представленная</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">этих</span><span class="w"> </span><span class="n">заметках</span><span class="p">,</span><span class="w"> </span><span class="n">безопасна</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">использования</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">практике</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="p">,</span><span class="w"> </span><span class="n">возможно</span><span class="p">,</span><span class="w"> </span><span class="n">самая</span><span class="w"> </span><span class="n">простая</span><span class="w"> </span><span class="n">стратегия</span><span class="w"> </span><span class="n">OVA</span><span class="w"> </span><span class="n">тоже</span><span class="w"> </span><span class="n">будет</span><span class="w"> </span><span class="n">работать</span><span class="w"> </span><span class="p">(</span><span class="n">как</span><span class="w"> </span><span class="n">утверждают</span><span class="w"> </span><span class="n">Рикин</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">др</span><span class="p">.</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="mi">2004</span><span class="w"> </span><span class="n">году</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="o">[</span><span class="n">«В защиту классификации «один против всех»</span><span class="o">]</span><span class="p">(</span><span class="nl">http</span><span class="p">:</span><span class="o">//</span><span class="n">www</span><span class="p">.</span><span class="n">jmlr</span><span class="p">.</span><span class="n">org</span><span class="o">/</span><span class="n">papers</span><span class="o">/</span><span class="n">volume5</span><span class="o">/</span><span class="n">rifkin04a</span><span class="o">/</span><span class="n">rifkin04a</span><span class="p">.</span><span class="n">pdf</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">pdf</span><span class="p">)).</span><span class="w">  </span>

<span class="err">##</span><span class="w"> </span><span class="n">Классификатор</span><span class="w"> </span><span class="n">Softmax</span><span class="w">  </span>

<span class="n">Оказывается</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">SVM</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="n">один</span><span class="w"> </span><span class="n">из</span><span class="w"> </span><span class="n">двух</span><span class="w"> </span><span class="n">наиболее</span><span class="w"> </span><span class="n">распространённых</span><span class="w"> </span><span class="n">классификаторов</span><span class="p">.</span><span class="w"> </span><span class="n">Другой</span><span class="w"> </span><span class="n">популярный</span><span class="w"> </span><span class="n">вариант</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="n">__классификатор</span><span class="w"> </span><span class="n">Softmax__</span><span class="p">,</span><span class="w"> </span><span class="n">у</span><span class="w"> </span><span class="n">которого</span><span class="w"> </span><span class="n">другая</span><span class="w"> </span><span class="n">функция</span><span class="w"> </span><span class="n">потерь</span><span class="p">.</span><span class="w"> </span><span class="n">Если</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">раньше</span><span class="w"> </span><span class="n">слышали</span><span class="w"> </span><span class="n">о</span><span class="w"> </span><span class="n">классификаторе</span><span class="w"> </span><span class="n">бинарной</span><span class="w"> </span><span class="n">логистической</span><span class="w"> </span><span class="n">регрессии</span><span class="p">,</span><span class="w"> </span><span class="n">то</span><span class="w"> </span><span class="n">классификатор</span><span class="w"> </span><span class="n">Softmax</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="n">это</span><span class="w"> </span><span class="n">его</span><span class="w"> </span><span class="n">обобщение</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">нескольких</span><span class="w"> </span><span class="n">классов</span><span class="p">.</span><span class="w"> </span><span class="n">В</span><span class="w"> </span><span class="n">отличие</span><span class="w"> </span><span class="n">от</span><span class="w"> </span><span class="n">SVM</span><span class="p">,</span><span class="w"> </span><span class="n">который</span><span class="w"> </span><span class="n">обрабатывает</span><span class="w"> </span><span class="n">выходные</span><span class="w"> </span><span class="n">данные</span><span class="w"> </span><span class="err">$</span><span class="n">f</span><span class="p">(</span><span class="n">x_i</span><span class="p">,</span><span class="n">W</span><span class="p">)</span><span class="err">$</span><span class="p">.</span><span class="w"> </span><span class="n">В</span><span class="w"> </span><span class="n">качестве</span><span class="w"> </span><span class="p">(</span><span class="n">некалиброванных</span><span class="w"> </span><span class="n">и</span><span class="p">,</span><span class="w"> </span><span class="n">возможно</span><span class="p">,</span><span class="w"> </span><span class="n">трудно</span><span class="w"> </span><span class="n">интерпретируемых</span><span class="p">)</span><span class="w"> </span><span class="n">оценок</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">каждого</span><span class="w"> </span><span class="n">класса</span><span class="w"> </span><span class="n">классификатор</span><span class="w"> </span><span class="n">Softmax</span><span class="w"> </span><span class="n">даёт</span><span class="w"> </span><span class="n">чуть</span><span class="w"> </span><span class="n">более</span><span class="w"> </span><span class="n">понятный</span><span class="w"> </span><span class="n">результат</span><span class="w"> </span><span class="p">(</span><span class="n">нормализованные</span><span class="w"> </span><span class="n">вероятности</span><span class="w"> </span><span class="n">классов</span><span class="p">),</span><span class="w"> </span><span class="n">а</span><span class="w"> </span><span class="n">также</span><span class="w"> </span><span class="n">имеет</span><span class="w"> </span><span class="n">вероятностную</span><span class="w"> </span><span class="n">интерпретацию</span><span class="p">,</span><span class="w"> </span><span class="n">которую</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">вскоре</span><span class="w"> </span><span class="n">опишем</span><span class="p">.</span><span class="w"> </span><span class="n">В</span><span class="w"> </span><span class="n">классификаторе</span><span class="w"> </span><span class="n">Softmax</span><span class="w"> </span><span class="n">функция</span><span class="p">,</span><span class="w"> </span><span class="n">отображающая</span><span class="w"> </span><span class="err">$</span><span class="n">f</span><span class="p">(</span><span class="n">x_i</span><span class="p">;</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">W</span><span class="w"> </span><span class="n">x_i</span><span class="err">$</span><span class="w"> </span><span class="n">остаётся</span><span class="w"> </span><span class="n">неизменным</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">теперь</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">интерпретируем</span><span class="w"> </span><span class="n">эти</span><span class="w"> </span><span class="n">оценки</span><span class="w"> </span><span class="n">как</span><span class="w"> </span><span class="n">ненормированные</span><span class="w"> </span><span class="n">логарифмические</span><span class="w"> </span><span class="n">вероятности</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">каждого</span><span class="w"> </span><span class="n">класса</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">заменяем</span><span class="w">  </span><span class="n">_потерю</span><span class="w"> </span><span class="n">от</span><span class="w"> </span><span class="n">перегиба_</span><span class="w"> </span><span class="n">__потерю</span><span class="w"> </span><span class="n">от</span><span class="w"> </span><span class="n">перекрёстной</span><span class="w"> </span><span class="n">энтропии__</span><span class="p">,</span><span class="w"> </span><span class="n">которая</span><span class="w"> </span><span class="n">имеет</span><span class="w"> </span><span class="nl">вид</span><span class="p">:</span><span class="w">  </span>

<span class="err">$$</span>
<span class="n">L_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="err">\</span><span class="nf">log</span><span class="err">\</span><span class="nf">left</span><span class="p">(</span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}}}{</span><span class="w"> </span><span class="err">\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}</span><span class="w"> </span><span class="err">}\</span><span class="nf">right</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="n">hspace</span><span class="err">{</span><span class="mf">0.5</span><span class="ow">in</span><span class="err">}</span><span class="w"> </span><span class="err">\</span><span class="nc">text</span><span class="err">{</span><span class="ow">or</span><span class="w"> </span><span class="n">equivalently</span><span class="err">}</span><span class="w"> </span><span class="err">\</span><span class="n">hspace</span><span class="err">{</span><span class="mf">0.5</span><span class="ow">in</span><span class="err">}</span><span class="w"> </span><span class="n">L_i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">\</span><span class="nf">log</span><span class="err">\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}</span>
<span class="err">$$</span><span class="w">  </span>

<span class="n">где</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">используем</span><span class="w"> </span><span class="n">обозначение</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">f_j</span><span class="err">$</span><span class="n">__</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">обозначения</span><span class="w"> </span><span class="n">j</span><span class="o">-</span><span class="n">го</span><span class="w"> </span><span class="n">элемента</span><span class="w"> </span><span class="n">вектора</span><span class="w"> </span><span class="n">оценок</span><span class="w"> </span><span class="n">класса</span><span class="w"> </span><span class="n">__f__</span><span class="p">.</span><span class="w"> </span><span class="n">Как</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">прежде</span><span class="p">,</span><span class="w"> </span><span class="n">полная</span><span class="w"> </span><span class="n">потеря</span><span class="w"> </span><span class="n">набора</span><span class="w"> </span><span class="n">данных</span><span class="w"> </span><span class="n">является</span><span class="w"> </span><span class="n">средним</span><span class="w"> </span><span class="n">значением</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">L_i</span><span class="err">$</span><span class="n">__</span>
<span class="w"> </span><span class="n">по</span><span class="w"> </span><span class="n">всем</span><span class="w"> </span><span class="n">обучающим</span><span class="w"> </span><span class="n">примерам</span><span class="w"> </span><span class="n">вместе</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">термином</span><span class="w"> </span><span class="n">регуляризации</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">R</span><span class="p">(</span><span class="n">W</span><span class="p">)</span><span class="err">$</span><span class="n">__</span><span class="p">.</span><span class="w"> </span><span class="n">Функция</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">f_j</span><span class="p">(</span><span class="n">z</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">z_j</span><span class="err">}}{\</span><span class="n">sum_k</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">z_k</span><span class="err">}}</span><span class="w"> </span><span class="err">$</span><span class="n">__</span><span class="w"> </span><span class="n">называется</span><span class="w"> </span><span class="n">__функцией</span><span class="w"> </span><span class="nl">softmax__</span><span class="p">:</span><span class="w"> </span><span class="n">она</span><span class="w"> </span><span class="n">принимает</span><span class="w"> </span><span class="n">вектор</span><span class="w"> </span><span class="n">произвольных</span><span class="w"> </span><span class="n">числовых</span><span class="w"> </span><span class="n">значений</span><span class="w">  </span><span class="p">(</span><span class="n">в</span><span class="w"> </span><span class="err">$</span><span class="n">z</span><span class="err">$</span><span class="p">)</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">преобразует</span><span class="w"> </span><span class="n">его</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">вектор</span><span class="w"> </span><span class="n">значений</span><span class="w"> </span><span class="n">от</span><span class="w"> </span><span class="n">нуля</span><span class="w"> </span><span class="n">до</span><span class="w"> </span><span class="n">единицы</span><span class="p">,</span><span class="w"> </span><span class="n">сумма</span><span class="w"> </span><span class="n">которых</span><span class="w"> </span><span class="n">равна</span><span class="w"> </span><span class="n">единице</span><span class="p">.</span><span class="w"> </span><span class="n">Полная</span><span class="w"> </span><span class="n">функция</span><span class="w"> </span><span class="n">потерь</span><span class="w"> </span><span class="n">перекрёстной</span><span class="w"> </span><span class="n">энтропии</span><span class="p">,</span><span class="w"> </span><span class="n">включающая</span><span class="w"> </span><span class="n">функцию</span><span class="w"> </span><span class="n">softmax</span><span class="p">,</span><span class="w"> </span><span class="n">может</span><span class="w"> </span><span class="n">показаться</span><span class="w"> </span><span class="n">пугающей</span><span class="p">,</span><span class="w"> </span><span class="n">если</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">видите</span><span class="w"> </span><span class="n">её</span><span class="w"> </span><span class="n">впервые</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">её</span><span class="w"> </span><span class="n">относительно</span><span class="w"> </span><span class="n">легко</span><span class="w"> </span><span class="n">объяснить</span><span class="p">.</span><span class="w">  </span>

<span class="w"> </span><span class="n">__С</span><span class="w"> </span><span class="n">точки</span><span class="w"> </span><span class="n">зрения</span><span class="w"> </span><span class="n">теории</span><span class="w"> </span><span class="n">информации__</span><span class="p">.</span><span class="w"> </span><span class="n">_Перекрёстная</span><span class="w"> </span><span class="n">энтропия_</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="err">«</span><span class="n">истинным</span><span class="err">»</span><span class="w"> </span><span class="n">распределением</span><span class="w"> </span><span class="n">p</span>
<span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">предполагаемое</span><span class="w"> </span><span class="n">распределение</span><span class="w"> </span><span class="n">__q__</span><span class="w"> </span><span class="n">определяется</span><span class="w"> </span><span class="nl">как</span><span class="p">:</span><span class="w">  </span>

<span class="err">$$</span>
<span class="n">H</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="err">\</span><span class="n">sum_x</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="err">\</span><span class="nf">log</span><span class="w"> </span><span class="n">q</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="err">$$</span><span class="w">  </span>

<span class="n">Таким</span><span class="w"> </span><span class="n">образом</span><span class="p">,</span><span class="w"> </span><span class="n">классификатор</span><span class="w"> </span><span class="n">Softmax</span><span class="w"> </span><span class="n">минимизирует</span><span class="w"> </span><span class="n">перекрестную</span><span class="w"> </span><span class="n">энтропию</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="n">оцененными</span><span class="w"> </span><span class="n">вероятностями</span><span class="w"> </span><span class="n">классов</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="err">$</span><span class="n">q</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}}</span><span class="w">  </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}</span><span class="w"> </span><span class="err">$</span><span class="w"> </span><span class="n">как</span><span class="w"> </span><span class="n">показано</span><span class="w"> </span><span class="n">выше</span><span class="p">)</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">_</span><span class="err">«</span><span class="n">истинное</span><span class="err">»</span><span class="n">_</span><span class="w"> </span><span class="n">распределение</span><span class="p">,</span><span class="w"> </span><span class="n">которое</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">этой</span><span class="w"> </span><span class="n">интерпретации</span><span class="w"> </span><span class="n">представляет</span><span class="w"> </span><span class="n">собой</span><span class="w"> </span><span class="n">распределение</span><span class="p">,</span><span class="w"> </span><span class="n">при</span><span class="w"> </span><span class="n">котором</span><span class="w"> </span><span class="n">вся</span><span class="w"> </span><span class="n">масса</span><span class="w"> </span><span class="n">вероятностей</span><span class="w"> </span><span class="n">приходится</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">правильный</span><span class="w"> </span><span class="n">класс</span><span class="w"> </span>
<span class="n">то</span><span class="w"> </span><span class="n">есть</span><span class="w"> </span><span class="err">$</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">0, \ldots 1, \ldots, 0</span><span class="o">]</span><span class="err">\\</span><span class="w"> </span><span class="n">содержит</span><span class="w"> </span><span class="n">единственную</span><span class="w"> </span><span class="n">единицу</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">y_i</span><span class="err">$</span><span class="n">__</span><span class="o">-</span><span class="n">й</span><span class="w"> </span><span class="n">позиции</span><span class="p">.).</span><span class="w"> </span><span class="n">Более</span><span class="w"> </span><span class="n">того</span><span class="p">,</span><span class="w"> </span><span class="n">поскольку</span><span class="w"> </span><span class="n">кросс</span><span class="o">-</span><span class="n">энтропию</span><span class="w"> </span><span class="n">можно</span><span class="w"> </span><span class="n">записать</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">терминах</span><span class="w"> </span><span class="n">энтропии</span><span class="p">,</span><span class="w"> </span><span class="n">а</span><span class="w"> </span><span class="n">дивергенцию</span><span class="w"> </span><span class="n">Кульбака</span><span class="o">-</span><span class="n">Лейблера</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">как</span><span class="w"> </span><span class="err">$</span><span class="n">H</span><span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">H</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">D_</span><span class="err">{</span><span class="n">KL</span><span class="err">}</span><span class="p">(</span><span class="n">p</span><span class="err">\</span><span class="o">|</span><span class="err">\</span><span class="o">|</span><span class="n">q</span><span class="p">)</span><span class="err">$</span><span class="p">,</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">энтропия</span><span class="w"> </span><span class="n">дельта</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">функции</span><span class="w"> </span><span class="n">__p__</span><span class="w"> </span><span class="n">равно</span><span class="w"> </span><span class="n">нулю</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">также</span><span class="w"> </span><span class="n">эквивалентно</span><span class="w"> </span><span class="n">минимизации</span><span class="w"> </span><span class="n">расхождения</span><span class="w"> </span><span class="n">Кульбака</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="n">Лейблера</span><span class="w"> </span><span class="n">между</span><span class="w"> </span><span class="n">двумя</span><span class="w"> </span><span class="n">распределениями</span><span class="w"> </span><span class="p">(</span><span class="n">мера</span><span class="w"> </span><span class="n">расстояния</span><span class="p">).</span><span class="w"> </span><span class="n">Другими</span><span class="w"> </span><span class="n">словами</span><span class="p">,</span><span class="w"> </span><span class="n">цель</span><span class="w"> </span><span class="n">кросс</span><span class="o">-</span><span class="n">энтропии</span><span class="w"> </span><span class="n">_заключается</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">том_</span><span class="p">,</span><span class="w"> </span><span class="n">чтобы</span><span class="w"> </span><span class="n">прогнозируемое</span><span class="w"> </span><span class="n">распределение</span><span class="w"> </span><span class="n">было</span><span class="w"> </span><span class="n">сосредоточено</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">правильном</span><span class="w"> </span><span class="n">ответе</span><span class="p">.</span><span class="w">  </span>

<span class="n">__Вероятностная</span><span class="w"> </span><span class="n">интерпретация__</span><span class="p">.</span><span class="w"> </span><span class="n">Глядя</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">выражение</span><span class="p">,</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">видим</span><span class="p">,</span><span class="w"> </span><span class="nl">что</span><span class="p">:</span><span class="w">  </span>

<span class="err">$$</span>
<span class="n">P</span><span class="p">(</span><span class="n">y_i</span><span class="w"> </span><span class="err">\</span><span class="n">mid</span><span class="w"> </span><span class="n">x_i</span><span class="p">;</span><span class="w"> </span><span class="n">W</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}}}{\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}</span><span class="w"> </span><span class="err">}</span>
<span class="err">$$</span>

<span class="n">может</span><span class="w"> </span><span class="n">быть</span><span class="w"> </span><span class="n">интерпретирована</span><span class="w"> </span><span class="n">как</span><span class="w"> </span><span class="p">(</span><span class="n">нормализованная</span><span class="p">)</span><span class="w"> </span><span class="n">вероятность</span><span class="p">,</span><span class="w"> </span><span class="n">присвоенная</span><span class="w"> </span><span class="n">правильной</span><span class="w"> </span><span class="n">метке</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">y_i</span><span class="err">$</span><span class="n">__</span><span class="w"> </span><span class="n">учитывая</span><span class="w"> </span><span class="n">изображение</span><span class="w"> </span><span class="n">__</span><span class="err">$</span><span class="n">x_i</span><span class="err">$</span><span class="n">__</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">параметризуется</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">помощью</span><span class="w"> </span><span class="n">__W__</span><span class="p">.</span><span class="n">Чтобы</span><span class="w"> </span><span class="n">понять</span><span class="w"> </span><span class="n">это</span><span class="p">,</span><span class="w"> </span><span class="n">вспомните</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">классификатор</span><span class="w"> </span><span class="n">Softmax</span><span class="w"> </span><span class="n">интерпретирует</span><span class="w"> </span><span class="n">оценки</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">выходном</span><span class="w"> </span><span class="n">векторе</span><span class="w"> </span><span class="n">__f__</span><span class="p">,</span><span class="w"> </span><span class="n">как</span><span class="w"> </span><span class="n">ненормированные</span><span class="w"> </span><span class="n">логарифмические</span><span class="w"> </span><span class="n">вероятности</span><span class="p">.</span><span class="w"> </span><span class="n">Возведение</span><span class="w"> </span><span class="n">этих</span><span class="w"> </span><span class="n">величин</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">степень</span><span class="w"> </span><span class="n">даёт</span><span class="w"> </span><span class="p">(</span><span class="n">ненормированные</span><span class="p">)</span><span class="w"> </span><span class="n">вероятности</span><span class="p">,</span><span class="w"> </span><span class="n">а</span><span class="w"> </span><span class="n">деление</span><span class="w"> </span><span class="n">выполняет</span><span class="w"> </span><span class="n">нормализацию</span><span class="p">,</span><span class="w"> </span><span class="n">чтобы</span><span class="w"> </span><span class="n">сумма</span><span class="w"> </span><span class="n">вероятностей</span><span class="w"> </span><span class="n">равнялась</span><span class="w"> </span><span class="n">единице</span><span class="p">.</span><span class="w"> </span><span class="n">Таким</span><span class="w"> </span><span class="n">образом</span><span class="p">,</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">вероятностной</span><span class="w"> </span><span class="n">интерпретации</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">минимизируем</span><span class="w"> </span><span class="n">отрицательную</span><span class="w"> </span><span class="n">логарифмическую</span><span class="w"> </span><span class="n">вероятность</span><span class="w"> </span><span class="n">правильного</span><span class="w"> </span><span class="n">класса</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">можно</span><span class="w"> </span><span class="n">интерпретировать</span><span class="w"> </span><span class="n">как</span><span class="w"> </span><span class="n">выполнение</span><span class="w"> </span><span class="n">__оценки</span><span class="w"> </span><span class="n">максимального</span><span class="w"> </span><span class="n">правдоподобия__</span><span class="w"> </span><span class="p">(</span><span class="n">MLE</span><span class="p">).</span><span class="w"> </span><span class="n">Преимущество</span><span class="w"> </span><span class="n">такого</span><span class="w"> </span><span class="n">подхода</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">том</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">теперь</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">можем</span><span class="w"> </span><span class="n">интерпретировать</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">член</span><span class="w"> </span><span class="n">регуляризации</span><span class="w"> </span><span class="n">__R</span><span class="p">(</span><span class="n">W</span><span class="p">)</span><span class="n">__</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">полной</span><span class="w"> </span><span class="n">функции</span><span class="w"> </span><span class="n">потерь</span><span class="p">,</span><span class="w"> </span><span class="n">исходящей</span><span class="w"> </span><span class="n">из</span><span class="w"> </span><span class="n">гауссовского</span><span class="w"> </span><span class="n">априора</span><span class="w"> </span><span class="n">по</span><span class="w"> </span><span class="n">весовой</span><span class="w"> </span><span class="n">матрице</span><span class="w"> </span><span class="n">__W__</span><span class="p">,</span><span class="w"> </span><span class="n">где</span><span class="w"> </span><span class="n">вместо</span><span class="w"> </span><span class="n">MLE</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">выполняем</span><span class="w"> </span><span class="n">оценку</span><span class="w"> </span><span class="n">_максимального</span><span class="w"> </span><span class="n">апостериорного</span><span class="w"> </span><span class="n">значения_</span><span class="w"> </span><span class="p">(</span><span class="k">MAP</span><span class="p">).</span><span class="w"> </span><span class="n">Мы</span><span class="w"> </span><span class="n">приводим</span><span class="w"> </span><span class="n">эти</span><span class="w"> </span><span class="n">интерпретации</span><span class="p">,</span><span class="w"> </span><span class="n">чтобы</span><span class="w"> </span><span class="n">помочь</span><span class="w"> </span><span class="n">вам</span><span class="w"> </span><span class="n">разобраться</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">подробное</span><span class="w"> </span><span class="n">описание</span><span class="w"> </span><span class="n">этого</span><span class="w"> </span><span class="n">вывода</span><span class="w"> </span><span class="n">выходит</span><span class="w"> </span><span class="n">за</span><span class="w"> </span><span class="n">рамки</span><span class="w"> </span><span class="n">данного</span><span class="w"> </span><span class="n">курса</span><span class="p">.</span><span class="w">  </span>

<span class="n">__Практические</span><span class="w"> </span><span class="nl">вопросы</span><span class="p">:</span><span class="w"> </span><span class="n">числовая</span><span class="w"> </span><span class="n">стабильность__</span><span class="p">.</span><span class="w"> </span><span class="n">Когда</span><span class="w"> </span><span class="n">вы</span><span class="w"> </span><span class="n">пишете</span><span class="w"> </span><span class="n">код</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">вычисления</span><span class="w"> </span><span class="n">функции</span><span class="w"> </span><span class="n">Softmax</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">практике</span><span class="p">,</span><span class="w"> </span><span class="n">промежуточные</span><span class="w"> </span><span class="n">значения</span><span class="err">$</span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}}$</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="err">$\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}$</span><span class="w"> </span><span class="n">может</span><span class="w"> </span><span class="n">быть</span><span class="w"> </span><span class="n">очень</span><span class="w"> </span><span class="n">большим</span><span class="w"> </span><span class="n">из</span><span class="o">-</span><span class="n">за</span><span class="w"> </span><span class="n">экспоненциальных</span><span class="w"> </span><span class="n">функций</span><span class="p">.</span><span class="w"> </span><span class="n">Деление</span><span class="w"> </span><span class="n">больших</span><span class="w"> </span><span class="n">чисел</span><span class="w"> </span><span class="n">может</span><span class="w"> </span><span class="n">быть</span><span class="w"> </span><span class="n">неустойчивым</span><span class="w"> </span><span class="n">с</span><span class="w"> </span><span class="n">точки</span><span class="w"> </span><span class="n">зрения</span><span class="w"> </span><span class="n">вычислений</span><span class="p">,</span><span class="w"> </span><span class="n">поэтому</span><span class="w"> </span><span class="n">важно</span><span class="w"> </span><span class="n">использовать</span><span class="w"> </span><span class="n">приём</span><span class="w"> </span><span class="n">нормализации</span><span class="p">.</span><span class="w"> </span><span class="n">Обратите</span><span class="w"> </span><span class="n">внимание</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">если</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">умножим</span><span class="w"> </span><span class="n">числитель</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">знаменатель</span><span class="w"> </span><span class="n">дроби</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">константу</span><span class="w"> </span><span class="n">__C__</span><span class="w"> </span><span class="n">и</span><span class="w"> </span><span class="n">подставим</span><span class="w"> </span><span class="n">его</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">сумму</span><span class="p">,</span><span class="w"> </span><span class="n">получим</span><span class="w"> </span><span class="n">следующее</span><span class="w"> </span><span class="p">(</span><span class="n">математически</span><span class="w"> </span><span class="n">эквивалентное</span><span class="p">)</span><span class="w"> </span><span class="nl">выражение</span><span class="p">:</span><span class="w">  </span>

<span class="err">$$</span>
<span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}}}{\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}}</span>
<span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="n">Ce</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}}}{</span><span class="n">C</span><span class="err">\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="err">}}</span>
<span class="o">=</span><span class="w"> </span><span class="err">\</span><span class="n">frac</span><span class="err">{</span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_</span><span class="err">{</span><span class="n">y_i</span><span class="err">}</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">\</span><span class="nf">log</span><span class="w"> </span><span class="n">C</span><span class="err">}}{\</span><span class="n">sum_j</span><span class="w"> </span><span class="n">e</span><span class="o">^</span><span class="err">{</span><span class="n">f_j</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">\</span><span class="nf">log</span><span class="w"> </span><span class="n">C</span><span class="err">}}</span>
<span class="err">$$</span><span class="w">  </span>

<span class="n">Мы</span><span class="w"> </span><span class="n">вольны</span><span class="w"> </span><span class="n">выбирать</span><span class="w"> </span><span class="n">стоимость</span><span class="w"> </span><span class="n">__C__</span><span class="p">.</span><span class="w"> </span><span class="n">Это</span><span class="w"> </span><span class="n">не</span><span class="w"> </span><span class="n">повлияет</span><span class="w"> </span><span class="n">ни</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">один</span><span class="w"> </span><span class="n">из</span><span class="w"> </span><span class="n">результатов</span><span class="p">,</span><span class="w"> </span><span class="n">но</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">можем</span><span class="w"> </span><span class="n">использовать</span><span class="w"> </span><span class="n">это</span><span class="w"> </span><span class="n">значение</span><span class="w"> </span><span class="n">для</span><span class="w"> </span><span class="n">повышения</span><span class="w"> </span><span class="n">численной</span><span class="w"> </span><span class="n">стабильности</span><span class="w"> </span><span class="n">вычислений</span><span class="p">.</span><span class="w"> </span><span class="n">Обычно</span><span class="w"> </span><span class="n">выбирают</span><span class="w"> </span><span class="n">__C__</span><span class="w"> </span><span class="n">заключается</span><span class="w"> </span><span class="n">в</span><span class="w"> </span><span class="n">том</span><span class="p">,</span><span class="w"> </span><span class="n">чтобы</span><span class="w"> </span><span class="n">установить</span><span class="w"> </span><span class="n">__</span><span class="err">$\</span><span class="nf">log</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="err">\</span><span class="n">max_j</span><span class="w"> </span><span class="n">f_j</span><span class="w"> </span><span class="err">$</span><span class="n">__</span><span class="p">.</span><span class="w"> </span><span class="n">Это</span><span class="w"> </span><span class="n">просто</span><span class="w"> </span><span class="n">указывает</span><span class="w"> </span><span class="n">на</span><span class="w"> </span><span class="n">то</span><span class="p">,</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">мы</span><span class="w"> </span><span class="n">должны</span><span class="w"> </span><span class="n">сместить</span><span class="w"> </span><span class="n">значения</span><span class="w"> </span><span class="n">внутри</span><span class="w"> </span><span class="n">вектора</span><span class="w"> </span><span class="n">__f__</span><span class="w"> </span><span class="n">так</span><span class="w"> </span><span class="n">что</span><span class="w"> </span><span class="n">наибольшее</span><span class="w"> </span><span class="n">значение</span><span class="w"> </span><span class="n">равно</span><span class="w"> </span><span class="n">нулю</span><span class="p">.</span><span class="w"> </span><span class="n">В</span><span class="w"> </span><span class="nl">коде</span><span class="p">:</span><span class="w">  </span>


<span class="err">```</span><span class="n">py</span>
<span class="n">f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="k">array</span><span class="p">(</span><span class="o">[</span><span class="n">123, 456, 789</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">example</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">classes</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="k">having</span><span class="w"> </span><span class="k">large</span><span class="w"> </span><span class="n">scores</span>
<span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nl">Bad</span><span class="p">:</span><span class="w"> </span><span class="nc">Numeric</span><span class="w"> </span><span class="n">problem</span><span class="p">,</span><span class="w"> </span><span class="n">potential</span><span class="w"> </span><span class="n">blowup</span>

<span class="err">#</span><span class="w"> </span><span class="nl">instead</span><span class="p">:</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">shift</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">highest</span><span class="w"> </span><span class="n">number</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span>
<span class="n">f</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">max</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="o">[</span><span class="n">-666, -333, 0</span><span class="o">]</span>
<span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">f</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">exp</span><span class="p">(</span><span class="n">f</span><span class="p">))</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">safe</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">do</span><span class="p">,</span><span class="w"> </span><span class="n">gives</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">correct</span><span class="w"> </span><span class="n">answer</span>
</pre></div>

<p><strong>Возможно, сбивающие с толку соглашения об именовании</strong>. Чтобы быть точным, в классификаторе SVM используется потеря шарнира, или также иногда называемая <em>потерей максимальной маржи</em>. <em>Классификатор Softmax</em> использует <em>кросс-энтропийные</em> потери. Классификатор Softmax получил свое название от <em>функции softmax</em>, которая используется для преобразования необработанных оценок класса в нормализованные положительные значения, которые в сумме равны единице, чтобы можно было применить потери от перекрестной энтропии. В частности, обратите внимание, что технически не имеет смысла говорить о «потере при softmax», поскольку softmax — это просто функция сжатия, но это относительно часто используемое сокращение.  </p>
<h3>SVM против Softmax</h3>
<p>Изображение может помочь прояснить разницу между классификаторами Softmax и SVM:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/svmvssoftmax.png"></p>
<p>Пример разницы между классификаторами SVM и Softmax для одной точки данных. В обоих случаях мы вычисляем один и тот же вектор оценок <strong>f</strong> (например, путём умножения матриц в этом разделе). Разница заключается в интерпретации оценок в <strong>f</strong>: SVM интерпретирует их как оценки классов, и его функция потерь поощряет правильный класс (класс 2, выделен синим цветом) к получению более высокой оценки, чем у других классов. Вместо этого классификатор Softmax интерпретирует баллы как (ненормализованные) логарифмические вероятности для каждого класса, а затем стремится к тому, чтобы (нормализованная) логарифмическая вероятность правильного класса была высокой (эквивалентно, чтобы её отрицательная величина была низкой). Окончательное значение потерь для этого примера составляет 1,58 для SVM и 1,04 (обратите внимание, что это 1,04 с использованием натурального логарифма, а не логарифма по основанию 2 или 10) для классификатора Softmax, но обратите внимание, что эти числа несопоставимы. Они имеют смысл только в сравнении с потерями, рассчитанными для того же классификатора и с теми же данными.  </p>
<hr>
<p><strong>Классификатор Softmax предоставляет «вероятности» для каждого класса</strong>. В отличие от SVM, который вычисляет некалиброванные и трудно интерпретируемые оценки для всех классов, классификатор Softmax позволяет вычислять «вероятности» для всех меток. Например, для изображения классификатор SVM может выдать оценки [12,5, 0,6, -23,0] для классов «кошка», «собака» и «корабль». Вместо этого классификатор softmax может вычислить вероятности трёх меток как [0,9, 0,09, 0,01], что позволяет интерпретировать его уверенность в каждом классе. Однако мы взяли слово «вероятности» в кавычки, потому что то, насколько выраженными или размытыми будут эти вероятности, напрямую зависит от силы регуляризации <strong>λ</strong>, которые вы вводите в систему в качестве входных данных. Например, предположим, что ненормированные логарифмические вероятности для трёх классов равны [1, -2, 0]. Тогда функция softmax вычислит:  </p>
<p>$$
[1, -2, 0] \rightarrow [e^1, e^{-2}, e^0] = [2.71, 0.14, 1] \rightarrow [0.7, 0.04, 0.26]
$$  </p>
<p>Где шаги, предпринятые для возведения в степень и нормализации, суммируются до единицы. Теперь, если сила регуляризации <strong>λ</strong> был выше, вес <strong>W</strong> будет больше штрафоваться, и это приведёт к уменьшению весов. Например, предположим, что веса стали в два раза меньше ([0,5, -1, 0]). Теперь <em>softmax</em> будет вычислять:  </p>
<p>$$
[0.5, -1, 0] \rightarrow [e^{0.5}, e^{-1}, e^0] = [1.65, 0.37, 1] \rightarrow [0.55, 0.12, 0.33]
$$  </p>
<p>где вероятности теперь более размыты. Более того, в пределе, когда веса стремятся к малым значениям из-за очень сильной регуляризации __λ__Выходные вероятности были бы почти равномерными. Следовательно, вероятности, вычисляемые классификатором Softmax, лучше рассматривать как степени уверенности, где, как и в случае с SVM, порядок значений интерпретируется, но абсолютные значения (или их разница) технически не интерпретируются.  </p>
<p>На практике SVM и Softmax обычно сопоставимы по эффективности. Разница в производительности между SVM и Softmax обычно очень мала, и разные люди по-разному оценивают, какой классификатор работает лучше. По сравнению с классификатором Softmax, SVM является более <em>локальной</em> целью, что можно рассматривать как недостаток или преимущество. Рассмотрим пример, в котором достигаются баллы [10, -2, 3] и где первый класс является правильным. SVM (например, с желаемым запасом прочности <strong>Δ=1</strong>) увидит, что правильный класс уже имеет оценку выше, чем разница между классами, и вычислит нулевую потерю. SVM не обращает внимания на детали отдельных оценок: если бы они были [10, -100, -100] или [10, 9, 9], SVM было бы всё равно, так как разница в 1 соблюдена и, следовательно, потеря равна нулю. Однако эти сценарии не эквивалентны классификатору Softmax, который привёл бы к гораздо более высоким потерям для оценок [10, 9, 9], чем для [10, -100, -100]. Другими словами, классификатор Softmax никогда не будет полностью удовлетворён полученными оценками: правильный класс всегда может иметь более высокую вероятность, а неправильные классы — более низкую, и потери всегда будут уменьшаться. Однако SVM доволен, если соблюдены границы, и не контролирует точные оценки за пределами этого ограничения. Это можно интуитивно воспринимать как особенность: например, классификатор автомобилей, который, скорее всего, тратит большую часть своих «усилий» на решение сложной задачи по отделению автомобилей от грузовиков, не должен подвергаться влиянию примеров с лягушками, которым он уже присваивает очень низкие баллы и которые, скорее всего, группируются в совершенно другой части облака данных.  </p>
<h3>Интерактивная веб-демонстрация</h3>
<hr>
<p><img alt="" src="http://vision.stanford.edu/teaching/cs231n/linear-classify-demo"></p>
<p>Мы написали интерактивную веб-демонстрацию, чтобы помочь вашей интуиции в работе с линейными классификаторами. Демонстрация визуализирует функции потерь, обсуждаемые в этом разделе, с использованием игрушечной трехмерной классификации на 2D-данных. Демонстрационная версия также немного забегает вперед и выполняет оптимизацию, которую мы подробно обсудим в следующем разделе.  </p>
<hr>
<h3>Краткая сводка</h3>
<p>Подводя итог: 
- Мы определили <strong>функцию оценки</strong> от пикселей изображения к оценкам классов (в этом разделе — линейную функцию, которая зависит от весовых коэффициентов <strong>W</strong> и смещений <strong>b</strong>).
- В отличие от классификатора kNN, преимущество этого <strong>параметрического подхода</strong> заключается в том, что после определения параметров мы можем отказаться от обучающих данных. Кроме того, прогнозирование для нового тестового изображения выполняется быстро, поскольку требует лишь одного умножения матрицы на <strong>W</strong>, а не исчерпывающего сравнения с каждым отдельным обучающим примером.
- Мы ввели <strong>уловку со смещением</strong>, которая позволяет нам сложить вектор смещения в весовую матрицу для удобства, чтобы отслеживать только одну матрицу параметров.
- Мы определили <strong>функцию потерь</strong> (мы ввели две часто используемые функции потерь для линейных классификаторов: <strong>SVM</strong> и <strong>Softmax</strong>), которая измеряет, насколько заданный набор параметров соответствует истинным меткам в обучающем наборе данных. Мы также увидели, что функция потерь определена таким образом, что хорошие прогнозы на обучающих данных эквивалентны небольшим потерям.</p>
<p>Теперь мы увидели один из способов взять набор изображений и сопоставить каждое из них с баллами классов на основе набора параметров, а также увидели два примера функций потерь, которые можно использовать для оценки качества прогнозов. Но как эффективно определить параметры, которые дают наилучшие (наименьшие) потери? Этот процесс называется <strong>оптимизацией</strong>, и ему посвящён следующий раздел.  </p>
<h3>Дополнительные материалы</h3>
<p>Эти показания являются необязательными и содержат указания, представляющие интерес: 
- <a href="https://arxiv.org/abs/1306.0239">«Глубокое обучение с использованием линейных машин опорных векторов»</a> от Чарли Танга, 2013 г., представляет некоторые результаты, согласно которым L2SVM превосходит Softmax.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/numpy-tutorial/" class="u-url">Tutorial python Numpy</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/numpy-tutorial/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-02T19:42:16+03:00" itemprop="datePublished" title="2025-03-02 19:42">2025-03-02 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Tutorial python Numpy (с Jupyter и Colab)</h2>
<p><a href="https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/python-colab.ipynb">Блокнот Colab</a></p>
<p>Этот урок был первоначально предоставлен <a href="http://cs.stanford.edu/people/jcjohns/">Джастином Джонсоном</a>.  </p>
<p>Мы будем использовать язык программирования <em>python</em> для всех заданий этого курса. <em>python</em> сам по себе является отличным языком программирования общего назначения, но с С помощью нескольких популярных библиотек (<em>numpy</em>, <em>scipy</em>, <em>matplotlib</em>) он становится мощным среда для научных вычислений.</p>
<p>Мы ожидаем, что многие из вас будут иметь некоторый опыт работы с <em>python</em> и <em>numpy</em>; Для остальных из вас этот раздел послужит кратким ускоренным курсом по обоим направлениям язык программирования <em>python</em> и его использование для научных исследований вычисление. Мы также познакомим вас с блокнотами, которые являются очень удобным способом возни с кодом на <em>python</em>. Некоторые из вас, возможно, уже знакомы с другой язык, и в этом случае мы также рекомендуем ссылаться <a href="https://numpy.org/doc/stable/user/numpy-for-matlab-users.html">на NumPy для пользователей Matlab</a>, <a href="http://www.data-analysis-in-python.org/python_for_r.html">python для пользователей R</a> и/или <a href="https://nbviewer.jupyter.org/github/RandyBetancourt/pythonForSASUsers/tree/master/">python для пользователей SAS</a>.  </p>
<p>Содержание
- <a href="posts/numpy-tutorial/">Блокноты Jupyter и Colab</a>
- <a href="posts/numpy-tutorial/">Питон</a>
    - <a href="posts/numpy-tutorial/">Версии python</a>
    - <a href="posts/numpy-tutorial/">Основные типы данных</a>
    - <a href="posts/numpy-tutorial/">Контейнеры</a>
        - <a href="posts/numpy-tutorial/">Списках</a>
        - <a href="posts/numpy-tutorial/">Словари</a>
        - <a href="posts/numpy-tutorial/">Множество</a>
        - <a href="posts/numpy-tutorial/">Кортежи</a>
    - <a href="posts/numpy-tutorial/">Функции</a>
    - <a href="posts/numpy-tutorial/">Классы</a>
- <a href="posts/numpy-tutorial/">Numpy</a>
    - <a href="posts/numpy-tutorial/">Массивы</a>
    - <a href="posts/numpy-tutorial/">Индексация массивов</a>
    - <a href="posts/numpy-tutorial/">Типы данных</a>
    - <a href="posts/numpy-tutorial/">Математические операции с массивами</a>
    - <a href="posts/numpy-tutorial/">Вещание</a>
    - <a href="posts/numpy-tutorial/">Документация Numpy</a>
- <a href="posts/numpy-tutorial/">SciPy</a>
    - <a href="posts/numpy-tutorial/">Операции с изображениями</a>
    - <a href="posts/numpy-tutorial/">Файлы MATLAB</a>
    - <a href="posts/numpy-tutorial/">Расстояние между точками</a>
- <a href="posts/numpy-tutorial/">Matplotlib</a>
    - <a href="posts/numpy-tutorial/">Постоение кривой</a>
    - <a href="posts/numpy-tutorial/">Побочные сюжеты</a>
    - <a href="posts/numpy-tutorial/">Изображения</a>  </p>
<h2>Блокноты Jupyter и Colab</h2>
<p>Прежде чем мы углубимся в python, мы хотели бы кратко поговорить о <em>блокнотах</em>. Записная книжка Jupyter позволяет писать и выполнять Код python <em>локально</em> в вашем веб-браузере. <em>Jupyter notebooks</em>: yпростите работу с кодом и выполняйте его битами и кусочки; По этой причине они широко используются в научных вычисление. <em>Colab</em>, с другой стороны, является разновидностью <em>Google</em> Блокноты <em>Jupyter</em>, которые особенно подходят для машинных машин обучение и анализ данных, и это полностью работает в <em>облаке</em>. <em>Colab</em> — это, по сути, <em>Jupyter</em> notebook на стероидах: он бесплатный, не требует настройки, Поставляется с предустановленными пакетами, его легко поделиться со всем миром, и преимущества бесплатного доступа к аппаратным ускорителям, таким как графические процессоры и <em>TPU</em> (с некоторыми оговорками).  </p>
<p><strong>Запустите Tutorial в Colab (рекомендуется)</strong>. Если вы хотите выполнить это руководство полностью в <em>Colab</em>, нажмите на значок в самом верху этой страницы.<code>Open in Colab</code></p>
<p><strong>Запустите Tutorial в записной книжке Jupyter</strong>. Если вы хотите запустить записную книжку локально с помощью <em>Jupyter</em>, убедитесь, что ваша виртуальная среда установлена правильно (в соответствии с <a href="https://cs231n.github.io/setup-instructions/">инструкциями по настройке</a>), активируйте ее, а затем запустите для установки записной книжки Jupyter. Затем <a href="https://raw.githubusercontent.com/cs231n/cs231n.github.io/master/jupyter-notebook-tutorial.ipynb">откройте блокнот</a> и загрузите его в каталог по вашему выбору, щелкнув правой кнопкой мыши по странице и выбрав . Затем в этот каталог и запустите .<code>pip install notebook</code> <code>Save Page As</code> <code>cd</code> <code>jupyter notebook</code>  </p>
<p><img alt="" src="https://cs231n.github.io/assets/ipython-tutorial/file-browser.png"></p>
<p>Это должно автоматически запустить сервер записных книжек в положении . Если все работало правильно, вы должны увидеть такой экран, показывающий все Доступные записные книжки в текущем каталоге. Нажмите и следуйте инструкциям в записной книжке. В противном случае вы можете продолжить чтение Туториал с фрагментами кода ниже.<code>http://localhost:8888</code> <code>jupyter-notebook-tutorial.ipynb</code>  </p>
<h2>python</h2>
<p><strong>python</strong> — это высокоуровневый, динамически типизированный мультипарадигмальный язык программирования. О коде на <em>python</em> часто говорят, что он похож на псевдокод, поскольку он позволяет вам выражать очень мощные идеи в очень немногих строках кода, оставаясь при этом очень удобочитаемый. В качестве примера приведем реализацию алгоритма классической быстрой сортировки на <em>python</em>:  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">quicksort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="c1"># Prints "[1, 1, 2, 3, 6, 8, 10]"</span>
</pre></div>

<h3>Версии python</h3>
<p>С 1 января 2020 года python <a href="https://www.python.org/doc/sunset-python-2/">официально прекратил поддержку</a> второй версии. 
<strong>Для современных приложений должен использоваться python &gt;= 3.9</strong>. 
Убедитесь, что вы правильно установили виртуальную среду, прежде чем продолжить работу с этим руководством. 
Вы можете проверить свою версию в командной строке после активации среды запустив команду: <code>python --version</code>  </p>
<h3>Основные типы данных</h3>
<p>Как и большинство языков, <em>python</em> имеет ряд основных типов: <em>int</em>, <em>floats</em>, <em>booleans</em> и <em>strings</em>. 
Эти типы данных ведут себя так же, как и в большинстве других языков программирования.  </p>
<p><strong>Числа</strong>:  </p>
<div class="code"><pre class="code literal-block"><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'int'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># Prints "3"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Addition; prints "4"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Subtraction; prints "2"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Multiplication; prints "6"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Exponentiation; prints "9"</span>
<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints "4"</span>
<span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints "8"</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'float'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Prints "2.5 3.5 5.0 6.25"</span>
</pre></div>

<p>Обратите внимание, что в отличие от многих языков, в python нет унарного инкремента (<code>x++</code>) или decrement (<code>x--</code>).   </p>
<p><em>python</em> также имеет встроенные типы для комплексных чисел; 
Все подробности можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#numeric-types-int-float-complex">в документации</a>.</p>
<p><strong>Булевы</strong>: <em>python</em> реализует все обычные операторы для булевой логики, но использует английские слова, а не символы (<code>&amp;&amp;</code>, <code>||</code> , и т. д.):   </p>
<div class="code"><pre class="code literal-block"><span class="n">t</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">f</span> <span class="o">=</span> <span class="kc">False</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'bool'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="ow">and</span> <span class="n">f</span><span class="p">)</span> <span class="c1"># Logical AND; prints "False"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="ow">or</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Logical OR; prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="n">t</span><span class="p">)</span>   <span class="c1"># Logical NOT; prints "False"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Logical XOR; prints "True"</span>
</pre></div>

<p><strong>Строки</strong>: <em>python</em> имеет отличную поддержку строк:  </p>
<div class="code"><pre class="code literal-block"><span class="n">hello</span> <span class="o">=</span> <span class="s1">'hello'</span>    <span class="c1"># String literals can use single quotes</span>
<span class="n">world</span> <span class="o">=</span> <span class="s2">"world"</span>    <span class="c1"># or double quotes; it does not matter.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>       <span class="c1"># Prints "hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hello</span><span class="p">))</span>  <span class="c1"># String length; prints "5"</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">hello</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="n">world</span>  <span class="c1"># String concatenation</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span>  <span class="c1"># prints "hello world"</span>
<span class="n">hw12</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>  <span class="c1"># sprintf style string formatting</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hw12</span><span class="p">)</span>  <span class="c1"># prints "hello world 12"  </span>
</pre></div>

<p>Строковые объекты имеют множество полезных методов:  </p>
<div class="code"><pre class="code literal-block"><span class="n">s</span> <span class="o">=</span> <span class="s2">"hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>  <span class="c1"># Capitalize a string; prints "Hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>       <span class="c1"># Convert a string to uppercase; prints "HELLO"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>      <span class="c1"># Right-justify a string, padding with spaces; prints "  hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>     <span class="c1"># Center a string, padding with spaces; prints " hello "</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="s1">'(ell)'</span><span class="p">))</span>  <span class="c1"># Replace all instances of one substring with another;</span>
                                <span class="c1"># prints "he(ell)(ell)o"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'  world '</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>  <span class="c1"># Strip leading and trailing whitespace; prints "world"</span>
</pre></div>

<p>Список всех строковых методов можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#string-methods">в документации</a>.</p>
<h3>Контейнеры</h3>
<p>python включает в себя несколько встроенных типов контейнеров: списки, словари, наборы и кортежи.</p>
<h3>Списки</h3>
<p>Список является эквивалентом массива в <em>python</em>, но его размер можно изменять и может содержать элементы разных типов:  </p>
<div class="code"><pre class="code literal-block"><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>    <span class="c1"># Create a list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># Prints "[3, 1, 2] 2"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># Negative indices count from the end of the list; prints "2"</span>
<span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'foo'</span>     <span class="c1"># Lists can contain elements of different types</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>         <span class="c1"># Prints "[3, 1, 'foo']"</span>
<span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>  <span class="c1"># Add a new element to the end of the list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>         <span class="c1"># Prints "[3, 1, 'foo', 'bar']"</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>      <span class="c1"># Remove and return the last element of the list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>      <span class="c1"># Prints "bar [3, 1, 'foo']"  </span>
</pre></div>

<p>Как обычно, вы можете найти подробности о <a href="https://docs.python.org/3.9/tutorial/datastructures.html#more-on-lists">списках в документации</a>.  </p>
<p><strong>Разрезание на ломтики</strong>: В дополнение к доступу к элементам списка по одному, <em>python</em> предоставляет лаконичный синтаксис для доступа к подспискам; Это называется нарезкой:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>     <span class="c1"># range is a built-in function that creates a list of integers</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>               <span class="c1"># Prints "[0, 1, 2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>          <span class="c1"># Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>           <span class="c1"># Get a slice from index 2 to the end; prints "[2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>           <span class="c1"># Get a slice from the start to index 2 (exclusive); prints "[0, 1]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:])</span>            <span class="c1"># Get a slice of the whole list; prints "[0, 1, 2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>          <span class="c1"># Slice indices can be negative; prints "[0, 1, 2, 3]"</span>
<span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>        <span class="c1"># Assign a new sublist to a slice</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>               <span class="c1"># Prints "[0, 1, 8, 9, 4]" </span>
</pre></div>

<p>Мы снова увидим нарезку в контексте массивов numpy.  </p>
<p><strong>Петли</strong>: Вы можете перебирать элементы списка следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
<span class="c1"># Prints "cat", "dog", "monkey", each on its own line.</span>
</pre></div>

<p>Если вы хотите получить доступ к индексу каждого элемента в теле цикла, Воспользуйтесь встроенной функцией:<code>enumerate</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">animal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">animals</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'#</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">animal</span><span class="p">))</span>
<span class="c1"># Prints "#1: cat", "#2: dog", "#3: monkey", each on its own line  </span>
</pre></div>

<p><strong>Список включений</strong>: При программировании мы часто хотим преобразовать один тип данных в другой. В качестве простого примера рассмотрим следующий код, который вычисляет квадратные числа:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># Prints [0, 1, 4, 9, 16]</span>
</pre></div>

<p>Вы можете упростить этот код с помощью <strong>спискового понимания</strong>:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># Prints [0, 1, 4, 9, 16]</span>
</pre></div>

<p>Включения списка также могут содержать условия:    </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">even_squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">even_squares</span><span class="p">)</span>  <span class="c1"># Prints "[0, 4, 16]"</span>
</pre></div>

<h4>Словари</h4>
<p>Словарь хранит пары (ключ, значение), аналогично?, a в <strong>i</strong> или объект в <em>Javascript</em>. Вы можете использовать его следующим образом:<code>Map</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">:</span> <span class="s1">'cute'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">:</span> <span class="s1">'furry'</span><span class="p">}</span>  <span class="c1"># Create a new dictionary with some data</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'cat'</span><span class="p">])</span>       <span class="c1"># Get an entry from a dictionary; prints "cute"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'cat'</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>     <span class="c1"># Check if a dictionary has a given key; prints "True"</span>
<span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'wet'</span>     <span class="c1"># Set an entry in a dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">])</span>      <span class="c1"># Prints "wet"</span>
<span class="c1"># print(d['monkey'])  # KeyError: 'monkey' not a key of d</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'monkey'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span>  <span class="c1"># Get an element with a default; prints "N/A"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span>    <span class="c1"># Get an element with a default; prints "wet"</span>
<span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">]</span>         <span class="c1"># Remove an element from a dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span> <span class="c1"># "fish" is no longer a key; prints "N/A"</span>
</pre></div>

<p>Все, что вам нужно знать о словарях, вы можете найти <a href="https://docs.python.org/3.9/library/stdtypes.html#dict">в документации</a>.  </p>
<p><strong>Петли</strong>: Перебирать ключи в словаре очень просто:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'person'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'spider'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">animal</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'A </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> legs'</span> <span class="o">%</span> <span class="p">(</span><span class="n">animal</span><span class="p">,</span> <span class="n">legs</span><span class="p">))</span>
<span class="c1"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs" </span>
</pre></div>

<p>Если вы хотите получить доступ к ключам и их соответствующим значениям, используйте метод:<code>items</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'person'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'spider'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="k">for</span> <span class="n">animal</span><span class="p">,</span> <span class="n">legs</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'A </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> legs'</span> <span class="o">%</span> <span class="p">(</span><span class="n">animal</span><span class="p">,</span> <span class="n">legs</span><span class="p">))</span>
<span class="c1"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs"</span>
</pre></div>

<p><strong>Словарное понимание</strong>: Они похожи на включения списков, но позволяют легко создавать Словари. Например:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">even_num_to_square</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">even_num_to_square</span><span class="p">)</span>  <span class="c1"># Prints "{0: 0, 2: 4, 4: 16}"</span>
</pre></div>

<h4>Множество</h4>
<p>Множество — это неупорядоченный набор отдельных элементов. В качестве простого примера рассмотрим следующее:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'cat'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>   <span class="c1"># Check if an element is in a set; prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'fish'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>  <span class="c1"># prints "False"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">)</span>       <span class="c1"># Add an element to a set</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'fish'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>  <span class="c1"># Prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Number of elements in a set; prints "3"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)</span>        <span class="c1"># Adding an element that is already in the set does nothing</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Prints "3"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)</span>     <span class="c1"># Remove an element from a set</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Prints "2"</span>
</pre></div>

<p>Как обычно, все, что вы хотите знать о множествах, можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#set">в документации</a>.  </p>
<p><strong>Петли</strong>: Перебор набора имеет тот же синтаксис, что и перебор списка; 
Однако, поскольку наборы не упорядочены, вы не можете делать предположения о порядке, в которых вы посещаете элементы набора:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'fish'</span><span class="p">}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">animal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">animals</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'#</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">animal</span><span class="p">))</span>
<span class="c1"># Prints "#1: fish", "#2: dog", "#3: cat"  </span>
</pre></div>

<p><strong>Набор понятий</strong>: Подобно спискам и словарям, мы можем легко создавать множества, используя включения множеств:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># Prints "{0, 1, 2, 3, 4, 5}"</span>
</pre></div>

<h4>Кортежи</h4>
<p>Кортеж — это (<em>неизменяемый</em>) упорядоченный список значений. Кортеж во многом похож на список; Одним из наиболее важных отличий является то, что Кортежи можно использовать как ключи в словарях и как элементы множеств, а списки — нет. Вот банальный пример:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>  <span class="c1"># Create a dictionary with tuple keys</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>        <span class="c1"># Create a tuple</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>    <span class="c1"># Prints "&lt;class 'tuple'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>       <span class="c1"># Prints "5"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># Prints "1"</span>
</pre></div>

<p><a href="https://docs.python.org/3.9/tutorial/datastructures.html#tuples-and-sequences">В документации</a> есть больше информации о кортежах.  </p>
<h3>Функции</h3>
<p>Функции python определяются с помощью ключевого слова. Например:<code>def</code>  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'positive'</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'negative'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'zero'</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># Prints "negative", "zero", "positive"</span>
</pre></div>

<p>Мы часто определяем функции, принимающие необязательные аргументы ключевых слов, например:  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">loud</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'HELLO, </span><span class="si">%s</span><span class="s1">!'</span> <span class="o">%</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Hello, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="n">hello</span><span class="p">(</span><span class="s1">'Bob'</span><span class="p">)</span> <span class="c1"># Prints "Hello, Bob"</span>
<span class="n">hello</span><span class="p">(</span><span class="s1">'Fred'</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Prints "HELLO, FRED!" </span>
</pre></div>

<p>В <a href="https://docs.python.org/3.9/tutorial/controlflow.html#defining-functions">документации</a> есть гораздо больше информации о функциях <em>python</em>.  </p>
<h4>Классы</h4>
<p>Синтаксис для определения классов в <em>python</em> прост:  </p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Greeter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># Constructor</span>
    <span class="k">def</span><span class="w"> </span><span class="o">**</span><span class="n">init</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># Create an instance variable</span>

    <span class="c1"># Instance method</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loud</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'HELLO, </span><span class="si">%s</span><span class="s1">!'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'Hello, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">Greeter</span><span class="p">(</span><span class="s1">'Fred'</span><span class="p">)</span>  <span class="c1"># Construct an instance of the Greeter class</span>
<span class="n">g</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>            <span class="c1"># Call an instance method; prints "Hello, Fred"</span>
<span class="n">g</span><span class="o">.</span><span class="n">greet</span><span class="p">(</span><span class="n">loud</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   <span class="c1"># Call an instance method; prints "HELLO, FRED!"</span>
</pre></div>

<p>Вы можете прочитать гораздо больше о классах <em>python</em> <a href="https://docs.python.org/3.9/tutorial/classes.html">в документации</a>.  </p>
<h2>Numpy</h2>
<p><a href="http://www.numpy.org/">Numpy</a> — это основная библиотека для научных вычислений на языке <em>python</em>. Он предоставляет высокопроизводительный многомерный массив объектов и инструменты для работы с ними Массивы. Если вы уже знакомы с <em>MATLAB</em>, <a href="https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users.html">то этот урок может быть вам полезен</a> для начала работы с <em>Numpy</em>.  </p>
<h3>Массивы</h3>
<p>Массив numpy представляет собой сетку значений одного и того же типа, индексируемую кортежем неотрицательные целые числа. Количество измерений — это ранг массива; Форма массива представляет собой кортеж целых чисел, задающий размер массива вдоль каждого измерения.  </p>
<p>Мы можем инициализировать массивы numpy из вложенных списков <em>python</em>, и получить доступ к элементам с помощью квадратных скобок:  </p>
<div class="code"><pre class="code literal-block"> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>   <span class="c1"># Create a rank 1 array</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>            <span class="c1"># Prints "&lt;class 'numpy.ndarray'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>            <span class="c1"># Prints "(3,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>   <span class="c1"># Prints "1 2 3"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>                  <span class="c1"># Change an element of the array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                  <span class="c1"># Prints "[5, 2, 3]"</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>    <span class="c1"># Create a rank 2 array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                     <span class="c1"># Prints "(2, 3)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>   <span class="c1"># Prints "1 2 4"  </span>
</pre></div>

<p><em>Numpy</em> также предоставляет множество функций для создания массивов:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>   <span class="c1"># Create an array of all zeros</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>              <span class="c1"># Prints "[[ 0.  0.]</span>
                      <span class="c1">#          [ 0.  0.]]"</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>    <span class="c1"># Create an array of all ones</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>              <span class="c1"># Prints "[[ 1.  1.]]"</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>  <span class="c1"># Create a constant array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>               <span class="c1"># Prints "[[ 7.  7.]</span>
                       <span class="c1">#          [ 7.  7.]]"</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1"># Create a 2x2 identity matrix</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>              <span class="c1"># Prints "[[ 1.  0.]</span>
                      <span class="c1">#          [ 0.  1.]]"</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Create an array filled with random values</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>                     <span class="c1"># Might print "[[ 0.91940167  0.08143941]</span>
                             <span class="c1">#               [ 0.68744134  0.87236687]]"</span>
</pre></div>

<p><strong>О других способах создания массивов вы можете прочитать</strong> <a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation">в документации</a>.</p>
<h3>Индексация массивов</h3>
<p><em>Numpy</em> предлагает несколько способов индексации в массивы.  </p>
<p><strong>Разрезание на ломтики</strong>: Как и в случае со списками <em>python</em>, массивы numpy могут быть разделены на срезы. Поскольку массивы могут быть многомерными, необходимо указать срез для каждого измерения массива:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create the following rank 2 array with shape (3, 4)</span>
<span class="c1"># [[ 1  2  3  4]</span>
<span class="c1">#  [ 5  6  7  8]</span>
<span class="c1">#  [ 9 10 11 12]]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>

<span class="c1"># Use slicing to pull out the subarray consisting of the first 2 rows</span>
<span class="c1"># and columns 1 and 2; b is the following array of shape (2, 2):</span>
<span class="c1"># [[2 3]</span>
<span class="c1">#  [6 7]]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

<span class="c1"># A slice of an array is a view into the same data, so modifying it</span>
<span class="c1"># will modify the original array.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># Prints "2"</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">77</span>     <span class="c1"># b[0, 0] is the same piece of data as a[0, 1]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># Prints "77"</span>
</pre></div>

<p>Вы также можете сочетать целочисленное индексирование с индексированием срезов. Однако это приведет к получению массива более низкого ранга, чем исходный массив. Обратите внимание, что это сильно отличается от способа, которым <em>MATLAB</em> работает с массивами разрезание на ломтики:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create the following rank 2 array with shape (3, 4)</span>
<span class="c1"># [[ 1  2  3  4]</span>
<span class="c1">#  [ 5  6  7  8]</span>
<span class="c1">#  [ 9 10 11 12]]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>

<span class="c1"># Two ways of accessing the data in the middle row of the array.</span>
<span class="c1"># Mixing integer indexing with slices yields an array of lower rank,</span>
<span class="c1"># while using only slices yields an array of the same rank as the</span>
<span class="c1"># original array:</span>
<span class="n">row_r1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>    <span class="c1"># Rank 1 view of the second row of a</span>
<span class="n">row_r2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># Rank 2 view of the second row of a</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_r1</span><span class="p">,</span> <span class="n">row_r1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[5 6 7 8] (4,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_r2</span><span class="p">,</span> <span class="n">row_r2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[[5 6 7 8]] (1, 4)"</span>

<span class="c1"># We can make the same distinction when accessing columns of an array:</span>
<span class="n">col_r1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">col_r2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">col_r1</span><span class="p">,</span> <span class="n">col_r1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[ 2  6 10] (3,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">col_r2</span><span class="p">,</span> <span class="n">col_r2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2]</span>
                             <span class="c1">#          [ 6]</span>
                             <span class="c1">#          [10]] (3, 1)"</span>
</pre></div>

<p><strong>Индексация целочисленного массива</strong>: Когда вы индексируете массивы numpy с помощью слайсинга, результирующее представление массива всегда будет подмассивом исходного массива. В противоположность этому, целочисленный массив Индексация позволяет создавать произвольные массивы, используя данные из другого массив. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="c1"># An example of integer array indexing.</span>
<span class="c1"># The returned array will have shape (3,) and</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># Prints "[1 4 5]"</span>

<span class="c1"># The above example of integer array indexing is equivalent to this:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>  <span class="c1"># Prints "[1 4 5]"</span>

<span class="c1"># When using integer array indexing, you can reuse the same</span>
<span class="c1"># element from the source array:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Prints "[2 2]"</span>

<span class="c1"># Equivalent to the previous integer array indexing example</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>  <span class="c1"># Prints "[2 2]"</span>
</pre></div>

<p>Одним из полезных приемов при индексации целочисленных массивов является выбор или изменение одного из них из каждой строки матрицы:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create a new array from which we will select elements</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># prints "array([[ 1,  2,  3],</span>
          <span class="c1">#                [ 4,  5,  6],</span>
          <span class="c1">#                [ 7,  8,  9],</span>
          <span class="c1">#                [10, 11, 12]])"</span>

<span class="c1"># Create an array of indices</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># Select one element from each row of a using the indices in b</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">])</span>  <span class="c1"># Prints "[ 1  6  7 11]"</span>

<span class="c1"># Mutate one element from each row of a using the indices in b</span>
<span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># prints "array([[11,  2,  3],</span>
          <span class="c1">#                [ 4,  5, 16],</span>
          <span class="c1">#                [17,  8,  9],</span>
          <span class="c1">#                [10, 21, 12]])</span>
</pre></div>

<p><strong>Индексация логических массивов</strong>: Логическое индексирование массива позволяет выделять произвольные элементы массива. Часто этот тип индексации используется для выбора элементов массива которые удовлетворяют какому-либо условию. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="n">bool_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Find the elements of a that are bigger than 2;</span>
                     <span class="c1"># this returns a numpy array of Booleans of the same</span>
                     <span class="c1"># shape as a, where each slot of bool_idx tells</span>
                     <span class="c1"># whether that element of a is &gt; 2.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">bool_idx</span><span class="p">)</span>      <span class="c1"># Prints "[[False False]</span>
                     <span class="c1">#          [ True  True]</span>
                     <span class="c1">#          [ True  True]]"</span>

<span class="c1"># We use boolean array indexing to construct a rank 1 array</span>
<span class="c1"># consisting of the elements of a corresponding to the True values</span>
<span class="c1"># of bool_idx</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">bool_idx</span><span class="p">])</span>  <span class="c1"># Prints "[3 4 5 6]"</span>

<span class="c1"># We can do all of the above in a single concise statement:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>     <span class="c1"># Prints "[3 4 5 6]"</span>
</pre></div>

<p>Для краткости мы опустили много подробностей об индексации массива numpy; Если вы хотите узнать больше, вам следует <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html">прочитать документацию</a>.  </p>
<h3>Типы данных</h3>
<p>Каждый массив numpy представляет собой сетку элементов одного типа. <em>Numpy</em> предоставляет большой набор числовых типов данных, которые можно использовать для создания массивов. <em>Numpy</em> пытается угадать тип данных при создании массива, но функции, которые конструируют. Массивы обычно также включают необязательный аргумент для явного указания типа данных. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>   <span class="c1"># Let numpy choose the datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>         <span class="c1"># Prints "int64"</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>   <span class="c1"># Let numpy choose the datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>             <span class="c1"># Prints "float64"</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>   <span class="c1"># Force a particular datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>                         <span class="c1"># Prints "int64"</span>
</pre></div>

<p>Вы можете прочитать все о типах данных <em>numpy</em> <a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html">в документации</a>.</p>
<h3>Математические операции с массивами</h3>
<p>Основные математические функции работают с массивами поэлементно и доступны как в виде перегрузок операторов, так и в виде функций в модуле numpy:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="c1"># Elementwise sum; both produce the array</span>
<span class="c1"># [[ 6.0  8.0]</span>
<span class="c1">#  [10.0 12.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise difference; both produce the array</span>
<span class="c1"># [[-4.0 -4.0]</span>
<span class="c1">#  [-4.0 -4.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise product; both produce the array</span>
<span class="c1"># [[ 5.0 12.0]</span>
<span class="c1">#  [21.0 32.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise division; both produce the array</span>
<span class="c1"># [[ 0.2         0.33333333]</span>
<span class="c1">#  [ 0.42857143  0.5       ]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise square root; produces the array</span>
<span class="c1"># [[ 1.          1.41421356]</span>
<span class="c1">#  [ 1.73205081  2.        ]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>Обратите внимание, что в отличие от <em>MATLAB</em>, это поэлементное умножение, а не матрица умножение. Вместо этого мы используем функцию для вычисления inner произведения векторов, умножить вектор на матрицу, и умножать матрицы. доступен как функция в numpy и в качестве экземпляра метода объектов массива:<code>*</code> <code>dot</code> <code>dot</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="c1"># Inner product of vectors; both produce 219</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

<span class="c1"># Matrix / vector product; both produce the rank 1 array [29 67]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="c1"># Matrix / matrix product; both produce the rank 2 array</span>
<span class="c1"># [[19 22]</span>
<span class="c1">#  [43 50]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>

<p><em>Numpy</em> предоставляет множество полезных функций для выполнения вычислений на Массивы; Одним из самых полезных является:<code>sum</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># Compute sum of all elements; prints "10"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># Compute sum of each column; prints "[4 6]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Compute sum of each row; prints "[3 7]"</span>
</pre></div>

<p>Полный список математических функций, предоставляемых numpy, вы можете найти <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">в документации</a>.</p>
<p>Помимо вычисления математических функций с помощью массивов, мы часто должны изменять форму данных в массивах или иным образом манипулировать ими. Самый простой пример. Одним из таких видов операции является транспонирование матрицы; для транспонирования матрицы, Просто используйте атрибут объекта массива:<code>T</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1"># Prints "[[1 2]</span>
            <span class="c1">#          [3 4]]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Prints "[[1 3]</span>
            <span class="c1">#          [2 4]]"</span>

<span class="c1"># Note that taking the transpose of a rank 1 array does nothing:</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>    <span class="c1"># Prints "[1 2 3]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Prints "[1 2 3]"</span>
</pre></div>

<p><em>Numpy</em> предоставляет гораздо больше функций для работы с массивами; С полным списком можно ознакомиться <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">в документации</a>.</p>
<h3>Вещание</h3>
<p><strong>Вещание</strong> - это мощный механизм, который позволяет numpy работать с массивами различных фигур при выполнении арифметических действий. Часто у нас есть меньший массив и больший массив, и мы хотим использовать меньший массив несколько раз для выполнения какой-либо операции на более крупном массиве.  </p>
<p>Например, предположим, что мы хотим добавить вектор константы к каждому строки матрицы. Мы могли бы сделать это следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># Create an empty matrix with the same shape as x</span>

<span class="c1"># Add the vector v to each row of the matrix x with an explicit loop</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">v</span>

<span class="c1"># Now y is the following</span>
<span class="c1"># [[ 2  2  4]</span>
<span class="c1">#  [ 5  5  7]</span>
<span class="c1">#  [ 8  8 10]</span>
<span class="c1">#  [11 11 13]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> 
</pre></div>

<p>Это работает, однако, когда матрица очень большая, вычисление явного цикла в <em>python</em> может быть медленным. Обратите внимание, что добавление вектора к каждой строке матрицы эквивалентно формированию матрицы путем наложения нескольких копий по вертикали, затем выполнение поэлементного суммирования и мы могли бы это реализовать. Подход таков:<code>x</code> <code>v</code> <code>x</code> <code>vv</code> <code>v</code> <code>x</code> <code>vv</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1"># Stack 4 copies of v on top of each other</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>                 <span class="c1"># Prints "[[1 0 1]</span>
                          <span class="c1">#          [1 0 1]</span>
                          <span class="c1">#          [1 0 1]</span>
                          <span class="c1">#          [1 0 1]]"</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">vv</span>  <span class="c1"># Add x and vv elementwise</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2  2  4</span>
          <span class="c1">#          [ 5  5  7]</span>
          <span class="c1">#          [ 8  8 10]</span>
          <span class="c1">#          [11 11 13]]"</span>
</pre></div>

<p>Числовое вещание позволяет нам выполнять эти вычисления без фактического Создание нескольких копий домена . Рассмотрим такой вариант, используя трансляцию:<code>v</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span>  <span class="c1"># Add v to each row of x using broadcasting</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2  2  4]</span>
          <span class="c1">#          [ 5  5  7]</span>
          <span class="c1">#          [ 8  8 10]</span>
          <span class="c1">#          [11 11 13]]"</span>
</pre></div>

<p>Линия работает, несмотря на то, что имеет форму и имеет форму благодаря вещанию; Эта линия работает так, как будто на самом деле имеет форму, где каждая строка была копией , а сумма выполнялась по элементам.<code>y = x + v</code> <code>x(4, 3)</code> <code>v(3,)</code> <code>v(4, 3)</code> <code>v</code>  </p>
<p>Трансляция двух массивов одновременно выполняется по следующим правилам:
1. Если массивы имеют разный ранг, добавьте в начало форму массива с меньшим рангом с <strong>1s</strong> до тех пор, пока обе фигуры не будут иметь одинаковую длину.
2. Два массива считаются <em>совместимыми</em> в размерности, если они имеют одинаковое значение size в измерении, или если один из массивов имеет размер <strong>1</strong> в этом измерении.
3. Массивы могут транслироваться вместе, если они совместимы во всех измерениях.
4. После трансляции каждый массив ведет себя так, как если бы он имел форму, равную поэлементной максимальное количество форм двух входных массивов.
5. В любом измерении, где один массив имеет размер <strong>1</strong>, а другой массив больше <strong>1</strong>, Первый массив ведет себя так, как если бы он был скопирован по этому размеру  </p>
<p>Если это объяснение не имеет смысла, попробуйте прочитать объяснение <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">из документации</a> или <a href="https://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">это объяснение</a>.  </p>
<p>Функции, поддерживающие широковещательную рассылку, называются <em>универсальными функциями</em>. Вы можете найти Список всех универсальных функций <a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">в документации</a>.  </p>
<p>Вот некоторые области применения вещания:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Compute outer product of vectors</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># v has shape (3,)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>    <span class="c1"># w has shape (2,)</span>
<span class="c1"># To compute an outer product, we first reshape v to be a column</span>
<span class="c1"># vector of shape (3, 1); we can then broadcast it against w to yield</span>
<span class="c1"># an output of shape (3, 2), which is the outer product of v and w:</span>
<span class="c1"># [[ 4  5]</span>
<span class="c1">#  [ 8 10]</span>
<span class="c1">#  [12 15]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>

<span class="c1"># Add a vector to each row of a matrix</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="c1"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span>
<span class="c1"># giving the following matrix:</span>
<span class="c1"># [[2 4 6]</span>
<span class="c1">#  [5 7 9]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

<span class="c1"># Add a vector to each column of a matrix</span>
<span class="c1"># x has shape (2, 3) and w has shape (2,).</span>
<span class="c1"># If we transpose x then it has shape (3, 2) and can be broadcast</span>
<span class="c1"># against w to yield a result of shape (3, 2); transposing this result</span>
<span class="c1"># yields the final result of shape (2, 3) which is the matrix x with</span>
<span class="c1"># the vector w added to each column. Gives the following matrix:</span>
<span class="c1"># [[ 5  6  7]</span>
<span class="c1">#  [ 9 10 11]]</span>
<span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="c1"># Another solution is to reshape w to be a column vector of shape (2, 1);</span>
<span class="c1"># we can then broadcast it directly against x to produce the same</span>
<span class="c1"># output.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1"># Multiply a matrix by a constant:</span>
<span class="c1"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span>
<span class="c1"># these can be broadcast together to shape (2, 3), producing the</span>
<span class="c1"># following array:</span>
<span class="c1"># [[ 2  4  6]</span>
<span class="c1">#  [ 8 10 12]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  
</pre></div>

<p>Широковещательная рассылка обычно делает ваш код более кратким и быстрым, поэтому вы должен стремиться использовать его там, где это возможно.  </p>
<h3>Документация Numpy</h3>
<p>Этот краткий обзор затронул многие важные вещи, которые вам необходимо Знаем о numpy, но далеко не полны. Ознакомьтесь <a href="http://docs.scipy.org/doc/numpy/reference/">со справочником numpy</a>, чтобы узнать больше о numpy.</p>
<h2>SciPy</h2>
<p><em>Numpy</em> предоставляет высокопроизводительный многомерный массив и основные инструменты для Выполняйте вычисления с помощью этих массивов и управляйте ими. 
<a href="http://docs.scipy.org/doc/scipy/reference/">SciPy</a> опирается на это и предоставляет большое количество функций, которые работают с массивами numpy и полезны для различные виды научных и инженерных приложений.  </p>
<p>Лучший способ познакомиться с <em>SciPy</em> - <a href="http://docs.scipy.org/doc/scipy/reference/index.html">это просмотреть документацию</a>. 
Мы выделим некоторые части SciPy, которые могут быть вам полезны для этого класса.</p>
<h3>Операции с изображениями</h3>
<p><em>SciPy</em> предоставляет некоторые основные функции для работы с изображениями. 
Например, в нем есть функции чтения изображений с диска в массивы numpy, для записи массивов numpy на диск в виде изображений, а также для изменения размера изображений. 
Вот простой пример, демонстрирующий эти функции:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">imread</span><span class="p">,</span> <span class="n">imsave</span><span class="p">,</span> <span class="n">imresize</span>

<span class="c1"># Read an JPEG image into a numpy array</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">'assets/cat.jpg'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "uint8 (400, 248, 3)"</span>

<span class="c1"># We can tint the image by scaling each of the color channels</span>
<span class="c1"># by a different scalar constant. The image has shape (400, 248, 3);</span>
<span class="c1"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span>
<span class="c1"># numpy broadcasting means that this leaves the red channel unchanged,</span>
<span class="c1"># and multiplies the green and blue channels by 0.95 and 0.9</span>
<span class="c1"># respectively.</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

<span class="c1"># Resize the tinted image to be 300 by 300 pixels.</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">imresize</span><span class="p">(</span><span class="n">img_tinted</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>

<span class="c1"># Write the tinted image back to disk</span>
<span class="n">imsave</span><span class="p">(</span><span class="s1">'assets/cat_tinted.jpg'</span><span class="p">,</span> <span class="n">img_tinted</span><span class="p">)</span>
</pre></div>

<p><strong>_<br><img alt="" src="https://cs231n.github.io/assets/cat.jpg"><br><img alt="" src="https://cs231n.github.io/assets/cat_tinted.jpg"><br></strong>Сверху<strong>: исходное изображение. </strong>Снизу<strong>: Затемненное изображение с измененным размером.<br></strong>_  </p>
<h3>Файлы MATLAB</h3>
<p>Функции и позволяют считывать и писать файлы <em>MATLAB</em>. О них можно прочитать в <a href="http://docs.scipy.org/doc/scipy/reference/io.html">документации</a>.<code>scipy.io.loadmatscipy.io.savemat</code></p>
<h3>Расстояние между точками</h3>
<p><em>SciPy</em> определяет некоторые полезные функции для вычисления расстояний между наборами точек.  </p>
<p>Функция вычисляет расстояние между всеми парами очков в заданном наборе:<code>scipy.spatial.distance.pdist</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>

<span class="c1"># Create the following array where each row is a point in 2D space:</span>
<span class="c1"># [[0 1]</span>
<span class="c1">#  [1 0]</span>
<span class="c1">#  [2 0]]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Compute the Euclidean distance between all rows of x.</span>
<span class="c1"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span>
<span class="c1"># and d is the following array:</span>
<span class="c1"># [[ 0.          1.41421356  2.23606798]</span>
<span class="c1">#  [ 1.41421356  0.          1.        ]</span>
<span class="c1">#  [ 2.23606798  1.          0.        ]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">'euclidean'</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>

<p>Все подробности об этой функции вы можете прочитать в <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">документации</a>.  </p>
<p>Аналогичная функция (<code>scipy.spatial.distance.cdist</code>) вычисляет расстояние между всеми парами по двум группам точек; Вы можете прочитать об этом <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">в документации</a> .</p>
<h2>Matplotlib</h2>
<p><a href="http://matplotlib.org/">Matplotlib</a> — библиотека для построения графиков. В этом разделе дается краткое введение в модуль, который обеспечивает систему построения графиков, аналогичную системе <em>MATLAB</em>.<code>matplotlib.pyplot</code></p>
<h3>Постоение графиков</h3>
<p>Наиболее важной функцией в <em>matplotlib</em> является , что позволяет строить графики <em>2D</em> данных. Вот простой пример:<code>plot</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on a sine curve</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Plot the points using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># You must call plt.show() to make graphics appear.</span>
</pre></div>

<p>Выполнение этого кода создает следующий график:<br><strong>_<br><img alt="" src="https://cs231n.github.io/assets/sine.png"><br></strong>_  </p>
<p>Приложив немного дополнительной работы, мы можем легко построить несколько линий и добавьте заголовок, легенду и подписи оси:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on sine and cosine curves</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Plot the points using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_sin</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_cos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'x axis label'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'y axis label'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Sine and Cosine'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'Sine'</span><span class="p">,</span> <span class="s1">'Cosine'</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><strong>_<br><img alt="" src="https://cs231n.github.io/assets/sine_cosine.png"><br></strong>_  </p>
<p>Гораздо больше о функции вы можете прочитать <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot">в документации</a>.<code>plot</code></p>
<h3>Побочные сюжеты</h3>
<p>С помощью этой функции на одном и том же рисунке можно изобразить разные объекты. Вот пример:<code>subplot</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on sine and cosine curves</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Set up a subplot grid that has height 2 and width 1,</span>
<span class="c1"># and set the first such subplot as active.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Make the first plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_sin</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Sine'</span><span class="p">)</span>

<span class="c1"># Set the second subplot as active, and make the second plot.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_cos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Cosine'</span><span class="p">)</span>

<span class="c1"># Show the figure.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><strong>_<br><img alt="" src="https://cs231n.github.io/assets/sine_cosine_subplot.png"><br></strong>_  </p>
<p>Гораздо больше о функции вы можете прочитать <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot">в документации</a>.<code>subplot</code></p>
<h3>Изображения</h3>
<p>Вы можете использовать функцию для показа изображений. Вот пример:<code>imshow</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">imread</span><span class="p">,</span> <span class="n">imresize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">'assets/cat.jpg'</span><span class="p">)</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

<span class="c1"># Show the original image</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="c1"># Show the tinted image</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># A slight gotcha with imshow is that it might give strange results</span>
<span class="c1"># if presented with data that is not uint8. To work around this, we</span>
<span class="c1"># explicitly cast the image to uint8 before displaying it.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">img_tinted</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><strong>_<br><img alt="" src="https://cs231n.github.io/assets/cat_tinted_imshow.png"><br></strong>_</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/software-setup/" class="u-url">Настройка программного обеспечения </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/software-setup/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-01T19:42:16+03:00" itemprop="datePublished" title="2025-03-01 19:42">2025-03-01 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Настройка программного обеспечения</h2>
<p>В этом году рекомендуется работать над заданиями через <a href="https://colab.research.google.com/">Google Colaboratory</a>. Однако, если у вас уже есть оборудование на базе графического процессора и вы предпочитаете работать локально, мы предоставим вам инструкции по настройке виртуальной среды.
- <a href="posts/software-setup/">Удаленная работа в Google Colaboratory</a>
- <a href="posts/software-setup/">Работа локально на вашем компьютере</a>
    - <a href="posts/software-setup/">Виртуальная среда Anaconda</a>
    - <a href="posts/software-setup/">Python venv</a>
    - <a href="posts/software-setup/">Установка пакетов</a></p>
<h4>Удаленная работа в Google Colaboratory</h4>
<p><em>Google Colaboratory</em> — это, по сути, комбинация <em>Jupyter notebook</em> и<em> Google Drive</em>. Он полностью работает в облаке и поставляется предустановлены многие пакеты (например, <em>PyTorch</em> и <em>Tensorflow</em>), поэтому у всех есть доступ к одному и тому же Зависимости. Еще круче тот факт, что Colab получает бесплатный доступ к аппаратным ускорителям например, графические процессоры (<em>K80</em>, <em>P100</em>) и ТПУ, которые будут особенно полезны для заданий <strong>2</strong> и <strong>3</strong>.  </p>
<p><strong>Требования</strong>. Чтобы использовать <em>Colab</em>, у вас должен быть аккаунт <em>Google</em> со связанным <em>Google</em> <strong>Диском</strong>. Предполагая, что у вас есть и то, и другое, вы можете подключить <em>Colab</em> к диску, выполнив следующие действия:</p>
<ol>
<li>Нажмите на колесико в правом верхнем углу и выберите .<code>Settings</code>
</li>
<li>Нажмите на вкладку.<code>Manage Apps</code>
</li>
<li>Вверху выберите, что должно вызвать окно.<code>Connect more apps</code> <code>GSuite Marketplace</code>
</li>
<li>Найдите <strong>Colab</strong> и нажмите .<code>Add</code>  </li>
</ol>
<p><strong>Рабочий процесс</strong>. Каждое задание содержит ссылку для скачивания zip-файла, содержащего записные книжки <em>Colab</em> и начальный код <em>Python</em>. Вы можете загрузить папку на <strong>Диск</strong>, открыть записные книжки в <em>Colab</em> и работать с ними, а затем сохранить свой прогресс обратно на <strong>Диск</strong>. Мы рекомендуем вам посмотреть обучающее видео ниже, в котором описывается рекомендуемый рабочий процесс на примере задания <strong>1</strong>.  </p>
<iframe style="display: block; margin: auto;" width="560" height="315" src="https://www.youtube.com/embed/DsGd2e9JNH4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<div class="code"><pre class="code literal-block">
</pre></div>

<p><strong>Лучшие практики</strong>. Есть несколько вещей, о которых вы должны знать при работе с <em>Colab</em>. Первое, что стоит отметить, это то, что ресурсы не гарантируются (это плата за бесплатность). Если вы бездействуете в течение определенного времени или общее время подключения превышает максимально допустимое время (<em>~12 часов</em>), виртуальная машина <em>Colab</em> будет отключена. Это означает, что любой несохраненный прогресс будет потерян. <font color="red"><strong> Таким образом, выработайте привычку часто сохранять свой код во время работы над заданиями. </strong></font> Чтобы узнать больше об ограничениях ресурсов в <em>Colab</em>, ознакомьтесь с их часто задаваемыми вопросами <a href="https://research.google.com/colaboratory/faq.html">здесь</a>.</p>
<p><strong>Использование графического процессора</strong>. Использовать графический процессор так же просто, как переключить среду выполнения в <em>Colab</em>. В частности, нажмите, и ваш экземпляр <em>Colab</em> будет автоматически подкреплен вычислениями графического процессора.<code>Runtime -&gt; Change runtime type -&gt; Hardware Accelerator -&gt; GPU</code>  </p>
<p>Если вы хотите узнать больше о <em>Colab</em>, мы рекомендуем вам посетить следующие ресурсы:
- <a href="https://www.youtube.com/watch?v=inN8seMm7UI">Введение в Google Colab</a>
- <a href="https://colab.research.google.com/notebooks/intro.ipynb">Добро пожаловать в Colab</a>
- <a href="https://colab.research.google.com/notebooks/basic_features_overview.ipynb">Обзор функций Colab</a>  </p>
<h4>Работа локально на вашем компьютере</h4>
<p>Если вы хотите работать локально, вам следует использовать виртуальную среду. Вы можете установить его через <em>Anaconda</em> (рекомендуется) или через собственный модуль <em>Python</em>. Убедитесь, что вы используете <strong>Python 3.7</strong>, так как <strong>мы больше не поддерживаем Python 2</strong>.<code>venv</code>  </p>
<h5>Виртуальная среда Anaconda</h5>
<p>Мы настоятельно рекомендуем использовать бесплатный <a href="https://www.anaconda.com/download/">дистрибутив Anaconda Python</a>, который предоставляет простой способ обработки зависимостей пакетов. Пожалуйста, обязательно скачайте версию <strong>Python 3</strong>, которая в настоящее время устанавливает <strong>Python 3.7</strong>. Приятная вещь в <em>Anaconda</em> заключается в том, что она поставляется с <a href="https://docs.anaconda.com/mkl-optimizations/">оптимизацией MKL</a> по умолчанию, что означает, что вы и код получаете значительное ускорение без необходимости изменять ни одной строки кода.<code>numpy</code> <code>scipy</code></p>
<p>После установки Anaconda имеет смысл создать виртуальную среду для курса. Если вы решите не использовать виртуальную среду (<em>настоятельно не рекомендуется!</em>), вы должны убедиться, что все зависимости для кода установлены глобально на вашем компьютере. Чтобы настроить виртуальную среду с именем , выполните следующие действия в терминале:<code>cs231n</code>  </p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">will</span><span class="w"> </span><span class="nv">create</span><span class="w"> </span><span class="nv">an</span><span class="w"> </span><span class="nv">anaconda</span><span class="w"> </span><span class="nv">environment</span>
#<span class="w"> </span><span class="nv">called</span><span class="w"> </span><span class="nv">cs231n</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="s1">'path/to/anaconda3/envs/'</span>
<span class="nv">conda</span><span class="w"> </span><span class="nv">create</span><span class="w"> </span><span class="o">-</span><span class="nv">n</span><span class="w"> </span><span class="nv">cs231n</span><span class="w"> </span><span class="nv">python</span><span class="o">=</span><span class="mi">3</span>.<span class="mi">7</span>
Чтобы<span class="w"> </span>активировать<span class="w"> </span>и<span class="w"> </span>войти<span class="w"> </span>в<span class="w"> </span>среду,<span class="w"> </span>запустите<span class="w"> </span>.<span class="w"> </span>Чтобы<span class="w"> </span>отключить<span class="w"> </span>среду,<span class="w"> </span>запустите<span class="w"> </span>терминал<span class="w"> </span>или<span class="w"> </span>выйдите<span class="w"> </span>из<span class="w"> </span>него.<span class="w"> </span>Обратите<span class="w"> </span>внимание,<span class="w"> </span>что<span class="w"> </span>каждый<span class="w"> </span>раз,<span class="w"> </span>когда<span class="w"> </span>вы<span class="w"> </span>хотите<span class="w"> </span>поработать<span class="w"> </span>над<span class="w"> </span>заданием,<span class="w"> </span>вы<span class="w"> </span>должны<span class="w"> </span>повторно<span class="w"> </span>запустить<span class="w"> </span>.<span class="nv">conda</span><span class="w"> </span><span class="nv">activate</span><span class="w"> </span><span class="nv">cs231nconda</span><span class="w"> </span><span class="nv">deactivate</span><span class="w"> </span><span class="nv">cs231nconda</span><span class="w"> </span><span class="nv">activate</span><span class="w"> </span><span class="nv">cs231n</span>

#<span class="w"> </span><span class="nv">sanity</span><span class="w"> </span><span class="nv">check</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">python</span>
#<span class="w"> </span><span class="nv">binary</span><span class="w"> </span><span class="nv">matches</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">anaconda</span><span class="w"> </span><span class="nv">env</span>
#<span class="w"> </span><span class="nv">after</span><span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">activate</span><span class="w"> </span><span class="nv">it</span>
<span class="nv">which</span><span class="w"> </span><span class="nv">python</span>
#<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">example</span>,<span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">my</span><span class="w"> </span><span class="nv">machine</span>,<span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">prints</span>
#<span class="w"> </span>$<span class="w"> </span><span class="s1">'/Users/kevin/anaconda3/envs/sci/bin/python'</span>
</pre></div>

<p>Вы можете обратиться к <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">этой странице</a> за более подробными инструкциями по управлению виртуальными средами с помощью Anaconda.  </p>
<p>__Заметка___: Если вы решили пойти по пути <em>Anaconda</em>, вы можете смело пропустить следующий раздел и сразу перейти к <a href="https://cs231n.github.io/setup-instructions/#installing-packages">установке пакетов</a>.  </p>
<h4>Python venv</h4>
<p>Начиная с версии <em>3.3</em>, <em>Python</em> поставляется с облегченным модулем виртуальной среды под названием <a href="https://docs.python.org/3/library/venv.html">venv</a>. Каждая виртуальная среда упаковывает свой собственный независимый набор установленных пакетов <em>Python</em>, которые изолированы от общесистемных пакетов <em>Python</em> и запускают версию <em>Python</em>, совпадающую с версией двоичного файла, который использовался для ее создания. Чтобы настроить виртуальную среду с именем , выполните следующие действия в терминале:<code>cs231n</code>  </p>
<div class="code"><pre class="code literal-block"># this will create a virtual environment
# called cs231n in your home directory
python3.7 -m venv ~/cs231n
</pre></div>

<p>Чтобы активировать и войти в среду, запустите . Чтобы отключить среду, запустите терминал или выйдите из него. Обратите внимание, что каждый раз, когда вы хотите поработать над заданием, вы должны повторно запустить .<code>source ~/cs231n/bin/activate</code> <code>deactivate</code> <code>source ~/cs231n/bin/activate</code>  </p>
<div class="code"><pre class="code literal-block">#<span class="w"> </span><span class="nv">sanity</span><span class="w"> </span><span class="nv">check</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">python</span>
#<span class="w"> </span><span class="nv">binary</span><span class="w"> </span><span class="nv">matches</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">virtual</span><span class="w"> </span><span class="nv">env</span>
#<span class="w"> </span><span class="nv">after</span><span class="w"> </span><span class="nv">you</span><span class="w"> </span><span class="nv">activate</span><span class="w"> </span><span class="nv">it</span>
<span class="nv">which</span><span class="w"> </span><span class="nv">python</span>
#<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">example</span>,<span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">my</span><span class="w"> </span><span class="nv">machine</span>,<span class="w"> </span><span class="nv">this</span><span class="w"> </span><span class="nv">prints</span>
#<span class="w"> </span>$<span class="w"> </span><span class="s1">'/Users/kevin/cs231n/bin/python'</span>
</pre></div>

<h4>Установка пакетов</h4>
<p>После того как вы <strong>настроили</strong> и <strong>активировали</strong> свою виртуальную среду (с помощью или ), вы должны установить библиотеки, необходимые для выполнения назначений с помощью . Для этого выполните:<code>conda</code> <code>venv</code> <code>pip</code></p>
<div class="code"><pre class="code literal-block"><span class="p">#</span><span class="w"> </span><span class="n">again</span><span class="p">,</span><span class="w"> </span><span class="n">ensure</span><span class="w"> </span><span class="n">your</span><span class="w"> </span><span class="n">virtual</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="p">(</span><span class="n">either</span><span class="w"> </span><span class="n">conda</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">venv</span><span class="p">)</span>
<span class="p">#</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">been</span><span class="w"> </span><span class="n">activated</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">running</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">commands</span><span class="w"> </span><span class="n">below</span>
<span class="n">cd</span><span class="w"> </span><span class="n">assignment1</span><span class="w">  </span><span class="p">#</span><span class="w"> </span><span class="n">cd</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">directory</span>

<span class="p">#</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">assignment</span><span class="w"> </span><span class="n">dependencies</span><span class="p">.</span>
<span class="p">#</span><span class="w"> </span><span class="n">since</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">virtual</span><span class="w"> </span><span class="n">env</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">activated</span><span class="p">,</span>
<span class="p">#</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">pip</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span>
<span class="p">#</span><span class="w"> </span><span class="n">python</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">environment</span>
<span class="n">pip</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="o">-</span><span class="n">r</span><span class="w"> </span><span class="n">requirements</span><span class="p">.</span><span class="n">txt</span><span class="w">  </span>
</pre></div>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/nlp-za-90-minut/" class="u-url">NLP за 90 минут</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/nlp-za-90-minut/" rel="bookmark">
            <time class="published dt-published" datetime="2023-06-16T11:44:44+03:00" itemprop="datePublished" title="2023-06-16 11:44">2023-06-16 11:44</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Основы обработки естественного языка</h2>
<h4>Вопросы:</h4>
<ol>
<li>Краткая история машинной обработки текстов (5 мин)</li>
<li>Основные определения (5 мин)</li>
<li>Методы предварительной обработки текста (10 мин)</li>
<li>Моделирование языка (языковые модели) (10 мин)</li>
<li>Нейронные сети в NLP (30 мин)</li>
<li>GPT модели (30 мин)</li>
</ol>
<h4>1. Краткая история машинной обработки текстов</h4>
<p><strong>NLP (Natural Language Processing)</strong> - это область науки, которая изучает методы обработки текстов на естественных языках с помощью вычислительных машин. 
Основной акцент в NLP делается на прикладные методы, которые можно реализовать на языке программирования. 
Для вычислительно сложных методов используют языки низкого уровня (С, С++), потому что важна эффективность вычислений. 
Для проведение экспериментов используют языки высокого уровня (python), потому что  для проверки гипотез важна скорость написания кода. 
Сегодня исследователям доступно множество библиотек на python, которые служат оберткой для оптимизированного машинного кода.  </p>
<p>В 1913 году русский математик Андрей Андреевич Марков провел эксперимент по оценке частоты появления разных букв в тексте. 
Он выписал первые 20 000 букв поэмы А. С. Пушкина «Евгений Онегин» в одну длинную строчку из букв, опустив все пробелы и знаки пунктуации. 
Затем он переставил эти буквы в 200 решёток (по 10х10 символов в каждой), и начал подсчитывать гласные звуки в каждой строке и столбце, записывая результаты. 
Марков считал, что большинство явлений происходит по цепочке причинно-следственной связи и зависит от предыдущих результатов. 
Он хотел найти способ моделировать эти события посредством вероятностного анализа. 
Он обнаружил, что для любой буквы текста Пушкина выполнялось правило: если это была гласная, то скорее всего за ней будет стоять согласная, и наоборот.  </p>
<p>В 1950 году в работе "Вычислительные машины и разум" ученый Алан Тьюринг предложил тест разумности для искуственного интеллекта.<br>
Если компьютер сможет провести убедительную беседу с человеком в текстовом режиме, можно будет предположить, что он разумен. </p>
<p>В 1954 году в штаб-квартире корпорации IBM состоялся Джорджтаунский эксперимент — демонстрация возможностей машинного перевода. 
В ходе эксперимента был продемонстрирован полностью автоматический перевод более 60 предложений с русского языка на английский. 
Программа выполнялась на мейнфрейме IBM 701. 
В том же году первый эксперимент по машинному переводу был произведён в Институте точной механики и вычислительной техники АН СССР, на компьютере БЭСМ.  </p>
<p>В 1966 году Джозеф Вейценбаум, работавший в лаборатории ИИ при MIT, разработал первый в мире чатбот "Элиза". 
Пользователь мог ввести некое утверждение или набор утверждений на обычном языке, нажать «ввод», и получить от машины ответ.  </p>
<p>В 1986 Давид Румельхарт разработал базовую концепцию рекуррентной нейросети (recurrent neural network, RNN). 
Этот метод позволял решать такие задачи как распознавание речи и текста.  </p>
<p>В 2017 году группа исследователей Google представила архитектуру трансформера (Transformer), которая позволяет обрабатывать тексты, в которых слова расположены в произвольном порядке. 
В настоящее время трансформеры используются в сервисах многих компаний, включая Яндекс и Google, являются основой для самых современных моделей GPT, Bert и т.д.  </p>
<p>В 2023 году OpenAI опубликовала языковую модель GPT-4, которая легко проходит тест Тьюринга и порождает споры об опасности искусственного интеллекта. </p>
<h4>2. Основные определения</h4>
<p><strong>Символ</strong> - это условный знак каких-либо понятий, идей, явлений. 
Первые наскальные символы обозначали зверей, охоту, солнце и другие предметы, которые отражались в сознании первобытных людей. 
Мы и сегодня часто используем символы эмоджи для отображения своих эмоций и скрытых смыслов. 
У разных народов сформировались свои уникальные алфавиты, которы представляют собой множества допустимых символов для письма.   </p>
<p>У компьютера тоже есть уникальный набор символов, определяемый кодировкой. 
Например, кодировка ASCII (American standard code for information interchange) была стандартизована в 1963 году и определяет символы:<br>
- десятичных цифр;<br>
- латинского алфавита;<br>
- национального алфавита;<br>
- знаков препинания;<br>
- управляющих символов.  </p>
<p>С математической точки зрения алфавит как множество символов обозначается символом $V$.<br>
Всевозможные комбинации символов, образующих конечные слова, в т.ч. состоящие из одного символа и бессмысленные комбинации, образуют множество $V^*$. </p>
<p><strong>Слово</strong> - наименьшая единица языка, служащая для именования предметов, качеств, характеристик, взаимодействий, а также для служебных целей. 
Например слово "Я" состоит всего из одного символа и в русском языке обозначает меня как субъект.<br>
Большинство слов состоят из нескольких символов, связанных в последовательность по определенным правилам. </p>
<p><strong>Язык</strong> - это множество слов, которые несут в себе хоть какой-то смысл. 
Например, слово "тывщштс" не имеет смысла в русском языке, хоть и состоит из символов кириллицы. 
А слово "дом", наоборот, является вполне известным и входит в множество слов русского языка. <br>
Формально язык обозначается символом $L$. В алфавите $V$ язык является подмножеством всех конечных слов $$L \in V^*$$</p>
<p><strong>Текст</strong> - это зафиксированая на материальном носителе человеческая мысль в виде последовательности символов. 
Текст может состоять из одного или нескольких слов. </p>
<h5>Представление текста в компьютере</h5>
<p>Для человека символы, слова и тексты несут в себе определенный смысл. 
Компьютер же работает только с байтами. 
Рассмотрим пример, как реализовано посимвольное кодирование алфавита в кодировке ASCII.</p>
<table class="tg">
<thead><tr>
<th class="tg-0pky">bin</th>
    <th class="tg-0pky">dec</th>
    <th class="tg-0pky">hex</th>
    <th class="tg-0pky">symbol</th>
  </tr></thead>
<tbody>
<tr>
<td class="tg-c3ow">110 0001</td>
    <td class="tg-c3ow">97</td>
    <td class="tg-c3ow">61</td>
    <td class="tg-c3ow">a</td>
  </tr>
<tr>
<td class="tg-c3ow">110 0010</td>
    <td class="tg-c3ow">98</td>
    <td class="tg-c3ow">62</td>
    <td class="tg-c3ow">b</td>
  </tr>
<tr>
<td class="tg-c3ow">110 0011</td>
    <td class="tg-c3ow">99</td>
    <td class="tg-c3ow">63</td>
    <td class="tg-c3ow">c</td>
  </tr>
<tr>
<td class="tg-c3ow">110 1010</td>
    <td class="tg-c3ow">106</td>
    <td class="tg-c3ow">6A</td>
    <td class="tg-c3ow">j</td>
  </tr>
<tr>
<td class="tg-c3ow">110 1011</td>
    <td class="tg-c3ow">107</td>
    <td class="tg-c3ow">6B</td>
    <td class="tg-c3ow">k</td>
  </tr>
</tbody>
</table>
<p><strong>bin</strong> - двоичное представление символа,<br><strong>dec</strong> - представление в десятичной системе счисления,<br><strong>hex</strong> - представление в шестнадцатеричной системе счисления.<br>
С полной таблицей кодировки ASCII можно ознакомиться по <a href="https://en.wikipedia.org/wiki/ASCII#8-bit_codes">ссылке</a>.<br>
Для хранения одного символа латинского алфавита достаточно 7 бит. 
Для хранения одного символа небольшого национального алфавита (например, кириллицы) достаточно 8 бит. 
Для кодировки символов более объемных алфавитов (например, китайского) используют 16 бит или два байта.  <br>
Слова, как и тексты, хранятся в компьютерной памяти в виде последовательности символов. </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/template/" class="u-url">Шаблон для новых постов</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/template/" rel="bookmark">
            <time class="published dt-published" datetime="2022-05-16T17:25:16+03:00" itemprop="datePublished" title="2022-05-16 17:25">2022-05-16 17:25</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Заготовка для создания новых постов</h2>
<p>Текст здесь </p>
<p>$$a^2 + b^2 = c^2$$</p>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="." rel="prev">Новые записи</a></li>
        </ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
