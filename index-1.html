<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="Заметки по machine learning, deep learning.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Заметки по ML, DL (1 страница со старыми записями) | Заметки по ML, DL</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="rss.xml">
<link rel="canonical" href="https://mldl.ru/index-1.html">
<link rel="prev" href="." type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/numpy-tutorial/" class="u-url">Tutorial python Numpy</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/numpy-tutorial/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-02T19:42:16+03:00" itemprop="datePublished" title="2025-03-02 19:42">2025-03-02 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Туториал python Numpy (с Jupyter и Colab)</h2>
<p><a href="https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/python-colab.ipynb">Блокнот Colab</a></p>
<p>Этот урок был первоначально предоставлен <a href="http://cs.stanford.edu/people/jcjohns/">Джастином Джонсоном</a>.  </p>
<p>Мы будем использовать язык программирования <em>python</em> для всех заданий этого курса. <em>Python</em> сам по себе является отличным языком программирования общего назначения, но с помощью нескольких популярных библиотек (<em>numpy</em>, <em>scipy</em>, <em>matplotlib</em>) он становится мощной средой для научных вычислений.</p>
<p>Мы ожидаем, что многие из вас имеют некоторый опыт работы с <em>python</em> и <em>numpy</em>; Для остальных из вас этот раздел послужит кратким ускоренным курсом по обоим направлениям языка программирования <em>python</em> и его использованию для научных исследований и вычислений. Мы также познакомим вас с блокнотами, которые являются очень удобным способом работы с кодом на <em>python</em>. Некоторые из вас, возможно, уже знакомы с другими языками, и в этом случае мы также рекомендуем ссылаться <a href="https://numpy.org/doc/stable/user/numpy-for-matlab-users.html">на NumPy для пользователей Matlab</a>, <a href="http://www.data-analysis-in-python.org/python_for_r.html">python для пользователей R</a> и/или <a href="https://nbviewer.jupyter.org/github/RandyBetancourt/pythonForSASUsers/tree/master/">python для пользователей SAS</a>.  </p>
<p>Содержание
- <a href="posts/numpy-tutorial/">Блокноты Jupyter и Colab</a>
- <a href="posts/numpy-tutorial/">Питон</a>
    - <a href="posts/numpy-tutorial/">Версии python</a>
    - <a href="posts/numpy-tutorial/">Основные типы данных</a>
    - <a href="posts/numpy-tutorial/">Контейнеры</a>
        - <a href="posts/numpy-tutorial/">Списках</a>
        - <a href="posts/numpy-tutorial/">Словари</a>
        - <a href="posts/numpy-tutorial/">Множество</a>
        - <a href="posts/numpy-tutorial/">Кортежи</a>
    - <a href="posts/numpy-tutorial/">Функции</a>
    - <a href="posts/numpy-tutorial/">Классы</a>
- <a href="posts/numpy-tutorial/">Numpy</a>
    - <a href="posts/numpy-tutorial/">Массивы</a>
    - <a href="posts/numpy-tutorial/">Индексация массивов</a>
    - <a href="posts/numpy-tutorial/">Типы данных</a>
    - <a href="posts/numpy-tutorial/">Математические операции с массивами</a>
    - <a href="posts/numpy-tutorial/">Вещание</a>
    - <a href="posts/numpy-tutorial/">Документация Numpy</a>
- <a href="posts/numpy-tutorial/">SciPy</a>
    - <a href="posts/numpy-tutorial/">Операции с изображениями</a>
    - <a href="posts/numpy-tutorial/">Файлы MATLAB</a>
    - <a href="posts/numpy-tutorial/">Расстояние между точками</a>
- <a href="posts/numpy-tutorial/">Matplotlib</a>
    - <a href="posts/numpy-tutorial/">Постоение кривой</a>
    - <a href="posts/numpy-tutorial/">Побочные сюжеты</a>
    - <a href="posts/numpy-tutorial/">Изображения</a>  </p>
<h2>Блокноты Jupyter и Colab</h2>
<p>Прежде чем мы углубимся в <em>python</em>, мы хотели бы кратко поговорить о <em>блокнотах</em>. Блокнот <em>Jupyter</em> позволяет писать и выполнять код <em>python</em> <em>локально</em> в вашем веб-браузере. <em>Jupyter notebooks</em> yпрощает работу с кодом и выполняет его битами и сегментами; По этой причине он широко используется в научных вычислениях. <em>Colab</em>, с другой стороны, является разновидностью <em>Google-блокнота</em> <em>Jupyter</em>, который особенно подходит для машинных алгоритмов обучения и анализа данных, которые сохраняют функционал в <em>облаке</em>. <em>Colab</em> — это, по сути, <em>Jupyter</em> notebook на стероидах: он бесплатный, не требует настройки, поставляется с предустановленными пакетами, им легко поделиться со всем миром, присутствуют преимущества бесплатного доступа к аппаратным ускорителям, таким как графические процессоры и <em>TPU</em> (с некоторыми оговорками).  </p>
<p><strong>Запустите Tutorial в Colab (рекомендуется)</strong>. Если вы хотите выполнить это руководство полностью в <em>Colab</em>, нажмите на значок <code>Open in Colab</code> в самом верху этой страницы.</p>
<p><strong>Запустите Tutorial в блокноте Jupyter</strong>. Если вы хотите запустить блокнот локально с помощью <em>Jupyter</em>, убедитесь, что ваша виртуальная среда установлена правильно (в соответствии с <a href="https://cs231n.github.io/setup-instructions/">инструкциями по настройке</a>), активируйте ее, а затем запустите <code>pip install notebook</code> для установки блокнота <em>Jupyter</em>. Затем <a href="https://raw.githubusercontent.com/cs231n/cs231n.github.io/master/jupyter-notebook-tutorial.ipynb">откройте блокнот</a> и загрузите его в каталог по вашему выбору, щелкнув правой кнопкой мыши по странице и выбрав <code>Save Page As</code>. Затем <code>cd</code> в этот каталог и запустите <code>jupyter notebook</code>.     </p>
<p><img alt="" src="https://cs231n.github.io/assets/ipython-tutorial/file-browser.png"></p>
<p>Это должно автоматически запустить сервер блокнотов по адресу <code>http://localhost:8888</code>. Если все работало правильно, вы должны увидеть такой экран, показывающий все доступные записные книжки в текущем каталоге. Нажмите <code>jupyter-notebook-tutorial.ipynb</code> и следуйте инструкциям в блокноте. В противном случае вы можете продолжить чтение туториала с фрагментами кода ниже.   </p>
<h2>Python</h2>
<p><strong>Python</strong> — это высокоуровневый, динамически типизированный мультипарадигмальный язык программирования. О коде на <em>python</em> часто говорят, что он похож на псевдокод, поскольку он позволяет вам выражать очень мощные идеи в очень немногих строках кода, оставаясь при этом очень удобочитаемый. В качестве примера приведем реализацию алгоритма классической быстрой сортировки на <em>python</em>:  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">quicksort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="c1"># Prints "[1, 1, 2, 3, 6, 8, 10]"</span>
</pre></div>

<h3>Версии python</h3>
<p>С 1 января 2020 года python <a href="https://www.python.org/doc/sunset-python-2/">официально прекратил поддержку</a> второй версии. 
<strong>Поэтому во всех примерах код написан на python 3.7</strong>. Убедитесь, что вы правильно установили виртуальную среду, прежде чем продолжить работу с этим руководством. Вы можете проверить свою версию в командной строке после активации среды, запустив команду: <code>python --version</code>  </p>
<h3>Основные типы данных</h3>
<p>Как и большинство языков, <em>python</em> имеет ряд основных типов: <em>int</em>, <em>floats</em>, <em>booleans</em> и <em>strings</em>. 
Эти типы данных ведут себя так же, как и в большинстве других языков программирования.  </p>
<p><strong>Числа</strong>:  </p>
<div class="code"><pre class="code literal-block"><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'int'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># Prints "3"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Addition; prints "4"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Subtraction; prints "2"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Multiplication; prints "6"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Exponentiation; prints "9"</span>
<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints "4"</span>
<span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints "8"</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'float'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Prints "2.5 3.5 5.0 6.25"</span>
</pre></div>

<p>Обратите внимание, что в отличие от многих языков, в python нет унарного инкремента (<code>x++</code>) или декремента (<code>x--</code>).   </p>
<p><em>Python</em> также имеет встроенные типы для комплексных чисел; 
Все подробности можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#numeric-types-int-float-complex">в документации</a>.</p>
<p><strong>Логический тип данных</strong>: <em>python</em> реализует все обычные операторы для булевой логики, но использует английские слова, а не символы (<code>&amp;&amp;</code>, <code>||</code> , и т. д.):   </p>
<div class="code"><pre class="code literal-block"><span class="n">t</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">f</span> <span class="o">=</span> <span class="kc">False</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'bool'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="ow">and</span> <span class="n">f</span><span class="p">)</span> <span class="c1"># Logical AND; prints "False"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="ow">or</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Logical OR; prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="n">t</span><span class="p">)</span>   <span class="c1"># Logical NOT; prints "False"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Logical XOR; prints "True"</span>
</pre></div>

<p><strong>Строки</strong>: <em>python</em> имеет отличную поддержку строк:  </p>
<div class="code"><pre class="code literal-block"><span class="n">hello</span> <span class="o">=</span> <span class="s1">'hello'</span>    <span class="c1"># String literals can use single quotes</span>
<span class="n">world</span> <span class="o">=</span> <span class="s2">"world"</span>    <span class="c1"># or double quotes; it does not matter.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>       <span class="c1"># Prints "hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hello</span><span class="p">))</span>  <span class="c1"># String length; prints "5"</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">hello</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="n">world</span>  <span class="c1"># String concatenation</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span>  <span class="c1"># prints "hello world"</span>
<span class="n">hw12</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>  <span class="c1"># sprintf style string formatting</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hw12</span><span class="p">)</span>  <span class="c1"># prints "hello world 12"  </span>
</pre></div>

<p>Строковые объекты имеют множество полезных методов:  </p>
<div class="code"><pre class="code literal-block"><span class="n">s</span> <span class="o">=</span> <span class="s2">"hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>  <span class="c1"># Capitalize a string; prints "Hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>       <span class="c1"># Convert a string to uppercase; prints "HELLO"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>      <span class="c1"># Right-justify a string, padding with spaces; prints "  hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>     <span class="c1"># Center a string, padding with spaces; prints " hello "</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="s1">'(ell)'</span><span class="p">))</span>  <span class="c1"># Replace all instances of one substring with another;</span>
                                <span class="c1"># prints "he(ell)(ell)o"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'  world '</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>  <span class="c1"># Strip leading and trailing whitespace; prints "world"</span>
</pre></div>

<p>Список всех строковых методов можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#string-methods">в документации</a>.</p>
<h3>Контейнеры</h3>
<p>Python включает в себя несколько встроенных типов контейнеров: списки, словари, наборы и кортежи.</p>
<h4>Списки</h4>
<p>Список в <em>python</em> является эквивалентом массива, но его размер можно изменять и он можетё содержать элементы разных типов:  </p>
<div class="code"><pre class="code literal-block"><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>    <span class="c1"># Create a list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># Prints "[3, 1, 2] 2"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># Negative indices count from the end of the list; prints "2"</span>
<span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'foo'</span>     <span class="c1"># Lists can contain elements of different types</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>         <span class="c1"># Prints "[3, 1, 'foo']"</span>
<span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>  <span class="c1"># Add a new element to the end of the list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>         <span class="c1"># Prints "[3, 1, 'foo', 'bar']"</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>      <span class="c1"># Remove and return the last element of the list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>      <span class="c1"># Prints "bar [3, 1, 'foo']"  </span>
</pre></div>

<p>Как обычно, вы можете найти подробности о <a href="https://docs.python.org/3.9/tutorial/datastructures.html#more-on-lists">списках в документации</a>.  </p>
<p><strong>Разрезание на ломтики</strong>: В дополнение к доступу к элементам списка по одному, <em>python</em> предоставляет лаконичный синтаксис для доступа к подспискам; Это называется нарезкой:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>     <span class="c1"># range is a built-in function that creates a list of integers</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>               <span class="c1"># Prints "[0, 1, 2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>          <span class="c1"># Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>           <span class="c1"># Get a slice from index 2 to the end; prints "[2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>           <span class="c1"># Get a slice from the start to index 2 (exclusive); prints "[0, 1]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:])</span>            <span class="c1"># Get a slice of the whole list; prints "[0, 1, 2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>          <span class="c1"># Slice indices can be negative; prints "[0, 1, 2, 3]"</span>
<span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>        <span class="c1"># Assign a new sublist to a slice</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>               <span class="c1"># Prints "[0, 1, 8, 9, 4]" </span>
</pre></div>

<p>Мы снова увидим нарезку в контексте массивов numpy.  </p>
<p><strong>Петли</strong>: Вы можете перебирать элементы списка следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
<span class="c1"># Prints "cat", "dog", "monkey", each on its own line.</span>
</pre></div>

<p>Если вы хотите получить доступ к индексу каждого элемента в теле цикла, воспользуйтесь встроенной функцией:<code>enumerate</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">animal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">animals</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'#</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">animal</span><span class="p">))</span>
<span class="c1"># Prints "#1: cat", "#2: dog", "#3: monkey", each on its own line  </span>
</pre></div>

<p><strong>Список включений</strong>: при программировании мы часто хотим преобразовать один тип данных в другой. В качестве простого примера рассмотрим следующий код, который вычисляет квадратные числа:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># Prints [0, 1, 4, 9, 16]</span>
</pre></div>

<p>Вы можете упростить этот код с помощью <strong>спискового понимания</strong>:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># Prints [0, 1, 4, 9, 16]</span>
</pre></div>

<p>Включения списка также могут содержать условия:    </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">even_squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">even_squares</span><span class="p">)</span>  <span class="c1"># Prints "[0, 4, 16]"</span>
</pre></div>

<h4>Словари</h4>
<p>Словарь хранит пары (ключ, значение), аналогично <code>Map</code> в <em>Java</em> или объекту в <em>Javascript</em>. Вы можете использовать его следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">:</span> <span class="s1">'cute'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">:</span> <span class="s1">'furry'</span><span class="p">}</span>  <span class="c1"># Create a new dictionary with some data</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'cat'</span><span class="p">])</span>       <span class="c1"># Get an entry from a dictionary; prints "cute"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'cat'</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>     <span class="c1"># Check if a dictionary has a given key; prints "True"</span>
<span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'wet'</span>     <span class="c1"># Set an entry in a dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">])</span>      <span class="c1"># Prints "wet"</span>
<span class="c1"># print(d['monkey'])  # KeyError: 'monkey' not a key of d</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'monkey'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span>  <span class="c1"># Get an element with a default; prints "N/A"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span>    <span class="c1"># Get an element with a default; prints "wet"</span>
<span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">]</span>         <span class="c1"># Remove an element from a dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span> <span class="c1"># "fish" is no longer a key; prints "N/A"</span>
</pre></div>

<p>Все, что вам нужно знать о словарях, вы можете найти <a href="https://docs.python.org/3.9/library/stdtypes.html#dict">в документации</a>.  </p>
<p><strong>Петли</strong>: Перебирать ключи в словаре очень просто:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'person'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'spider'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">animal</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'A </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> legs'</span> <span class="o">%</span> <span class="p">(</span><span class="n">animal</span><span class="p">,</span> <span class="n">legs</span><span class="p">))</span>
<span class="c1"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs" </span>
</pre></div>

<p>Если вы хотите получить доступ к ключам и их соответствующим значениям, используйте метод:<code>items</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'person'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'spider'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="k">for</span> <span class="n">animal</span><span class="p">,</span> <span class="n">legs</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'A </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> legs'</span> <span class="o">%</span> <span class="p">(</span><span class="n">animal</span><span class="p">,</span> <span class="n">legs</span><span class="p">))</span>
<span class="c1"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs"</span>
</pre></div>

<p><strong>Словарное понимание</strong>: Они похожи на включения списков, но позволяют легко создавать cловари. Например:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">even_num_to_square</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">even_num_to_square</span><span class="p">)</span>  <span class="c1"># Prints "{0: 0, 2: 4, 4: 16}"</span>
</pre></div>

<h4>Наборы</h4>
<p>Наборы — это неупорядоченное множество отдельных элементов. В качестве простого примера рассмотрим следующее:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'cat'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>   <span class="c1"># Check if an element is in a set; prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'fish'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>  <span class="c1"># prints "False"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">)</span>       <span class="c1"># Add an element to a set</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'fish'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>  <span class="c1"># Prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Number of elements in a set; prints "3"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)</span>        <span class="c1"># Adding an element that is already in the set does nothing</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Prints "3"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)</span>     <span class="c1"># Remove an element from a set</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Prints "2"</span>
</pre></div>

<p>Как обычно, все, что вы хотите знать о множествах, можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#set">в документации</a>.  </p>
<p><strong>Петли</strong>: Перебор набора имеет тот же синтаксис, что и перебор списка; 
Однако, поскольку наборы не упорядочены, вы не можете делать предположения о порядке, в которых вы посещаете элементы набора:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'fish'</span><span class="p">}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">animal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">animals</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'#</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">animal</span><span class="p">))</span>
<span class="c1"># Prints "#1: fish", "#2: dog", "#3: cat"  </span>
</pre></div>

<p><strong>Набор понятий</strong>: подобно спискам и словарям, мы можем легко создавать наборы, используя включения множеств:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># Prints "{0, 1, 2, 3, 4, 5}"</span>
</pre></div>

<h4>Кортежи</h4>
<p>Кортеж — это (<em>неизменяемый</em>) упорядоченный список значений. Кортеж во многом похож на список; Одним из наиболее важных отличий является то, что кортежи можно использовать как ключи в словарях и как элементы множеств, а списки — нет. Вот банальный пример:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>  <span class="c1"># Create a dictionary with tuple keys</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>        <span class="c1"># Create a tuple</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>    <span class="c1"># Prints "&lt;class 'tuple'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>       <span class="c1"># Prints "5"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># Prints "1"</span>
</pre></div>

<p><a href="https://docs.python.org/3.9/tutorial/datastructures.html#tuples-and-sequences">В документации</a> есть больше информации о кортежах.  </p>
<h3>Функции</h3>
<p>Функции python определяются с помощью ключевого слова. Например:<code>def</code>  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'positive'</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'negative'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'zero'</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># Prints "negative", "zero", "positive"</span>
</pre></div>

<p>Мы часто определяем функции, принимающие необязательные аргументы ключевых слов, например:  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">loud</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'HELLO, </span><span class="si">%s</span><span class="s1">!'</span> <span class="o">%</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Hello, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="n">hello</span><span class="p">(</span><span class="s1">'Bob'</span><span class="p">)</span> <span class="c1"># Prints "Hello, Bob"</span>
<span class="n">hello</span><span class="p">(</span><span class="s1">'Fred'</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Prints "HELLO, FRED!" </span>
</pre></div>

<p>В <a href="https://docs.python.org/3.9/tutorial/controlflow.html#defining-functions">документации</a> есть гораздо больше информации о функциях <em>python</em>.  </p>
<h4>Классы</h4>
<p>Синтаксис для определения классов в <em>python</em> прост:  </p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Greeter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># Constructor</span>
    <span class="k">def</span><span class="w"> </span><span class="o">**</span><span class="n">init</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># Create an instance variable</span>

    <span class="c1"># Instance method</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loud</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'HELLO, </span><span class="si">%s</span><span class="s1">!'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'Hello, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">Greeter</span><span class="p">(</span><span class="s1">'Fred'</span><span class="p">)</span>  <span class="c1"># Construct an instance of the Greeter class</span>
<span class="n">g</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>            <span class="c1"># Call an instance method; prints "Hello, Fred"</span>
<span class="n">g</span><span class="o">.</span><span class="n">greet</span><span class="p">(</span><span class="n">loud</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   <span class="c1"># Call an instance method; prints "HELLO, FRED!"</span>
</pre></div>

<p>Вы можете прочитать гораздо больше о классах <em>python</em> <a href="https://docs.python.org/3.9/tutorial/classes.html">в документации</a>.  </p>
<h2>Numpy</h2>
<p><a href="http://www.numpy.org/">Numpy</a> — это основная библиотека для научных вычислений на языке <em>python</em>. Она предоставляет высокопроизводительный многомерный массив объектов и инструменты для работы с ними Массивы. Если вы уже знакомы с <em>MATLAB</em>, <a href="https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users.html">то этот урок может быть вам полезен</a> для начала работы с <em>Numpy</em>.  </p>
<h3>Массивы</h3>
<p>Массив numpy представляет собой сетку значений одного и того же типа, индексирующую кортежем неотрицательные целые числа. Количество измерений — это ранг массива; Форма массива представляет собой кортеж целых чисел, задающий размер массива вдоль каждого измерения.  </p>
<p>Мы можем инициализировать массивы <em>numpy</em> из вложенных списков <em>python</em>, и получить доступ к элементам с помощью квадратных скобок:  </p>
<div class="code"><pre class="code literal-block"> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>   <span class="c1"># Create a rank 1 array</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>            <span class="c1"># Prints "&lt;class 'numpy.ndarray'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>            <span class="c1"># Prints "(3,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>   <span class="c1"># Prints "1 2 3"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>                  <span class="c1"># Change an element of the array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                  <span class="c1"># Prints "[5, 2, 3]"</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>    <span class="c1"># Create a rank 2 array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                     <span class="c1"># Prints "(2, 3)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>   <span class="c1"># Prints "1 2 4"  </span>
</pre></div>

<p><em>Numpy</em> также предоставляет множество функций для создания массивов:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>   <span class="c1"># Create an array of all zeros</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>              <span class="c1"># Prints "[[ 0.  0.]</span>
                      <span class="c1">#          [ 0.  0.]]"</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>    <span class="c1"># Create an array of all ones</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>              <span class="c1"># Prints "[[ 1.  1.]]"</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>  <span class="c1"># Create a constant array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>               <span class="c1"># Prints "[[ 7.  7.]</span>
                       <span class="c1">#          [ 7.  7.]]"</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1"># Create a 2x2 identity matrix</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>              <span class="c1"># Prints "[[ 1.  0.]</span>
                      <span class="c1">#          [ 0.  1.]]"</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Create an array filled with random values</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>                     <span class="c1"># Might print "[[ 0.91940167  0.08143941]</span>
                             <span class="c1">#               [ 0.68744134  0.87236687]]"</span>
</pre></div>

<p><strong>О других способах создания массивов вы можете прочитать</strong> <a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation">в документации</a>.</p>
<h3>Индексация массивов</h3>
<p><em>Numpy</em> предлагает несколько способов индексации в массивы.  </p>
<p><strong>Разрезание на ломтики</strong>: как и в случае со списками <em>python</em>, массивы numpy могут быть разделены на срезы. Поскольку массивы могут быть многомерными, необходимо указать срез для каждого измерения массива:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create the following rank 2 array with shape (3, 4)</span>
<span class="c1"># [[ 1  2  3  4]</span>
<span class="c1">#  [ 5  6  7  8]</span>
<span class="c1">#  [ 9 10 11 12]]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>

<span class="c1"># Use slicing to pull out the subarray consisting of the first 2 rows</span>
<span class="c1"># and columns 1 and 2; b is the following array of shape (2, 2):</span>
<span class="c1"># [[2 3]</span>
<span class="c1">#  [6 7]]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

<span class="c1"># A slice of an array is a view into the same data, so modifying it</span>
<span class="c1"># will modify the original array.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># Prints "2"</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">77</span>     <span class="c1"># b[0, 0] is the same piece of data as a[0, 1]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># Prints "77"</span>
</pre></div>

<p>Вы также можете сочетать целочисленное индексирование с индексированием срезов. Однако это приведет к получению массива более низкого ранга, чем исходный массив. Обратите внимание, что это сильно отличается от способа, которым <em>MATLAB</em> работает с массивами при разрезании на ломтики:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create the following rank 2 array with shape (3, 4)</span>
<span class="c1"># [[ 1  2  3  4]</span>
<span class="c1">#  [ 5  6  7  8]</span>
<span class="c1">#  [ 9 10 11 12]]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>

<span class="c1"># Two ways of accessing the data in the middle row of the array.</span>
<span class="c1"># Mixing integer indexing with slices yields an array of lower rank,</span>
<span class="c1"># while using only slices yields an array of the same rank as the</span>
<span class="c1"># original array:</span>
<span class="n">row_r1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>    <span class="c1"># Rank 1 view of the second row of a</span>
<span class="n">row_r2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># Rank 2 view of the second row of a</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_r1</span><span class="p">,</span> <span class="n">row_r1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[5 6 7 8] (4,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_r2</span><span class="p">,</span> <span class="n">row_r2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[[5 6 7 8]] (1, 4)"</span>

<span class="c1"># We can make the same distinction when accessing columns of an array:</span>
<span class="n">col_r1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">col_r2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">col_r1</span><span class="p">,</span> <span class="n">col_r1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[ 2  6 10] (3,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">col_r2</span><span class="p">,</span> <span class="n">col_r2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2]</span>
                             <span class="c1">#          [ 6]</span>
                             <span class="c1">#          [10]] (3, 1)"</span>
</pre></div>

<p><strong>Индексация целочисленного массива</strong>: Когда вы индексируете массивы <em>numpy</em> с помощью слайсинга, результирующее представление массива всегда будет подмассивом исходного массива. В противоположность этому, индексация целочисленного массива позволяет создавать произвольные массивы, используя данные из другого массива. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="c1"># An example of integer array indexing.</span>
<span class="c1"># The returned array will have shape (3,) and</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># Prints "[1 4 5]"</span>

<span class="c1"># The above example of integer array indexing is equivalent to this:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>  <span class="c1"># Prints "[1 4 5]"</span>

<span class="c1"># When using integer array indexing, you can reuse the same</span>
<span class="c1"># element from the source array:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Prints "[2 2]"</span>

<span class="c1"># Equivalent to the previous integer array indexing example</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>  <span class="c1"># Prints "[2 2]"</span>
</pre></div>

<p>Одним из полезных приемов при индексации целочисленных массивов является выбор или изменение в одногм из них каждой строки матрицы:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create a new array from which we will select elements</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># prints "array([[ 1,  2,  3],</span>
          <span class="c1">#                [ 4,  5,  6],</span>
          <span class="c1">#                [ 7,  8,  9],</span>
          <span class="c1">#                [10, 11, 12]])"</span>

<span class="c1"># Create an array of indices</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># Select one element from each row of a using the indices in b</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">])</span>  <span class="c1"># Prints "[ 1  6  7 11]"</span>

<span class="c1"># Mutate one element from each row of a using the indices in b</span>
<span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># prints "array([[11,  2,  3],</span>
          <span class="c1">#                [ 4,  5, 16],</span>
          <span class="c1">#                [17,  8,  9],</span>
          <span class="c1">#                [10, 21, 12]])</span>
</pre></div>

<p><strong>Индексация логических массивов</strong>: Логическое индексирование массива позволяет выделять произвольные элементы массива. Часто этот тип индексации используется для выбора элементов массива которые удовлетворяют какому-либо условию. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="n">bool_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Find the elements of a that are bigger than 2;</span>
                     <span class="c1"># this returns a numpy array of Booleans of the same</span>
                     <span class="c1"># shape as a, where each slot of bool_idx tells</span>
                     <span class="c1"># whether that element of a is &gt; 2.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">bool_idx</span><span class="p">)</span>      <span class="c1"># Prints "[[False False]</span>
                     <span class="c1">#          [ True  True]</span>
                     <span class="c1">#          [ True  True]]"</span>

<span class="c1"># We use boolean array indexing to construct a rank 1 array</span>
<span class="c1"># consisting of the elements of a corresponding to the True values</span>
<span class="c1"># of bool_idx</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">bool_idx</span><span class="p">])</span>  <span class="c1"># Prints "[3 4 5 6]"</span>

<span class="c1"># We can do all of the above in a single concise statement:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>     <span class="c1"># Prints "[3 4 5 6]"</span>
</pre></div>

<p>Для краткости мы опустили много подробностей об индексации массива <em>numpy</em>; Если вы хотите узнать больше, вам следует <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html">прочитать документацию</a>.  </p>
<h3>Типы данных</h3>
<p>Каждый массив <em>numpy</em> представляет собой сетку элементов одного типа. <em>Numpy</em> предоставляет большой набор числовых типов данных, которые можно использовать для создания массивов. <em>Numpy</em> пытается определить тип данных при создании массива, но функции, создающие массивы, обычно также включают необязательный аргумент для явного указания типа данных. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>   <span class="c1"># Let numpy choose the datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>         <span class="c1"># Prints "int64"</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>   <span class="c1"># Let numpy choose the datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>             <span class="c1"># Prints "float64"</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>   <span class="c1"># Force a particular datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>                         <span class="c1"># Prints "int64"</span>
</pre></div>

<p>Вы можете прочитать все о типах данных <em>numpy</em> <a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html">в документации</a>.</p>
<h3>Математические операции с массивами</h3>
<p>Основные математические функции работают с массивами поэлементно и доступны как в виде перегрузок операторов, так и в виде функций в модуле <em>numpy</em>:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="c1"># Elementwise sum; both produce the array</span>
<span class="c1"># [[ 6.0  8.0]</span>
<span class="c1">#  [10.0 12.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise difference; both produce the array</span>
<span class="c1"># [[-4.0 -4.0]</span>
<span class="c1">#  [-4.0 -4.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise product; both produce the array</span>
<span class="c1"># [[ 5.0 12.0]</span>
<span class="c1">#  [21.0 32.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise division; both produce the array</span>
<span class="c1"># [[ 0.2         0.33333333]</span>
<span class="c1">#  [ 0.42857143  0.5       ]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise square root; produces the array</span>
<span class="c1"># [[ 1.          1.41421356]</span>
<span class="c1">#  [ 1.73205081  2.        ]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>Обратите внимание, что в отличие от <em>MATLAB</em>,<code>*</code>- это поэлементное умножение, а не матрица умножение. Вместо этого мы используем функцию <code>dot</code> для вычисления скалярного произведения векторов, умножить вектор на матрицу, и умножения матриц. <code>dot</code> доступен как функция в numpy и в качестве экземпляра метода объектов массива:    </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="c1"># Inner product of vectors; both produce 219</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

<span class="c1"># Matrix / vector product; both produce the rank 1 array [29 67]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="c1"># Matrix / matrix product; both produce the rank 2 array</span>
<span class="c1"># [[19 22]</span>
<span class="c1">#  [43 50]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>

<p><em>Numpy</em> предоставляет множество полезных функций для выполнения вычислений на массивах; Одной из самых полезных является:<code>sum</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># Compute sum of all elements; prints "10"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># Compute sum of each column; prints "[4 6]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Compute sum of each row; prints "[3 7]"</span>
</pre></div>

<p>Полный список математических функций, предоставляемых <em>numpy</em>, вы можете найти <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">в документации</a>.</p>
<p>Помимо вычисления математических функций с помощью массивов, мы часто должны изменять форму данных в массивах или иным образом манипулировать ими. Самый простой пример. Одним из таких видов операции является транспонирование матрицы; для транспонирования матрицы, просто используйте атрибут <code>T</code> объекта массива:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1"># Prints "[[1 2]</span>
            <span class="c1">#          [3 4]]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Prints "[[1 3]</span>
            <span class="c1">#          [2 4]]"</span>

<span class="c1"># Note that taking the transpose of a rank 1 array does nothing:</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>    <span class="c1"># Prints "[1 2 3]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Prints "[1 2 3]"</span>
</pre></div>

<p><em>Numpy</em> предоставляет гораздо больше функций для работы с массивами; С полным списком можно ознакомиться <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">в документации</a>.</p>
<h3>Вещание</h3>
<p><strong>Вещание</strong> - это мощный механизм, который позволяет <em>numpy</em> работать с массивами различных фигур при выполнении арифметических действий. Часто у нас есть меньший массив и больший массив, и мы хотим использовать меньший массив несколько раз для выполнения какой-либо операции на более крупном массиве.  </p>
<p>Например, предположим, что мы хотим добавить вектор константы к каждой строке матрицы. Мы могли бы сделать это следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># Create an empty matrix with the same shape as x</span>

<span class="c1"># Add the vector v to each row of the matrix x with an explicit loop</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">v</span>

<span class="c1"># Now y is the following</span>
<span class="c1"># [[ 2  2  4]</span>
<span class="c1">#  [ 5  5  7]</span>
<span class="c1">#  [ 8  8 10]</span>
<span class="c1">#  [11 11 13]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> 
</pre></div>

<p>Это работает, однако, когда матрица <code>x</code> очень большая, вычисление явного цикла в <em>python</em> может быть медленным. Обратите внимание, что добавление вектора <code>v</code> к каждой строке матрицы <code>x</code> эквивалентно формированию матрицы <code>vv</code> путем наложения нескольких копий <code>v</code> по вертикали, затем выполнение поэлементного суммирования <code>x</code> и <code>vv</code> мы могли бы реализовать этот подход следующим образом:        </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1"># Stack 4 copies of v on top of each other</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>                 <span class="c1"># Prints "[[1 0 1]</span>
                          <span class="c1">#          [1 0 1]</span>
                          <span class="c1">#          [1 0 1]</span>
                          <span class="c1">#          [1 0 1]]"</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">vv</span>  <span class="c1"># Add x and vv elementwise</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2  2  4</span>
          <span class="c1">#          [ 5  5  7]</span>
          <span class="c1">#          [ 8  8 10]</span>
          <span class="c1">#          [11 11 13]]"</span>
</pre></div>

<p>Массивы Numpy позволяют выполнять вычисления без фактического создания нескольких копий <code>v</code>. Рассмотрим эту версию с использованием массивов:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span>  <span class="c1"># Add v to each row of x using broadcasting</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2  2  4]</span>
          <span class="c1">#          [ 5  5  7]</span>
          <span class="c1">#          [ 8  8 10]</span>
          <span class="c1">#          [11 11 13]]"</span>
</pre></div>

<p>Строка <code>y = x + v</code> работает, несмотря на то, что <code>x</code> имеет форму  <code>(4, 3)</code>и <code>v</code> имеет форму <code>(3,)</code> благодаря вещанию; Эта линия работает так, как будто <code>v</code> на самом деле имеет форму <code>(4, 3)</code>, где каждая строка была копией , а сумма <code>v</code> выполнялась по элементам.     </p>
<p>Трансляция двух массивов одновременно выполняется по следующим правилам:
1. Если массивы имеют разный ранг, добавьте в начало форму массива с меньшим рангом с <strong>1s</strong> до тех пор, пока обе фигуры не будут иметь одинаковую длину.
2. Два массива считаются <em>совместимыми</em> в размерности, если они имеют одинаковое значение size в измерении, или если один из массивов имеет размер <strong>1</strong> в этом измерении.
3. Массивы могут транслироваться вместе, если они совместимы во всех измерениях.
4. После трансляции каждый массив ведет себя так, как если бы он имел форму, равную поэлементной максимальное количество форм двух входных массивов.
5. В любом измерении, где один массив имеет размер <strong>1</strong>, а другой массив больше <strong>1</strong>, первый массив ведет себя так, как если бы он был скопирован по этому размеру  </p>
<p>Если это объяснение не имеет смысла, попробуйте прочитать объяснение <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">из документации</a> или <a href="https://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">это объяснение</a>.  </p>
<p>Функции, поддерживающие широковещательную рассылку, называются <em>универсальными функциями</em>. Вы можете найти Список всех универсальных функций <a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">в документации</a>.  </p>
<p>Вот некоторые области применения вещания:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Compute outer product of vectors</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># v has shape (3,)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>    <span class="c1"># w has shape (2,)</span>
<span class="c1"># To compute an outer product, we first reshape v to be a column</span>
<span class="c1"># vector of shape (3, 1); we can then broadcast it against w to yield</span>
<span class="c1"># an output of shape (3, 2), which is the outer product of v and w:</span>
<span class="c1"># [[ 4  5]</span>
<span class="c1">#  [ 8 10]</span>
<span class="c1">#  [12 15]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>

<span class="c1"># Add a vector to each row of a matrix</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="c1"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span>
<span class="c1"># giving the following matrix:</span>
<span class="c1"># [[2 4 6]</span>
<span class="c1">#  [5 7 9]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

<span class="c1"># Add a vector to each column of a matrix</span>
<span class="c1"># x has shape (2, 3) and w has shape (2,).</span>
<span class="c1"># If we transpose x then it has shape (3, 2) and can be broadcast</span>
<span class="c1"># against w to yield a result of shape (3, 2); transposing this result</span>
<span class="c1"># yields the final result of shape (2, 3) which is the matrix x with</span>
<span class="c1"># the vector w added to each column. Gives the following matrix:</span>
<span class="c1"># [[ 5  6  7]</span>
<span class="c1">#  [ 9 10 11]]</span>
<span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="c1"># Another solution is to reshape w to be a column vector of shape (2, 1);</span>
<span class="c1"># we can then broadcast it directly against x to produce the same</span>
<span class="c1"># output.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1"># Multiply a matrix by a constant:</span>
<span class="c1"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span>
<span class="c1"># these can be broadcast together to shape (2, 3), producing the</span>
<span class="c1"># following array:</span>
<span class="c1"># [[ 2  4  6]</span>
<span class="c1">#  [ 8 10 12]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  
</pre></div>

<p>Широковещательная рассылка обычно делает ваш код более кратким и быстрым, поэтому вы должен стремиться использовать ее там, где это возможно.  </p>
<h3>Документация Numpy</h3>
<p>Этот краткий обзор затронул многие важные вещи, которые вам необходимо знать о <em>numpy</em>, но далеко не полны. Ознакомьтесь <a href="http://docs.scipy.org/doc/numpy/reference/">со справочником numpy</a>, чтобы узнать больше о numpy.</p>
<h2>SciPy</h2>
<p><em>Numpy</em> предоставляет высокопроизводительный многомерный массив и основные инструменты для выполняйте вычисления с помощью этих массивов и управляйте ими. 
<a href="http://docs.scipy.org/doc/scipy/reference/">SciPy</a> опирается на это и предоставляет большое количество функций, которые работают с массивами <em>numpy</em> и полезны для различных видов научных и инженерных приложений.  </p>
<p>Лучший способ познакомиться с <em>SciPy</em> - <a href="http://docs.scipy.org/doc/scipy/reference/index.html">это просмотреть документацию</a>. 
Мы выделим некоторые части <em>SciPy</em>, которые могут быть вам полезны для этого класса.</p>
<h3>Операции с изображениями</h3>
<p><em>SciPy</em> предоставляет некоторые основные функции для работы с изображениями. 
Например, в нем есть функции чтения изображений с диска в массивы <em>numpy</em>, для записи массивов <em>numpy</em> на диск в виде изображений, а также для изменения размера изображений. 
Вот простой пример, демонстрирующий эти функции:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">imread</span><span class="p">,</span> <span class="n">imsave</span><span class="p">,</span> <span class="n">imresize</span>

<span class="c1"># Read an JPEG image into a numpy array</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">'assets/cat.jpg'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "uint8 (400, 248, 3)"</span>

<span class="c1"># We can tint the image by scaling each of the color channels</span>
<span class="c1"># by a different scalar constant. The image has shape (400, 248, 3);</span>
<span class="c1"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span>
<span class="c1"># numpy broadcasting means that this leaves the red channel unchanged,</span>
<span class="c1"># and multiplies the green and blue channels by 0.95 and 0.9</span>
<span class="c1"># respectively.</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

<span class="c1"># Resize the tinted image to be 300 by 300 pixels.</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">imresize</span><span class="p">(</span><span class="n">img_tinted</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>

<span class="c1"># Write the tinted image back to disk</span>
<span class="n">imsave</span><span class="p">(</span><span class="s1">'assets/cat_tinted.jpg'</span><span class="p">,</span> <span class="n">img_tinted</span><span class="p">)</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/cat.jpg"><br><img alt="" src="https://cs231n.github.io/assets/cat_tinted.jpg"><br><strong>Сверху</strong>: исходное изображение. <strong>Снизу</strong>: Затемненное изображение с измененным размером.  </p>
<h3>Файлы MATLAB</h3>
<p>Функции <code>scipy.io.loadmat</code> и <code>scipy.io.savemat</code> позволяют считывать и писать файлы <em>MATLAB</em>. О них можно прочитать в <a href="http://docs.scipy.org/doc/scipy/reference/io.html">документации</a>.</p>
<h3>Расстояние между точками</h3>
<p><em>SciPy</em> определяет некоторые полезные функции для вычисления расстояний между наборами точек.  </p>
<p>Функция <code>scipy.spatial.distance.pdist</code> вычисляет расстояние между всеми парами точек в заданном наборе:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>

<span class="c1"># Create the following array where each row is a point in 2D space:</span>
<span class="c1"># [[0 1]</span>
<span class="c1">#  [1 0]</span>
<span class="c1">#  [2 0]]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Compute the Euclidean distance between all rows of x.</span>
<span class="c1"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span>
<span class="c1"># and d is the following array:</span>
<span class="c1"># [[ 0.          1.41421356  2.23606798]</span>
<span class="c1">#  [ 1.41421356  0.          1.        ]</span>
<span class="c1">#  [ 2.23606798  1.          0.        ]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">'euclidean'</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>

<p>Все подробности об этой функции вы можете прочитать в <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">документации</a>.  </p>
<p>Аналогичная функция (<code>scipy.spatial.distance.cdist</code>) вычисляет расстояние между всеми парами по двум группам точек; Вы можете прочитать об этом <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">в документации</a> .</p>
<h2>Matplotlib</h2>
<p><a href="http://matplotlib.org/">Matplotlib</a> — библиотека для построения графиков. В этом разделе дается краткое введение в модуль <code>matplotlib.pyplot</code>, который обеспечивает систему построения графиков, аналогичную системе <em>MATLAB</em>.</p>
<h3>Постоение графиков</h3>
<p>Наиболее важной функцией в <em>matplotlib</em> является <code>plot</code>, что позволяет строить графики <em>2D</em> данных. Вот простой пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on a sine curve</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Plot the points using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># You must call plt.show() to make graphics appear.</span>
</pre></div>

<p>Выполнение этого кода создает следующий график:  </p>
<p><img alt="" src="https://cs231n.github.io/assets/sine.png"></p>
<p>Приложив немного дополнительной работы, мы можем легко построить несколько линий и добавить заголовок, легенду и подписи осям:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on sine and cosine curves</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Plot the points using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_sin</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_cos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'x axis label'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'y axis label'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Sine and Cosine'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'Sine'</span><span class="p">,</span> <span class="s1">'Cosine'</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/sine_cosine.png"></p>
<p>Гораздо больше о функции <code>plot</code> вы можете прочитать <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot">в документации</a>.</p>
<h3>Подзаголовки</h3>
<p>С помощью <code>subplot</code> функции на одном и том же рисунке можно изобразить разные объекты. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on sine and cosine curves</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Set up a subplot grid that has height 2 and width 1,</span>
<span class="c1"># and set the first such subplot as active.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Make the first plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_sin</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Sine'</span><span class="p">)</span>

<span class="c1"># Set the second subplot as active, and make the second plot.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_cos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Cosine'</span><span class="p">)</span>

<span class="c1"># Show the figure.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/sine_cosine_subplot.png"></p>
<p>Гораздо больше о функции <code>subplot</code> вы можете прочитать <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot">в документации</a>.</p>
<h3>Изображения</h3>
<p>Вы можете использовать функцию <code>imshow</code> для показа изображений. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">imread</span><span class="p">,</span> <span class="n">imresize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">'assets/cat.jpg'</span><span class="p">)</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

<span class="c1"># Show the original image</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="c1"># Show the tinted image</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># A slight gotcha with imshow is that it might give strange results</span>
<span class="c1"># if presented with data that is not uint8. To work around this, we</span>
<span class="c1"># explicitly cast the image to uint8 before displaying it.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">img_tinted</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/cat_tinted_imshow.png"></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/software-setup/" class="u-url">Настройка программного обеспечения </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/software-setup/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-01T19:42:16+03:00" itemprop="datePublished" title="2025-03-01 19:42">2025-03-01 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Настройка программного обеспечения</h2>
<p>Для работы с нейросетями можно работать через <a href="https://colab.research.google.com/">Google Colaboratory</a>. Однако, если у вас уже есть хорошая видеокарта (Nvidia) и вы предпочитаете работать локально, здесь вы найдет инструкции по настройке виртуальной среды.<br>
- <a href="posts/software-setup/">Удаленная работа в Google Colaboratory</a><br>
- <a href="posts/software-setup/">Работа локально на вашем компьютере</a><br>
    - <a href="posts/software-setup/">Виртуальная среда Anaconda</a><br>
    - <a href="posts/software-setup/">Python venv</a><br>
    - <a href="posts/software-setup/">Установка пакетов</a>  </p>
<h4>Удаленная работа в Google Colaboratory</h4>
<p><em>Google Colaboratory</em> — это, по сути, комбинация <em>Jupyter notebook</em> и <em>Google Drive</em>. 
Он полностью работает в облаке и поставляется с множеством предустановленных заранее пакетами (например, <em>PyTorch</em> и <em>Tensorflow</em>), поэтому у всех есть доступ к одному и тому же широкому перечню библиотек. 
Кроме того, <em>Google Colab</em> дает бесплатный доступ к аппаратным ускорителям например, <em>K80</em>, <em>P100</em> и TPU (Tensor Processing Unit).  </p>
<p><strong>Требования</strong>. 
Чтобы использовать <em>Colab</em>, у вас должен быть аккаунт <em>Google</em> со связанным <strong>Google диском</strong>. 
Предполагается, что у вас есть и то, и другое, вы можете подключить <em>Colab</em> к <strong>G-drive</strong>, выполнив следующие действия:</p>
<ol>
<li>Нажмите на колесико в правом верхнем углу и выберите <code>Settings</code>.  </li>
<li>Нажмите на вкладку <code>Manage Apps</code>.  </li>
<li>Вверху выберите <code>Connect more apps</code>, что должно вызвать окно <code>GSuite Marketplace</code>.  </li>
<li>Найдите <strong>Colab</strong> и нажмите <code>Add</code>.  </li>
</ol>
<p><strong>Рекомендации</strong>. Есть несколько вещей, о которых вы должны знать при работе с <em>Colab</em>:  </p>
<ol>
<li>
<p>Постоянное наличие ресурсов не гарантировано (это плата за бесплатность).  </p>
</li>
<li>
<p>Если вы бездействуете в течение определенного времени или общее время подключения превышает максимально допустимое время (<em>~12 часов</em>), виртуальная машина <em>Colab</em> будет отключена. Это означает, что любой несохраненный прогресс будет потерян. </p>
</li>
</ol>
<p><font color="red"><strong><br>
Таким образом, выработайте привычку часто сохранять свой код и веса моделей во время работы! 
</strong></font>  </p>
<p>Чтобы узнать больше об ограничениях ресурсов в <em>Colab</em>, ознакомьтесь с их часто задаваемыми вопросами <a href="https://research.google.com/colaboratory/faq.html">здесь</a>.</p>
<p><strong>Использование графического процессора (GPU)</strong>. 
Использовать графический процессор очень просто, нужно просто переключить среду выполнения в <em>Colab</em>. 
Перейдите в настройки по следующему пути: <code>Runtime -&gt; Change runtime type -&gt; Hardware Accelerator -&gt; GPU</code> , и <em>Colab</em> будет автоматически подкреплен вычислительными мощностями графического процессора.  </p>
<p>Если вы хотите узнать больше о <em>Colab</em>, рекомендую вам посетить следующие ресурсы:
- <a href="https://www.youtube.com/watch?v=inN8seMm7UI">Введение в Google Colab</a>
- <a href="https://colab.research.google.com/notebooks/intro.ipynb">Добро пожаловать в Colab</a>
- <a href="https://colab.research.google.com/notebooks/basic_features_overview.ipynb">Обзор функций Colab</a>  </p>
<h4>Работа на локальном компьютере</h4>
<p>Если вы хотите работать локально, вам следует использовать виртуальную среду <code>venv</code>. 
Вы можете установить ее через <em>Anaconda</em> или через модуль <em>python -m venv</em>. </p>
<h5>Виртуальная среда Anaconda</h5>
<p>Бесплатный <a href="https://www.anaconda.com/download/">дистрибутив Anaconda Python</a> предоставляет собой набор пакетов для научных вычислений. 
Приятная вещь в <em>Anaconda</em> заключается в том, что она поставляется с <a href="https://docs.anaconda.com/mkl-optimizations/">оптимизацией MKL</a> по умолчанию, 
Это означает, что ваши библиотеки <code>numpy</code> и <code>scipy</code> код получают значительное ускорение без необходимости изменять ни одной строки кода. </p>
<p>После установки Anaconda имеет смысл создать виртуальную среду для отдельного проекта. 
Если вы не не будете использовать виртуальную среду (<em>настоятельно не рекомендуется!</em>), все зависимости будут установлены глобально на вашем компьютере. 
Чтобы настроить виртуальную среду с именем <code>mldl</code>, выполните следующие действия в терминале:  </p>
<div class="code"><pre class="code literal-block">conda create -n mldl python=3.12
</pre></div>

<p>Чтобы активировать и войти в среду, запустите </p>
<div class="code"><pre class="code literal-block">conda activate mldl
</pre></div>

<p>Чтобы отключить среду, закройте терминал или используйте команду</p>
<div class="code"><pre class="code literal-block">conda deactivate
</pre></div>

<p>Вы можете обратиться к <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">этой странице</a> за более подробными инструкциями по управлению виртуальными средами с помощью Anaconda.  </p>
<h4>Python venv</h4>
<p>Начиная с версии <em>3.3</em>, <em>Python</em> поставляется с облегченным модулем виртуальной среды под названием <a href="https://docs.python.org/3/library/venv.html">venv</a>. 
Каждая виртуальная среда упаковывает свой собственный независимый набор установленных пакетов (библиотек) <em>Python</em>.
Это позволяет изолировать проект от общесистемных пакетов <em>Python</em> и запускать нужную версию <em>Python</em>. 
Чтобы настроить виртуальную среду с именем <code>mldl</code>, выполните команду в терминале:</p>
<div class="code"><pre class="code literal-block">python3.12 -m venv mldl
</pre></div>

<p>Чтобы активировать и войти в среду, запустите <code>source mldl/bin/activate</code>. 
Чтобы отключить среду, запустите в терминале <code>deactivate</code> или выйдите из него. 
Обратите внимание, что каждый раз, когда вы хотите поработать над проектом, вы должны повторно активировать среду. </p>
<h4>Установка пакетов</h4>
<p>После того как вы <strong>настроили</strong> и <strong>активировали</strong> свою виртуальную среду (с помощью <code>conda</code> или <code>venv</code>), вы должны установить библиотеки, необходимые для выполнения назначений с помощью <code>pip</code>. 
Для этого выполните команду:</p>
<div class="code"><pre class="code literal-block">pip install -r requirements.txt  
</pre></div>

<h3>Python IDE</h3>
<p>Использование Ide для работы над проектами очень упрощает создание и настройку python. 
Кроме того, интеграция с Git и другие полезные утилиты позволяют повысить эффективность разработки, не отвлекаясь на рутинные операции. 
Используйте PyCharm, VsCode или любую другую IDE на ваш вкус. 
Мой выбор - VsCode с расширениями (Extentions): Python (Microsoft), Black Formatter, JetBrains IDE KeyMapping. </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/transfer-learning/" class="u-url">Трансфер обучения</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/transfer-learning/" rel="bookmark">
            <time class="published dt-published" datetime="2025-02-14T19:42:16+03:00" itemprop="datePublished" title="2025-02-14 19:42">2025-02-14 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Трансфер обучения</h2>
<p><strong><em>(Эти заметки в настоящее время находятся в черновой форме и находятся в разработке)</em></strong></p>
<p>Содержание:
- <a href="posts/transfer-learning/">Трансферное обучение</a>
- <a href="posts/transfer-learning/">Дополнительные примечания</a></p>
<h3>Трансферное обучение</h3>
<p>На практике очень немногие обучают всю сверточную сеть с нуля (со случайной инициализацией), потому что относительно редко удается иметь набор данных достаточного размера. Вместо этого обычно предварительно обучают <em>ConvNet</em> на очень большом наборе данных (например, <em>ImageNet</em>, который содержит 1,2 миллиона изображений с 1000 категориями), а затем используют ConvNet либо в качестве инициализации, либо в качестве фиксированного экстрактора признаков для интересующей задачи. Три основных сценария трансферного обучения выглядят следующим образом:
- <strong>ConvNet в качестве фиксированного экстрактора признаков</strong>. Возьмите предварительно обученный <em>ConvNet</em> на <em>ImageNet</em>, удалите последний полностью подключенный слой (выходные данные этого слоя представляют собой 1000 баллов класса для другой задачи, такой как <em>ImageNet</em>), а затем обрабатывайте остальную часть <em>ConvNet</em> как фиксированный экстрактор признаков для нового набора данных. В <em>AlexNet</em> это позволило бы вычислить вектор <strong>4096-D</strong> для каждого изображения, содержащего активации скрытого слоя непосредственно перед классификатором. Мы называем эти функции <strong>кодами CNN</strong>. Для производительности важно, чтобы эти коды были <em>ReLUd</em> (т.е. пороговыми на нуле), если они также были пороговыми во время обучения <em>ConvNet</em> на <em>ImageNet</em> (как это обычно бывает). После извлечения кодов <strong>4096-D</strong> для всех изображений обучите линейный классификатор (например, Linear <em>SVM</em> или классификатор Softmax) для нового набора данных.
- <strong>Тонкая настройка ConvNet</strong>. Вторая стратегия заключается не только в замене и переобучении классификатора поверх <em>ConvNet</em> на новом наборе данных, но и в тонкой настройке весов предварительно обученной сети путем продолжения обратного распространения. Можно тонко настроить все уровни <em>ConvNet</em>, или можно оставить некоторые из более ранних уровней фиксированными (из-за опасений переобучения) и выполнить тонкую настройку только некоторой части сети более высокого уровня. Это мотивировано наблюдением, что более ранние функции <em>ConvNet</em> содержат более общие функции (например, детекторы краев или детекторы цветных пятен), которые должны быть полезны для многих задач, но более поздние уровни <em>ConvNet</em> становятся все более специфичными для деталей классов, содержащихся в исходном наборе данных. Например, в случае <em>ImageNet</em>, который содержит множество пород собак, значительная часть репрезентативной мощности <em>ConvNet</em> может быть направлена на функции, специфичные для дифференциации между породами собак.
- <strong>Предварительно обученные модели</strong>. Поскольку обучение современных <em>ConvNet</em> на нескольких графических процессорах <em>ImageNet</em> занимает 2–3 недели, часто можно увидеть, как люди выпускают свои окончательные контрольные точки <em>ConvNet</em> в пользу других пользователей, которые могут использовать сети для тонкой настройки. Например, в библиотеке <em>Caffe</em> есть <a href="https://github.com/BVLC/caffe/wiki/Model-Zoo">Model Zoo</a>, где люди делятся своими сетевыми весами.  </p>
<p><strong>Когда и как проводить тонкую настройку?</strong> Как вы решаете, какой тип переносного обучения вы должны выполнять на новом наборе данных? Это зависит от нескольких факторов, но два наиболее важных из них — это размер нового набора данных (маленький или большой) и его сходство с исходным набором данных (например, похожий на ImageNet с точки зрения содержимого изображений и классов, или сильно отличающийся, например, изображения микроскопа). Помня о том, что объекты <em>ConvNet</em> более универсальны в ранних слоях и более специфичны для исходного набора данных в более поздних слоях, вот некоторые общие эмпирические правила для навигации по <em>4</em> основным сценариям:<br>
1. <em>Новый набор данных имеет небольшой размер и похож на исходный набор данных</em>. Поскольку объем данных невелик, тонкая настройка <em>ConvNet</em> не является хорошей идеей из-за проблем с переобучением. Поскольку данные аналогичны исходным данным, мы ожидаем, что функции более высокого уровня в <em>ConvNet</em> также будут иметь отношение к этому набору данных. Следовательно, лучшей идеей может быть обучение линейного классификатора на кодах <em>CNN</em>.
2. <em>Новый набор данных имеет большой размер и похож на исходный набор данных</em>. Поскольку у нас больше данных, мы можем быть уверены в том, что не переучимся, если попытаемся выполнить тонкую настройку через всю сеть.
3. <em>Новый набор данных небольшой, но сильно отличается от исходного</em>. Поскольку данные невелики, вероятно, лучше всего обучить только линейный классификатор. Поскольку набор данных сильно отличается, возможно, не стоит обучать классификатор с вершины сети, которая содержит больше функций, специфичных для набора данных. Вместо этого, возможно, лучше обучить классификатор <em>SVM</em> от активаций где-то раньше в сети.
4. <em>Новый набор данных имеет большой размер и сильно отличается от исходного набора данных</em>. Поскольку набор данных очень большой, можно ожидать, что мы сможем позволить себе обучить <em>ConvNet</em> с нуля. Однако на практике очень часто все же полезно инициализировать весами из предварительно обученной модели. В этом случае у нас было бы достаточно данных и уверенности для тонкой настройки по всей сети.  </p>
<p><strong>Практические советы</strong>. Есть несколько дополнительных моментов, о которых следует помнить при выполнении <em>Transfer Learning</em>:</p>
<ul>
<li>
<em>Ограничения из предварительно обученных моделей</em>. Обратите внимание, что если вы хотите использовать предварительно обученную сеть, вы можете быть немного ограничены с точки зрения архитектуры, которую вы можете использовать для вашего нового набора данных. Например, вы не можете произвольно удалять слои Conv из предварительно обученной сети. Тем не менее, некоторые изменения просты: благодаря совместному использованию параметров вы можете легко запустить предварительно обученную сеть на изображениях разного пространственного размера. Это ясно видно в случае слоев Conv/Pool, потому что их прямая функция не зависит от пространственного размера входного объема (до тех пор, пока шаги «подходят»). В случае слоев FC это по-прежнему верно, потому что слои FC могут быть преобразованы в сверточный слой: например, в AlexNet окончательный объем пула перед первым слоем <em>FC</em> имеет размер <strong>[6x6x512]</strong>. Следовательно, слой <em>FC</em>, рассматривающий этот объем, эквивалентен наличию сверточного слоя, который имеет размер рецептивного поля 6x6 и применяется с отступом <strong>0</strong>.</li>
<li>
<em>Скорость обучения</em>. Обычно для тонко настраиваемых весов <em>ConvNet</em> используется меньшая скорость обучения по сравнению с весами (случайно инициализированными) для нового линейного классификатора, который вычисляет баллы классов нового набора данных. Это связано с тем, что мы ожидаем, что веса <em>ConvNet</em> относительно хороши, поэтому мы не хотим искажать их слишком быстро и слишком сильно (особенно когда новый линейный классификатор над ними обучается на основе случайной инициализации).  </li>
</ul>
<h3>Дополнительные примечания</h3>
<ul>
<li>
<a href="http://arxiv.org/abs/1403.6382">Готовые функции CNN: A Astounding Baseline for Recognition</a> обучает <em>SVM</em> функциям из предварительно обученного <em>ImageNet</em> <em>ConvNet</em> и сообщает о нескольких современных результатах.</li>
<li>
<a href="http://arxiv.org/abs/1310.1531">DeCAF</a> сообщал об аналогичных выводах в 2013 году. Фреймворк в этой статье (<em>DeCAF</em>) был предшественником библиотеки <em>C++</em> <em>Caffe</em> на основе <em>Python</em>.</li>
<li>
<a href="http://arxiv.org/abs/1411.1792">Насколько переносимы функции в глубоких нейронных сетях?</a> Подробно изучает эффективность обучения переносу, включая некоторые неинтуитивные выводы о коадаптациях слоев.</li>
</ul>
</div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/nlp-za-90-minut/" class="u-url">NLP за 90 минут</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/nlp-za-90-minut/" rel="bookmark">
            <time class="published dt-published" datetime="2023-06-16T11:44:44+03:00" itemprop="datePublished" title="2023-06-16 11:44">2023-06-16 11:44</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Основы обработки естественного языка</h2>
<h4>Вопросы:</h4>
<ol>
<li>Краткая история машинной обработки текстов (5 мин)</li>
<li>Основные определения (5 мин)</li>
<li>Методы предварительной обработки текста (10 мин)</li>
<li>Моделирование языка (языковые модели) (10 мин)</li>
<li>Нейронные сети в NLP (30 мин)</li>
<li>GPT модели (30 мин)</li>
</ol>
<h4>1. Краткая история машинной обработки текстов</h4>
<p><strong>NLP (Natural Language Processing)</strong> - это область науки, которая изучает методы обработки текстов на естественных языках с помощью вычислительных машин. 
Основной акцент в NLP делается на прикладные методы, которые можно реализовать на языке программирования. 
Для вычислительно сложных методов используют языки низкого уровня (С, С++), потому что важна эффективность вычислений. 
Для проведение экспериментов используют языки высокого уровня (python), потому что  для проверки гипотез важна скорость написания кода. 
Сегодня исследователям доступно множество библиотек на python, которые служат оберткой для оптимизированного машинного кода.  </p>
<p>В 1913 году русский математик Андрей Андреевич Марков провел эксперимент по оценке частоты появления разных букв в тексте. 
Он выписал первые 20 000 букв поэмы А. С. Пушкина «Евгений Онегин» в одну длинную строчку из букв, опустив все пробелы и знаки пунктуации. 
Затем он переставил эти буквы в 200 решёток (по 10х10 символов в каждой), и начал подсчитывать гласные звуки в каждой строке и столбце, записывая результаты. 
Марков считал, что большинство явлений происходит по цепочке причинно-следственной связи и зависит от предыдущих результатов. 
Он хотел найти способ моделировать эти события посредством вероятностного анализа. 
Он обнаружил, что для любой буквы текста Пушкина выполнялось правило: если это была гласная, то скорее всего за ней будет стоять согласная, и наоборот.  </p>
<p>В 1950 году в работе "Вычислительные машины и разум" ученый Алан Тьюринг предложил тест разумности для искуственного интеллекта.<br>
Если компьютер сможет провести убедительную беседу с человеком в текстовом режиме, можно будет предположить, что он разумен. </p>
<p>В 1954 году в штаб-квартире корпорации IBM состоялся Джорджтаунский эксперимент — демонстрация возможностей машинного перевода. 
В ходе эксперимента был продемонстрирован полностью автоматический перевод более 60 предложений с русского языка на английский. 
Программа выполнялась на мейнфрейме IBM 701. 
В том же году первый эксперимент по машинному переводу был произведён в Институте точной механики и вычислительной техники АН СССР, на компьютере БЭСМ.  </p>
<p>В 1966 году Джозеф Вейценбаум, работавший в лаборатории ИИ при MIT, разработал первый в мире чатбот "Элиза". 
Пользователь мог ввести некое утверждение или набор утверждений на обычном языке, нажать «ввод», и получить от машины ответ.  </p>
<p>В 1986 Давид Румельхарт разработал базовую концепцию рекуррентной нейросети (recurrent neural network, RNN). 
Этот метод позволял решать такие задачи как распознавание речи и текста.  </p>
<p>В 2017 году группа исследователей Google представила архитектуру трансформера (Transformer), которая позволяет обрабатывать тексты, в которых слова расположены в произвольном порядке. 
В настоящее время трансформеры используются в сервисах многих компаний, включая Яндекс и Google, являются основой для самых современных моделей GPT, Bert и т.д.  </p>
<p>В 2023 году OpenAI опубликовала языковую модель GPT-4, которая легко проходит тест Тьюринга и порождает споры об опасности искусственного интеллекта. </p>
<h4>2. Основные определения</h4>
<p><strong>Символ</strong> - это условный знак каких-либо понятий, идей, явлений. 
Первые наскальные символы обозначали зверей, охоту, солнце и другие предметы, которые отражались в сознании первобытных людей. 
Мы и сегодня часто используем символы эмоджи для отображения своих эмоций и скрытых смыслов. 
У разных народов сформировались свои уникальные алфавиты, которы представляют собой множества допустимых символов для письма.   </p>
<p>У компьютера тоже есть уникальный набор символов, определяемый кодировкой. 
Например, кодировка ASCII (American standard code for information interchange) была стандартизована в 1963 году и определяет символы:<br>
- десятичных цифр;<br>
- латинского алфавита;<br>
- национального алфавита;<br>
- знаков препинания;<br>
- управляющих символов.  </p>
<p>С математической точки зрения алфавит как множество символов обозначается символом $V$.<br>
Всевозможные комбинации символов, образующих конечные слова, в т.ч. состоящие из одного символа и бессмысленные комбинации, образуют множество $V^*$. </p>
<p><strong>Слово</strong> - наименьшая единица языка, служащая для именования предметов, качеств, характеристик, взаимодействий, а также для служебных целей. 
Например слово "Я" состоит всего из одного символа и в русском языке обозначает меня как субъект.<br>
Большинство слов состоят из нескольких символов, связанных в последовательность по определенным правилам. </p>
<p><strong>Язык</strong> - это множество слов, которые несут в себе хоть какой-то смысл. 
Например, слово "тывщштс" не имеет смысла в русском языке, хоть и состоит из символов кириллицы. 
А слово "дом", наоборот, является вполне известным и входит в множество слов русского языка. <br>
Формально язык обозначается символом $L$. В алфавите $V$ язык является подмножеством всех конечных слов $$L \in V^*$$</p>
<p><strong>Текст</strong> - это зафиксированая на материальном носителе человеческая мысль в виде последовательности символов. 
Текст может состоять из одного или нескольких слов. </p>
<h5>Представление текста в компьютере</h5>
<p>Для человека символы, слова и тексты несут в себе определенный смысл. 
Компьютер же работает только с байтами. 
Рассмотрим пример, как реализовано посимвольное кодирование алфавита в кодировке ASCII.</p>
<table class="tg">
<thead><tr>
<th class="tg-0pky">bin</th>
    <th class="tg-0pky">dec</th>
    <th class="tg-0pky">hex</th>
    <th class="tg-0pky">symbol</th>
  </tr></thead>
<tbody>
<tr>
<td class="tg-c3ow">110 0001</td>
    <td class="tg-c3ow">97</td>
    <td class="tg-c3ow">61</td>
    <td class="tg-c3ow">a</td>
  </tr>
<tr>
<td class="tg-c3ow">110 0010</td>
    <td class="tg-c3ow">98</td>
    <td class="tg-c3ow">62</td>
    <td class="tg-c3ow">b</td>
  </tr>
<tr>
<td class="tg-c3ow">110 0011</td>
    <td class="tg-c3ow">99</td>
    <td class="tg-c3ow">63</td>
    <td class="tg-c3ow">c</td>
  </tr>
<tr>
<td class="tg-c3ow">110 1010</td>
    <td class="tg-c3ow">106</td>
    <td class="tg-c3ow">6A</td>
    <td class="tg-c3ow">j</td>
  </tr>
<tr>
<td class="tg-c3ow">110 1011</td>
    <td class="tg-c3ow">107</td>
    <td class="tg-c3ow">6B</td>
    <td class="tg-c3ow">k</td>
  </tr>
</tbody>
</table>
<p><strong>bin</strong> - двоичное представление символа,<br><strong>dec</strong> - представление в десятичной системе счисления,<br><strong>hex</strong> - представление в шестнадцатеричной системе счисления.<br>
С полной таблицей кодировки ASCII можно ознакомиться по <a href="https://en.wikipedia.org/wiki/ASCII#8-bit_codes">ссылке</a>.<br>
Для хранения одного символа латинского алфавита достаточно 7 бит. 
Для хранения одного символа небольшого национального алфавита (например, кириллицы) достаточно 8 бит. 
Для кодировки символов более объемных алфавитов (например, китайского) используют 16 бит или два байта.  <br>
Слова, как и тексты, хранятся в компьютерной памяти в виде последовательности символов. </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/template/" class="u-url">Шаблон для новых постов</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/template/" rel="bookmark">
            <time class="published dt-published" datetime="2022-05-16T17:25:16+03:00" itemprop="datePublished" title="2022-05-16 17:25">2022-05-16 17:25</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Заготовка для создания новых постов</h2>
<p>Текст здесь </p>
<p>$$a^2 + b^2 = c^2$$</p>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="." rel="prev">Новые записи</a></li>
        </ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
