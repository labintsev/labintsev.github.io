<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="Заметки по machine learning, deep learning.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Заметки по ML, DL</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="rss.xml">
<link rel="canonical" href="https://mldl.ru/">
<link rel="next" href="index-2.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]--><link rel="prefetch" href="posts/active-volumetric/" type="text/html">
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/active-volumetric/" class="u-url">Активное стерео и объёмное стереовидение</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/active-volumetric/" rel="bookmark">
            <time class="published dt-published" datetime="2025-10-04T14:00:00+03:00" itemprop="datePublished" title="2025-10-04 14:00">2025-10-04 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h4>Введение</h4>
<p>В классическом стереовидении мы пытаемся определить положение трёхмерной точки в пространстве, используя <strong>соответствующие точки</strong> на двух изображениях. Главная сложность здесь — решить <strong>проблему соответствия</strong>: как понять, что точка на одном изображении соответствует точке на другом?</p>
<p>Эта проблема усложняется тем, что в сцене присутствует множество трёхмерных точек, и нам нужно обработать их все. Сегодня мы рассмотрим альтернативный подход к реконструкции трехмерной сцены. </p>
<h4>1. Активное стерео</h4>
<p>Чтобы решить проблему поиска соответствующих точек, была разработана концепция <strong>активного стерео</strong>. Её суть состоит в том, что вместо одной из камер используется специальный проектор, который взаимодействует с трёхмерной сценой.
Проектор создаёт на объекте специальный узор или проецирует определённую точку, а вторая камера наблюдает за тем, как этот узор отображается на объекте. 
Поскольку мы точно знаем, что и куда проецируем (положение точки, цвет, яркость), нам легко найти соответствующую точку на изображении второй камеры</p>
<p>Главное преимущество активного стерео состоит в том, что оно значительно упрощает решение проблему поиска соответствующих точек. Проектор и камера работают как единая система, создавая особую геометрию, похожую на обычную стереосистему, но с виртуальной проекционной плоскостью вместо второй камеры.</p>
<p>Этот метод особенно эффективен, когда нужно точно определить положение объектов в пространстве, так как мы контролируем проецируемый узор и можем легко отследить его отображение на второй камере.</p>
<p><img alt="Рисунок 1: Система активного стерео" src="https://storage.yandexcloud.net/yahosting/active/1.jpg"></p>
<p><strong>Рисунок 1: Система активного стерео</strong></p>
<p>На рисунке 1 показано, как проектор используется для проецирования точки $p$ из виртуальной плоскости на объект в трёхмерном пространстве, создавая точку в трёхмерном пространстве $P$. Эта трёхмерная точка $P$ должна наблюдаться второй камерой как точка $p'$.</p>
<p>Поскольку мы знаем, что именно проецируем (например, положение точки $p$ в виртуальной плоскости, цвет и интенсивность проекции и так далее), мы можем легко обнаружить соответствующее наблюдение во второй камере $p'$.</p>
<p>Распространённый прием в активном стерео — проецировать из виртуальной плоскости вертикальную полосу $s$ вместо одиночной точки. Этот случай очень похож на случай с точкой, когда линия $s$ проецируется в виде полосы в трёхмерное пространство $S$ и наблюдается камерой как линия $s'$.</p>
<p><img alt="Рисунок 2: Проецирование отрезка" src="https://storage.yandexcloud.net/yahosting/active/2.jpg"></p>
<p><strong>Рисунок 2: Проецирование отрезка</strong></p>
<p>Если проектор и камера расположены параллельно или откалиброваны, мы можем легко обнаружить соответствующие точки, просто пересекая $s'$ с горизонтальными эпиполярными линиями. На основе этих соответствий мы можем использовать методы триангуляции, рассмотренных в предыдущих материалах курса, чтобы восстановить все трёхмерные точки на полосе $S$.</p>
<p>Перемещая линию по сцене и повторяя процесс, мы можем восстановить полную форму всех видимых объектов в сцене.</p>
<p>Обратите внимание, что одно из требований для работы этого алгоритма заключается в том, что проектор и камера должны быть откалиброваны. Активная стереосистема может быть откалибрована с использованием аналогичных техник, как описано в предыдущих заметках.</p>
<p>Сначала мы калибруем камеру с помощью калибровочного устройства. Затем, проецируя известные полосы на калибровочное устройство и используя соответствующие наблюдения в недавно откалиброванной камере, мы можем установить ограничения для оценки внутренних и внешних параметров проектора.</p>
<p>После калибровки эта активная стереоустановка может давать очень точные результаты. В 2000 году Марк Левой и его студенты из Стэнфорда продемонстрировали, что, используя точно настроенный лазерный сканер, они могли восстановить форму скульптуры «Пьета» Микеланджело с субмиллиметровой точностью.</p>
<p>Однако в некоторых случаях наличие точно настроенного проектора может быть слишком дорогим или неудобным. Альтернативный подход, который использует гораздо более дешёвую установку, использует тени для создания активных паттернов на объекте, который мы хотим восстановить.</p>
<p>Размещая палочку между объектом и источником света в известном положении, мы можем эффективно проецировать полосу на объект, как и раньше. Перемещение палочки позволяет нам проецировать различные теневые полосы на объект и восстанавливать объект аналогичным образом, как и раньше.</p>
<p>Этот метод, хотя и намного дешевле, имеет тенденцию давать менее точные результаты, поскольку требует очень хорошей калибровки между палочкой, камерой и источником света, при этом необходимо поддерживать компромисс между длиной и тонкостью тени палочки.</p>
<p><img alt="Рисунок 3: Активное стерео с цветными отрезками" src="https://storage.yandexcloud.net/yahosting/active/3.jpg"></p>
<p>Одно из ограничений проецирования единственной полосы на объекты заключается в том, что этот метод довольно медленный, поскольку проектору необходимо охватить весь объект с разных ракурсов. Более того, это означает, что данный метод не может фиксировать деформации в режиме реального времени.</p>
<p>Естественное развитие этой идеи — попытка восстановить объект путём проецирования одного кадра или изображения вместо последовательного сканирования. Суть заключается в проецировании известного узора из различных полос на весь видимый участок объекта, а не одной полосы.</p>
<p>Цвета этих полос разработаны таким образом, чтобы их можно было однозначно идентифицировать на изображении. Рисунок 3 иллюстрирует этот метод с использованием множества цветных полос. Эта концепция легла в основу многих современных датчиков глубины, например, оригинальной версии Microsoft Kinect.</p>
<p>На практике такие датчики используют инфракрасные лазерные проекторы, которые позволяют захватывать трёхмерные видеоданные при любых условиях внешней освещённости.</p>
<p>### 2. Методы объёмного стереовидения </p>
<p>Альтернативой как традиционному стереовидению, так и активному стерео является объёмное стереовидение, которое переворачивает проблему использования соответствующих точек для восстановления трёхмерной структуры.</p>
<p><img alt="Рисунок 4: Основная идея объемного стереовидения - поиск точки в известном объеме" src="https://storage.yandexcloud.net/yahosting/active/4.jpg"></p>
<p><strong>Рисунок 4: Основная идея объемного стереовидения - поиск точки в известном объеме</strong></p>
<p>В объёмном стереовидении мы предполагаем, что трёхмерная точка, которую мы пытаемся оценить, находится в некотором ограниченном, известном объёме. Затем мы проецируем гипотетическую трёхмерную точку обратно в откалиброванные камеры и проверяем, согласуются ли эти проекции в нескольких видах. Рисунок 4 иллюстрирует общую схему задачи объёмного стереовидения.</p>
<p>Поскольку мы предполагаем, что точки, которые мы хотим восстановить, содержатся в ограниченном объёме, этот метод пригоден для восстановления трёхмерных моделей конкретных объектов. Это главное отличие от более общей задачи восстановления моделей сцены, в которой расположение объектов может быть неограниченным.</p>
<p>Основной принцип любого метода объёмного стереовидения заключается в том, чтобы сначала определить способ для определения согласованности точки, которая проецируется на несколько ракурсов изображений. Известно множество различных методов определения того, что мы будем считать согласованными наблюдениями. Мы кратко опишем три основных метода:<br>
- пространственное вырезание (Space carving),<br>
- теневое вырезание (shadow carving),<br>
- раскраска вокселей (voxel coloring). </p>
<h5>2.1 Space carving</h5>
<p>Идея пространственного вырезания (space carving) в основном основана на наблюдении, что контуры объекта предоставляют богатый источник геометрической информации об этом объекте.</p>
<p><img alt="Рисунок 5: Силуэт объекта и визуальный конус" src="https://storage.yandexcloud.net/yahosting/active/5.jpg"></p>
<p><strong>Рисунок 5: Силуэт объекта и визуальный конус</strong></p>
<p>В контексте множественных видов сначала рассмотрим задачу, проиллюстрированную на рисунке 5. Каждая камера наблюдает некоторую видимую часть объекта, по которой можно определить контур. При проецировании в плоскость изображения этот контур охватывает набор пикселей, известный как <strong>силуэт объекта</strong> в плоскости изображения. Пространственное вырезание в конечном итоге использует силуэты объектов с разных видов для обеспечения согласованности.</p>
<p>Однако если у нас нет информации о трёхмерной сцене, а есть только её изображения, то как мы можем получить информацию о силуэтах? К счастью, одно из практических преимуществ работы с силуэтами заключается в том, что их можно легко обнаружить на изображениях, если мы контролируем фон за объектом, который хотим восстановить. Например, мы можем использовать «зелёный экран» за объектом или использовать специальные алгоритмы отделения объекта от фона.</p>
<p>Теперь, когда у нас есть силуэты, как мы можем их использовать? Напомним, что в объёмном стереовидении у нас есть оценка некоторого объёма, в котором, как мы гарантируем, может находиться объект. Теперь введём понятие <strong>визуального конуса</strong> — это охватывающая поверхность, определяемая центром камеры и контуром объекта в плоскости изображения. По построению сцены гарантируется, что объект будет полностью находиться как в начальном объёме, так и в визуальном конусе.</p>
<p><img alt="Рисунок 6: Построение визуальной оболочки" src="https://storage.yandexcloud.net/yahosting/active/6.jpg"></p>
<p><strong>Рисунок 6: Построение визуальной оболочки</strong></p>
<p>Если у нас есть множество видов с разных ракурсов, мы можем вычислить визуальные конусы для каждого вида. Поскольку, по определению, объект находится в каждом из этих визуальных конусов, он должен лежать в их пересечении, как показано на рисунке 6. Такое пересечение часто называют визуальной оболочкой (visual hull).</p>
<p>На практике мы сначала начинаем с определения рабочего объёма, в котором, как мы знаем, находится объект. Например, если наши камеры окружают объект, мы можем просто сказать, что рабочий объём — это всё внутреннее пространство, ограниченное камерами. Мы разделяем этот объём на маленькие единицы, известные как воксели, создавая то, что называется воксельной сеткой. Мы берём каждый воксель из воксельной сетки и проецируем его на каждый из видов. Если воксель не содержится в силуэте на каком-либо виде, он отбрасывается. Следовательно, в конце алгоритма пространственного вырезания у нас остаются воксели, содержащиеся внутри визуальной оболочки.</p>
<p>Хотя метод пространственного вырезания позволяет избежать проблемы соответствий и является относительно простым, у него всё ещё есть множество ограничений. Одно из ограничений пространственного вырезания заключается в том, что он масштабируется линейно с количеством вокселей в сетке. По мере уменьшения размера каждого вокселя, количество вокселей в сетке увеличивается кубически. Поэтому получение более точных результатов реконструкции приводит к значительному увеличению времени обработки. Однако некоторые методы, такие как использование октетных деревьев (octrees), могут помочь решить эту проблему. Продвинутые методы включают выполнение итеративной адаптации для уменьшения размера начальной воксельной сетки в тех областях изображений, где это необходимо.</p>
<p><img alt="Рисунок 7: Воксельная сетка объекта" src="https://storage.yandexcloud.net/yahosting/active/7.jpg"></p>
<p>На рисунке 7 показан результат пространственного вырезания при работе с воксельной сеткой. Область представляет собой реконструированный объект после вырезания с использованием двух видов, в то время как затенённая часть внутри — это фактический объект. </p>
<p>Ограничение метода заключается в том, что эффективность пространственного вырезания зависит от количества видов, точности силуэта и даже формы объекта, который мы пытаемся восстановить. Если количество видов слишком мало, мы получаем очень приблизительную оценку визуальной оболочки объекта. По мере увеличения количества видов можно удалить больше лишних вокселей с помощью проверки согласованности.</p>
<p>Кроме того, достоверность проверки согласованности поддерживается только тем фактом, что мы считаем силуэты правильными и гладкими. Если силуэт слишком сложен и содержит больше пикселей, чем мы имеем в распоряжении, наша реконструкция может оказаться неточной. В потенциально ещё худшем случае силуэт пропускает части фактического объекта, что приводит к чрезмерному вырезанию при реконструкции.</p>
<p>Наконец, основным недостатком пространственного вырезания является то, что оно не способно моделировать определённые вогнутости объекта, как показано на рисунке 8.</p>
<p><img alt="Рисунок 8: Недостаток пространственного вырезания при наличии вогнутостей на объекте" src="https://storage.yandexcloud.net/yahosting/active/8.jpg"></p>
<p><strong>Рисунок 8: Недостаток пространственного вырезания при наличии вогнутостей на объекте</strong></p>
<h5>2.2 Shadow carving</h5>
<p>Чтобы обойти проблему вогнутостей, возникающую при пространственном вырезании, нам нужно обратиться к другим формам проверок согласованности.</p>
<p>Одним из важных признаков для определения трёхмерной формы объекта является наличие самотеней — теней, которые объект отбрасывает на себя. Для вогнутых объектов характерно то, что они часто отбрасывают самотени в вогнутых областях.</p>
<p><img alt="Рисунок 9: Вырезание с учетом теней" src="https://storage.yandexcloud.net/yahosting/active/9.jpg"></p>
<p><strong>Рисунок 9: Вырезание с учетом теней</strong></p>
<p>По своей сути теневое вырезание дополняет пространственное вырезание идеей использования самотеней для более точной оценки вогнутостей. Как показано на рисунке 9, общая установка теневого вырезания очень похожа на пространственное вырезание. Объект помещается на поворотный стол, который просматривается откалиброванной камерой. Однако вокруг камеры располагается массив источников света в известных позициях, состояние которых можно соответствующим образом включать и выключать. Эти источники света будут использоваться для того, чтобы заставить объект отбрасывать самотени.</p>
<p><img alt="Рисунок 10: Источник света как дополнительный инструмент для построения визуальной оболочки" src="https://storage.yandexcloud.net/yahosting/active/10.jpg"></p>
<p><strong>Рисунок 10: Источник света как дополнительный инструмент для построения визуальной оболочки</strong></p>
<p>Как показано на рисунке 10, процесс теневого вырезания начинается с начальной воксельной сетки, которая обрезается с помощью того же подхода, что и при пространственном вырезании. Однако в каждом виде мы можем включать и выключать каждый источник света в массиве, окружающем камеру. Каждый источник света будет создавать различную самотень на объекте. После определения тени в плоскости изображения мы можем найти воксели на поверхности нашей обрезанной воксельной сетки, которые находятся в визуальном конусе тени. Эти поверхностные воксели позволяют нам затем создать новый визуальный конус с источником изображения. Затем мы используем полезный факт, что воксель, являющийся частью обоих визуальных конусов, не может быть частью объекта, чтобы исключить воксели в вогнутости.</p>
<p>Как и в случае с пространственным вырезанием, время работы теневого вырезания зависит от разрешения воксельной сетки. Время работы масштабируется кубически с разрешением воксельной сетки. Однако если имеется N источников света, то теневое вырезание занимает примерно в N + 1 раз больше времени, чем пространственное вырезание, поскольку каждый воксель необходимо проецировать в камеру и на каждый из N источников света.</p>
<p>Подводя итог, теневое вырезание всегда даёт консервативную оценку объёма, которая лучше восстанавливает трёхмерные формы с вогнутостями. Качество результатов зависит как от количества видов, так и от количества источников света. Некоторые недостатки этого подхода заключаются в том, что он не может обрабатывать случаи, когда объект содержит отражающие области или области с низким альбедо. Это связано с тем, что в таких условиях невозможно точно определить тени.</p>
<h5>2.3 Раскраска вокселей (Voxel coloring)</h5>
<p>И напоследок рассмотрим еще одну технику объёмного стереовидения — раскраска вокселей. 
Эта техника основана на пространственном вырезании, но для согласованности контуров дополнительно использует согласованность цветов.</p>
<p><img alt="Рисунок 11: Раскраска вокселей" src="https://storage.yandexcloud.net/yahosting/active/11.jpg"></p>
<p><strong>Рисунок 11: Раскраска вокселей</strong></p>
<p>Предположим, что нам даны изображения объекта с нескольких точек зрения, который мы хотим восстановить (рисунок 11). Для каждого вокселя мы смотрим на его соответствующие проекции на каждом из изображений и сравниваем цвет каждой из этих проекций. Если цвета этих проекций достаточно совпадают, мы отмечаем воксель как часть объекта.</p>
<p>Одно из преимуществ раскраски вокселей, которого нет в пространственном вырезании, заключается в том, что цвет, связанный с проекциями, может быть перенесён на воксель, что даёт цветную реконструкцию.</p>
<p>В целом существует множество методов, которые можно использовать для проверки согласованности цветов. Один из примеров — установка порога между сходством цветов проекций. Однако существует критическое предположение для любой используемой проверки согласованности цветов: реконструируемый объект должен быть ламбертовским. Это означает, что воспринимаемая яркость любой части объекта не должна меняться с изменением положения точки обзора или позы.</p>
<p>Для неламбертовских объектов, например, сделанных из высокоотражающих материалов, легко представить, что проверка согласованности цветов может дать сбой на вокселях, которые фактически являются частью объекта.</p>
<p><img alt="Рисунок 12: Частный случай неоднозначности раскраски вокселей" src="https://storage.yandexcloud.net/yahosting/active/12.jpg"></p>
<p><strong>Рисунок 12: Частный случай неоднозначности раскраски вокселей</strong></p>
<p>Одним из недостатков простой раскраски вокселей является то, что она даёт решение, которое не обязательно является уникальным (рисунок 12). Поиск истинного, уникального решения усложняет задачу реконструкции с помощью раскраски вокселей.</p>
<p>Можно устранить неоднозначность в реконструкции, введя ограничение видимости на воксель, которое требует, чтобы воксели проходили в определённом порядке. В частности, мы хотим проходить воксели слой за слоем, начиная с вокселей, расположенных ближе к камерам, а затем переходить к более удалённым вокселям.</p>
<p>При использовании такого порядка мы выполняем проверку согласованности цветов. Затем проверяем, виден ли воксель как минимум двум камерам, что создаёт наше ограничение видимости. Если воксель не виден как минимум двум камерам, он должен быть закрыт и, следовательно, не является частью объекта.</p>
<p>Обратите внимание, что наш порядок обработки ближайших вокселей позволяет нам убедиться, что мы сохраняем воксели, которые могут закрывать более поздние обработанные воксели, чтобы обеспечить это ограничение видимости.</p>
<p>В заключение отметим, что раскраска вокселей имеет преимущество одновременного захвата формы и текстуры объекта. Некоторые из недостатков включают предположение о том, что объект является ламбертовским, и то, что камеры не могут находиться в определённых местах, поскольку воксели должны обрабатываться в определённом порядке из-за ограничения видимости.</p>
<h4>Резюме</h4>
<p>Мы рассмотрели современные подходы к решению задачи трёхмерной реконструкции объектов, которые позволяют обойти сложности классического стереовидения, связанные с поиском соответствующих точек на разных изображениях.</p>
<p>Основное внимание уделяется двум ключевым направлениям. Первое — активное стерео, где вместо второй камеры применяется специальный проектор, создающий определённые узоры на объекте. Этот метод значительно упрощает определение соответствий между точками. В рамках активного стерео описаны различные техники: от проецирования отдельных точек и полос до создания сложных цветных узоров, подобных тем, что используются в датчиках глубины типа Microsoft Kinect. Также рассматривается вариант с применением теневых проекций, который является более экономичным, хотя и менее точным решением.</p>
<p>Второе направление — объёмное стереовидение, основанное на проверке согласованности проекций точек в ограниченном объёме. Этот подход включает несколько методов реконструкции: пространственное вырезание (space carving), использующее силуэты объекта и воксельные сетки; теневое вырезание (shadow carving), улучшающее реконструкцию вогнутых поверхностей за счёт анализа самотеней; и раскраска вокселей (voxel coloring), позволяющая получать цветные трёхмерные модели благодаря анализу цветовой согласованности.</p>
<p>Описанные методы обладают рядом преимуществ: они существенно упрощают поиск соответствий между точками, обеспечивают возможность создания детальных трёхмерных моделей и могут применяться в различных условиях съёмки. Однако существуют и определённые ограничения: необходимость тщательной калибровки оборудования, требование ламбертовского характера объектов, значительные временные затраты на обработку данных, а также проблемы при работе с отражающими поверхностями.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/structure-from-motion/" class="u-url">Извлечение структуры сцены из движения камеры </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/structure-from-motion/" rel="bookmark">
            <time class="published dt-published" datetime="2025-10-04T10:00:00+03:00" itemprop="datePublished" title="2025-10-04 10:00">2025-10-04 10:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h3>1. Аффинная структура из движения</h3>
<p>В конце предыдущего раздела мы затронули интересную тему, как можно использовать более двух проекций сцены, чтобы получить информацию о трёхмерной сцене. Теперь давайте более подробно рассмотрим расширение геометрии двух камер на более общий случай множества камер. Комбинируя наблюдения точек из нескольких видов, мы сможем одновременно определить как трёхмерную структуру сцены, так и параметры камеры — эта задача известна как <strong>структура из движения</strong> (structure from motion).</p>
<p><img alt="Рисунок 1: Общая схема структуры из движения" src="https://storage.yandexcloud.net/yahosting/stereo/3.jpg"></p>
<p><strong>Рисунок 1: Общая схема структуры из движения</strong></p>
<p>Схема для формальной постановки задачи приведена на рисунке 1. Предположим, что у нас есть $m$ камер с матрицами камер $M_i$, которые кодируют как внутренние, так и внешние параметры камер. Пусть $X_j$ — одна из $n$ трёхмерных точек в сцене. Каждая трёхмерная точка может быть видна в нескольких камерах в позиции $x_{ij}$, которая является проекцией $X_j$ на изображение камеры $i$ с помощью проективного преобразования $M_i$.</p>
<p>Цель оценки <strong>структуры из движения</strong> - восстановление как структуры сцены (то есть $n$ трёхмерных точек $X_j$), так и движения камер (то есть $m$ проективных матриц $M_i$) из всех наблюдений $x_{ij}$.</p>
<p>Основные данные этой системы включают в себя:<br>
- <strong>Структура сцены</strong>: набор трёхмерных точек $X_j$, которые составляют геометрию сцены.<br>
- <strong>Движение камер</strong>: параметры проективных матриц $M_i$, описывающие положение и ориентацию каждой камеры.<br>
- <strong>Наблюдения</strong>: множество проекций $x_{ij}$, показывающих, где трёхмерные точки видны на изображениях разных камер.  </p>
<p>Таким образом, задача структуры из движения заключается в одновременном восстановлении трёхмерной геометрии сцены и параметров движения камер на основе множества двумерных наблюдений. Это фундаментальная задача в компьютерном зрении и трёхмерной реконструкции.</p>
<p>Прежде чем решать общую задачу структуры из движения, мы начнем с более простой задачи, которая предполагает, что камеры являются аффинными или слабоперспективными. В конечном итоге отсутствие операции перспективного масштабирования упрощает математическое выведение для этой задачи.</p>
<p>Ранее мы вывели приведенные уравнения для случаев перспективы и слабой перспективы. 
Вспомним, что в полной перспективной модели матрица камеры определяется как:</p>
<p>$M = \begin{bmatrix} A &amp; b \\ v &amp; 1 \end{bmatrix}$ (1)</p>
<p>где $v$ — некоторый ненулевой вектор размером $1 \times 3$. 
С другой стороны, для модели слабой перспективы $v = 0$. Мы обнаруживаем, что это свойство делает однородную координату $MX$ равной 1:</p>
<p>$x = MX = \begin{bmatrix} m_1 \\ m_2 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} X_1 \\ X_2 \\ X_3 \\ 1 \end{bmatrix} = \begin{bmatrix} m_1X \\ m_2X \\ 1 \end{bmatrix}$ (2)</p>
<p>Следовательно, при переходе от однородных к евклидовым координатам нелинейность проективного преобразования исчезает, и преобразование слабой перспективы действует как простой увеличитель. Мы можем представить проекцию в более компактной форме:</p>
<p>$ M_{affine} = \begin{bmatrix} m_1X \\ m_2X \end{bmatrix} = [A \ b]X = AX + b$ (3)</p>
<p>Таким образом, теперь мы используем аффинную модель камеры для выражения связи между точкой $X_j$ в 3D и соответствующими наблюдениями в каждой аффинной камере (например, $x_{ij}$ в камере $i$).</p>
<p>Возвращаясь к задаче структуры из движения, нам нужно оценить $m$ матриц $M_i$ и $n$ векторов мировых координат $X_j$. 
Такая система содержит всего $8m + 3n$ неизвестных, на основе $mn$ наблюдений. Каждое наблюдение создает 2 ограничения на камеру, поэтому имеется $2mn$ уравнений с $8m + 3n$ неизвестными.</p>
<p>Мы можем использовать это уравнение, чтобы определить нижнюю границу количества соответствующих наблюдений в каждом из изображений, которые нам необходимы. Например, если у нас есть $m = 2$ камеры, то нам нужно иметь как минимум $n = 16$ точек в 3D. Однако как решить эту задачу, когда у нас достаточно соответствующих точек, помеченных на каждом изображении? </p>
<h3>2 Метод факторизации Томаси и Канеде</h3>
<p>В этой части мы рассмотрим метод факторизации Томаси и Канеде для решения задачи аффинной структуры из движения. Этот метод состоит из двух основных этапов:  центрирования данных и собственно факторизации.</p>
<p><img alt="Рисунок 2: Центроид наблюдаемых точек" src="https://storage.yandexcloud.net/yahosting/stereo/4.jpg"></p>
<p><strong>Рисунок 2: Центроид наблюдаемых точек</strong></p>
<p>На рисунке 2 приведен пример центрирования - все точки изображения размещаются таким образом, чтобы их центроид находился в начале координат в плоскости изображения. Аналогично мы размещаем систему мировых координат так, чтобы начало координат находилось в центроиде 3D точек.
Основная идея этого этапа — центрирование данных в начале координат. Для этого для каждого изображения $i$ мы переопределяем новые координаты $\hat{x}<em ij>{ij}$ для каждой точки изображения $x</em>_i$:}$, вычитая их центроид $\bar{x</p>
<p>$\hat{x}<em ij>{ij} = x</em>} - \bar{x<em ij>i = x</em>$ (4)} - \frac{1}{n} \sum_{j=1}^{n} x_{ij</p>
<p>Напомним, что задача аффинной структуры из движения позволяет нам определить взаимосвязь между точками изображения $x_{ij}$, переменными матрицы камеры $A_i$ и $b_i$, и 3D точками $X_j$ как:</p>
<p>$x_{ij} = A_i X_j + b_i$ (5)</p>
<p>После этапа центрирования мы можем объединить определение центрированных точек изображения $\hat{x}_{ij}$ из уравнения (4) и аффинное выражение из уравнения (5):</p>
<p>$\hat{x}<em ij>{ij} = x</em> = $} - \frac{1}{n} \sum_{k=1}^{n} x_{ik<br>
$= A_i X_j - \frac{1}{n} \sum_{k=1}^{n} A_i X_k = A_i(X_j - \frac{1}{n} \sum_{k=1}^{n} X_k) = $<br>
$ = A_i(X_j - \bar{X}) = A_i \hat{X}_j$ (6)</p>
<p>Как видно из уравнения (6), если мы переместим начало системы мировых координат в центроид $\bar{X}$, то центрированные координаты точек изображения $\hat{x}_{ij}$ и центрированные координаты 3D точек $\hat{X}_j$ связаны только одной матрицей $2 \times 3$ $A_i$. В конечном итоге этап центрирования метода факторизации позволяет нам создать компактное матричное произведение для связи 3D структуры с наблюдаемыми точками на множестве изображений.</p>
<p>Однако заметим, что в матричном произведении $\hat{x}<em ij>{ij} = A_i \hat{X}_j$ у нас есть доступ только к значениям в левой части уравнения. Таким образом, нам нужно каким-то образом выделить матрицы движения $A_i$ и структуру $X_j$. Используя все наблюдения для всех камер, мы можем построить матрицу измерений $D$, состоящую из $n$ наблюдений в $m$ камерах (помните, что каждая запись $\hat{x}</em>$ — это вектор $2 \times 1$):</p>
<p>$D = \begin{bmatrix} \hat{x}<em 12>{11} &amp; \hat{x}</em>} &amp; \dots &amp; \hat{x<em 21>{1n} \\ \hat{x}</em>} &amp; \hat{x<em 2n>{22} &amp; \dots &amp; \hat{x}</em>} \\ \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ \hat{x<em m2>{m1} &amp; \hat{x}</em>$ (7)} &amp; \dots &amp; \hat{x}_{mn} \end{bmatrix</p>
<p>Теперь вспомним, что из-за нашего аффинного предположения, $D$ может быть выражена как произведение матрицы движения $2m \times 3$ $M$ (которая включает матрицы камер $A_1, \dots, A_m$) и матрицы структуры $3 \times n$ $S$ (которая включает 3D точки $X_1, \dots, X_n$). Важный факт, который мы будем использовать, заключается в том, что $rank(D) = 3$, поскольку $D$ — это произведение двух матриц, максимальное измерение которых равно 3.</p>
<p>Чтобы разложить $D$ на $M$ и $S$, мы будем использовать сингулярное разложение:</p>
<p>$D = U\Sigma V^T = \begin{bmatrix} u_1 &amp; \dots &amp; u_n \end{bmatrix} \begin{bmatrix} \sigma_1 &amp; 0 &amp; 0 &amp; 0 &amp; \dots &amp; 0 \\ 0 &amp; \sigma_2 &amp; 0 &amp; 0 &amp; \dots &amp; 0 \\ 0 &amp; 0 &amp; \sigma_3 &amp; 0 &amp; \dots &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \dots &amp; 0 \\ \vdots &amp; \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; 0 &amp; 0 &amp; 0 &amp; \dots &amp; 0 \end{bmatrix} \begin{bmatrix} v_1^T \\ \vdots \\ v_n^T \end{bmatrix} = $  </p>
<p>$ = \begin{bmatrix} u_1 &amp; u_2 &amp; u_3 \end{bmatrix} \begin{bmatrix} \sigma_1 &amp; 0 &amp; 0 \\ 0 &amp; \sigma_2 &amp; 0 \\ 0 &amp; 0 &amp; \sigma_3 \end{bmatrix} \begin{bmatrix} v_1^T \\ v_2^T \\ v_3^T \end{bmatrix} = U_3\Sigma_3V_3^T$ (8)</p>
<p>В этом разложении $\Sigma_3$ определяется как диагональная матрица, образованная ненулевыми сингулярными значениями, в то время как $U_3$ и $V_3^T$ получаются путем взятия соответствующих трех столбцов матрицы $U$ и строк матрицы $V^T$ соответственно.</p>
<p>К сожалению, на практике $rank(D) &gt; 3$ из-за шума измерений и аффинного приближения камеры. Однако мы помним замечательное свойство сингулярного разложения, что когда $rank(D) &gt; 3$, $U_3W_3V_3^T$ все еще остается наилучшим возможным приближением ранга 3 для $MS$ в смысле нормы Фробениуса.</p>
<p>При внимательном рассмотрении мы видим, что матричное произведение $\Sigma_3V_3^T$ образует матрицу размером $3 \times n$, что точно соответствует размеру матрицы структуры $S$. Аналогично, $U_3$ — это матрица размером $2m \times 3$, что соответствует размеру матрицы движения $M$.</p>
<p>Хотя такой способ сопоставления компонентов SVD-разложения с $M$ и $S$ приводит к физически и геометрически правдоподобному решению задачи аффинной структуры из движения, этот выбор не является единственным решением. 
Например, мы также могли бы установить матрицу движения как $M = U_3\Sigma_3$, а матрицу структуры как $S = V_3^T$, поскольку в обоих случаях матрица наблюдений $D$ остается той же.</p>
<p>Так какое разложение выбрать? В своей работе Томаси и Канеде пришли к выводу, что наиболее надежным выбором факторизации является $M = U_3\sqrt{\Sigma_3}$ и $S = \sqrt{\Sigma_3}V_3^T$. </p>
<p>Тем не менее, мы обнаруживаем внутреннюю неоднозначность в любом выборе факторизации $D = MS$, поскольку в разложение можно вставить любую произвольную обратимую матрицу $3 \times 3$ $A$:</p>
<p>$D = MA A^{-1}S = (MA)(A^{-1}S)$ (9)</p>
<p>Это означает, что матрицы камер, полученные из движения $M$, и 3D точки, полученные из структуры $S$, определяются с точностью до умножения на общую матрицу $A$. Следовательно, наше решение недоопределено и требует дополнительных ограничений для разрешения этой аффинной неоднозначности. Несмотря на то, что параллельность линий сохраняется, метрический масштаб элементов матрицы и координат точек остаются неизвестными. </p>
<p>Другой важный класс неоднозначностей для реконструкции — это неоднозначность подобия, которая возникает, когда реконструкция верна с точностью до преобразования подобия (вращение, перенос и масштабирование). Реконструкция только с неоднозначностью подобия известна как метрическая реконструкция. Эта неоднозначность существует даже при внутренней калибровке камер. Хорошая новость заключается в том, что для откалиброванных камер неоднозначность подобия является единственной возможной неоднозначностью.</p>
<p>Тот факт, что невозможно восстановить абсолютный масштаб сцены по изображениям, довольно интуитивен. 
Масштаб объекта, абсолютное положение и каноническая ориентация всегда будут неизвестны, если мы не сделаем дополнительные предположения (например, знаем высоту дома на рисунке) или не включим дополнительные данные о матрице переноса. 
Это происходит потому, что одни атрибуты могут компенсировать другие. Например, чтобы получить то же изображение, мы можем просто отодвинуть объект назад и соответствующим образом масштабировать его.</p>
<p>Один из примеров устранения неоднозначности подобия возник во время процедуры калибровки камеры, когда мы сделали предположение, что знаем расположение калибровочных точек относительно мировой системы координат. Это позволило нам узнать размер квадратов шахматной доски для определения метрического масштаба 3D структуры. </p>
<h3>3. Структура из движения с перспективными преобразованиями камер (метод разложения)</h3>
<p>После изучения упрощённой задачи аффинной структуры из движения давайте рассмотрим общий случай для проективных камер $M_i$.</p>
<p>В общем случае с проективными камерами каждая матрица камеры $M_i$ содержит 11 степеней свободы, поскольку она определена с точностью до масштабного множителя:</p>
<p>$M_i = \begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} &amp; b_1 \\ a_{21} &amp; a_{22} &amp; a_{23} &amp; b_2 \\ a_{31} &amp; a_{32} &amp; a_{33} &amp; 1 \end{bmatrix}$ (10)</p>
<p>Более того, в общем случае решения определение матриц структуры из движения могут быть определены с точностью до проективного преобразования, как и при афинной неоднозначности. Мы всегда можем произвольно применить проективное преобразование $4 \times 4$ $H$ к матрице движения, при условии, что мы также преобразуем матрицу структуры с помощью обратного преобразования $H^{-1}$. Результирующие наблюдения в плоскости изображения останутся прежними.</p>
<p>Аналогично аффинному случаю, мы можем сформулировать общую задачу структуры из движения как оценку как $m$ матриц движения $M_i$, так и $n$ 3D точек $X_j$ на основе $mn$ наблюдений $x_{ij}$. Поскольку камеры и точки могут быть восстановлены только с точностью до проективного преобразования $4 \times 4$ с учётом масштаба (15 параметров), у нас есть $11m + 3n - 15$ неизвестных в $2mn$ уравнениях.</p>
<p>Из этих фактов мы можем определить необходимое количество видов и наблюдений, требуемых для решения неизвестных. </p>
<h3>4. Алгебраический подход к SFM с перспективой</h3>
<p>Теперь рассмотрим алгебраический подход, который использует концепцию фундаментальной матрицы $F$ для решения задачи оценки структуры из движения для двух камер.
В отличии от метода разложения, в алгебраическом подходе мы рассматриваем последовательные пары камер для определения матриц камер $M_1$ и $M_2$ с точностью до перспективного преобразования. Затем мы находим перспективное преобразование $H$ такое, что $M_1H = [I \ 0]$ и $M_2H = [A \ B]$.</p>
<p><img alt="Рисунок 3: Алгебраический подход к оценке структуры из движения" src="https://storage.yandexcloud.net/yahosting/stereo/5.jpg"></p>
<p>Как показано на рисунке 3, основная идея алгебраического подхода заключается в вычислении двух матриц камер $M_1$ и $M_2$, которые могут быть вычислены только с точностью до перспективного преобразования $H$.</p>
<p>Поскольку каждая $M_i$ может быть вычислена только с точностью до перспективного преобразования $H$, мы всегда можем рассмотреть такое $H$, при котором матрица проекции первой камеры $M_1H^{-1}$ будет канонической. Разумеется, то же преобразование должно быть применено и ко второй камере, что приводит к следующей форме:</p>
<p>$M_1H^{-1} = [I \ 0]$<br>
$M_2H^{-1} = [A \ b]$ (11)</p>
<p>Для выполнения этой задачи сначала необходимо вычислить фундаментальную матрицу $F$ с помощью алгоритма восьми точек. 
Далее матрица $F$ используется для оценки проективных матриц камер $M_1$ и $M_2$.</p>
<p>Для этой оценки определим 3D точку $P$ и соответствующие наблюдения на изображениях $p$ и $p'$. 
Поскольку мы применили $H^{-1}$ к обеим матрицам проекции камер, мы также должны применить $H$ к структуре, получая $P_e = HP$.<br>
Таким образом, мы можем связать координаты пикселей $p$ и $p'$ с преобразованной структурой следующим образом:  </p>
<p>$p = M_1P = M_1H^{-1}HP = [I \ 0]P_e$<br>
$p' = M_2P = M_2H^{-1}HP = [A \ b]P_e$ (12)</p>
<p>Интересное свойство между двумя соответствиями изображений $p$ и $p'$ возникает при подстановках:</p>
<p>$p' = [A \ b] P_e =$<br>
$= A[I \ 0] P_e + b =$  <br>
$= Ap + b$ (13)</p>
<p>Используя уравнение (13), мы можем записать векторное произведение между $p'$ и $b$ как:</p>
<p>$p' \times b = (Ap + b) \times b = Ap \times b$ (14)</p>
<p>По определению векторного произведения, $p' \times b$ перпендикулярен $p'$. Поэтому мы можем записать:</p>
<p>$0 = p'^T(p' \times b) = p'^T(Ap \times b) = p'^T \cdot (b \times Ap) = p'^T[b\times] Ap$ (15)</p>
<p>Рассматрев это ограничение более внимательно, можно увидеть, что оно напоминает общее определение фундаментальной матрицы<br>
$p'^TFp = 0$  </p>
<p>Если мы установим $F = [b\times] A$, то извлечение $A$ и $b$ снова сводится к задаче разложения.</p>
<p>Давайте начнем с определения $b$. Снова используя определение векторного произведения, мы можем записать:</p>
<p>$F^\top b = [[b\times] A]^\top b = 0$ (16) </p>
<p>Поскольку матрица $F$ является сингулярной, вектор $b$ можно вычислить как решение методом наименьших квадратов уравнения $F^\top b = 0$ при условии $|b| = 1$ с помощью сингулярного разложения (SVD).</p>
<p>Как только вектор $b$ становится известным, мы можем вычислить матрицу $A$. Если мы положим $A = −[b\times] F$, то можем проверить, что это определение удовлетворяет условию $F = [b\times] A$:</p>
<p>$[b\times] A' = −[b\times][b\times] F$
$= (bb^\top − |b|^2I)F$
$= bb^\top F + |b|^2F$
$= 0 + 1 · F$
$= F$ (17)</p>
<p>Следовательно, мы определяем два выражения для матриц наших камер $M_1H^{−1}$ и $M_2H^{−1}$:</p>
<p>$\tilde{M}_1 = [I \ 0]$
$\tilde{M}_2 = [−[b\times] F \ b]$ (18)</p>
<p>Прежде чем завершить этот раздел, мы хотим дать геометрическую интерпретацию для вектора $b$. Мы знаем, что $b$ удовлетворяет условию $Fb = 0$. Вспомним эпиполярные ограничения, которые мы вывели в предыдущих конспектах, где было показано, что эпиполы на изображении — это точки, которые отображаются в ноль при преобразовании фундаментальной матрицей (то есть $Fe_2 = 0$ и $F^\top e_1 = 0$). Таким образом, мы видим, что $b$ является эпиполом. Это даёт нам новый набор уравнений для матриц проекции камер (формулы 4.10):</p>
<p>$\tilde{M}_1 = [I \ 0]$
$\tilde{M}_2 = [−[e\times] F \ e]$ (19) </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/stereo-systems/" class="u-url">Стерео системы </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/stereo-systems/" rel="bookmark">
            <time class="published dt-published" datetime="2025-10-03T14:00:00+03:00" itemprop="datePublished" title="2025-10-03 14:00">2025-10-03 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <p>В предыдущих заметках мы рассмотрели, как с помощью ключевых точек можно значительно улучшить наше понимание -сцены. Мы сосредоточились на настройке <strong>эполярной геометрии</strong>, чтобы связать точки одной плоскости изображения с точками другой без извлечения какой-либо информации о трёхмерной сцене. В этой заметке мы обсудим, как восстановить информацию о трёхмерной сцене из нескольких двумерных изображений.</p>
<p><img alt="Рисунок 1: Триангуляция точки Р по двум изображениям" src="https://storage.yandexcloud.net/yahosting/stereo/1.jpg"></p>
<p><strong>Рисунок 1: Триангуляция точки Р по двум изображениям</strong></p>
<p>Одной из фундаментальных задач в геометрии множественных видов является задача <strong>триангуляции</strong> — процесс определения местоположения трёхмерной точки по её проекциям на два или более изображений. В задаче триангуляции с двумя видами у нас есть две камеры с известными внутренними параметрами камеры $K$ и $K'$ соответственно. Нам также известны относительные ориентации и смещения $R$, $T$ этих камер относительно друг друга.</p>
<p>Предположим, что у нас есть точка $P$ в трёхмерном пространстве, которая может быть найдена на изображениях двух камер в точках $p$ и $p'$ соответственно. Хотя местоположение $P$ в данный момент неизвестно, мы можем измерить точные местоположения $p$ и $p'$ на изображении. Поскольку $K$, $K'$, $R$, $T$ известны, мы можем вычислить две линии визирования $ℓ$ и $ℓ'$, которые определяются центрами камер $O_1$, $O_2$ и местоположениями изображений $p$, $p'$. Следовательно, $P$ может быть вычислена как точка пересечения $ℓ$ и $ℓ'$.</p>
<p><img alt="Рисунок 2: Ошибки в проекции точки" src="https://storage.yandexcloud.net/yahosting/stereo/2.jpg"></p>
<p><strong>Рисунок 2: Ошибки в проекции точки</strong></p>
<p>Хотя этот процесс кажется простым и математически обоснованным, на практике он работает не очень хорошо. В реальном мире из-за того, что наблюдения $p$ и $p'$ зашумлены, а параметры калибровки камеры не являются точными, поиск точки пересечения прямых $ℓ$ и $ℓ'$ может быть проблематичным. В большинстве случаев она вообще не существует, поскольку эти две прямые могут не пересекаться.</p>
<h4>1. Линейный метод триангуляции</h4>
<p>В этом разделе мы описываем простой линейный метод триангуляции, который решает проблему отсутствия точки пересечения между лучами. Нам даны две точки на изображениях, которые соответствуют друг другу:<br>
$p = MP = (x, y, 1)$<br>
$p' = M'P = (x', y', 1)$   </p>
<p>Вспомним, что векторное произведение двух векторов в трехмерном пространстве дает вектор, перпендикулярный обоим исходным векторам.</p>
<p>В нашем случае:
* $p = (x, y, 1)$ — это точка на плоскости изображения
* $MP$ — это результат умножения матрицы камеры $M$ на координаты 3D точки $P$</p>
<p>Векторы $p$ и $MP$ коллинеарны (лежат на одной прямой или параллельны), а значит  $p \times (MP) = 0$</p>
<p>Развернем это векторное произведение в координатной форме:</p>
<p>$p \times (MP) = \begin{vmatrix}
i &amp; j &amp; k \\
x &amp; y &amp; 1 \\
M_1P &amp; M_2P &amp; M_3P
\end{vmatrix} = 0$</p>
<p>Раскрывая определитель, получаем:</p>
<p>$p \times (MP) = i(yM_3P - M_2P) - j(xM_3P - M_1P) + k(xM_2P - yM_1P) = 0$</p>
<p>Это векторное равенство равно нулю тогда и только тогда, когда каждая его компонента равна нулю:</p>
<p>$x(M_3P) − (M_1P) = 0$<br>
$y(M_3P) − (M_2P) = 0$<br>
$x(M_2P) − y(M_1P) = 0$ (1)  </p>
<p>где $M_i$ — это $i$-я строка матрицы $M$.  </p>
<p>Подобные ограничения можно сформулировать для $p'$ и $M'$. Используя ограничения обоих изображений, мы можем сформулировать линейное уравнение вида<br>
$AP = 0$, где  </p>
<p>$A = \begin{bmatrix}
xM_3 − M_1 \\
yM_3 − M_2 \\
x'M'_3 − M'_1 \\
y'M'_3 − M'_2
\end{bmatrix}$ (2)</p>
<p>Это уравнение можно решить с помощью сингулярного разложения (SVD), чтобы найти наилучшую линейную оценку точки $P$. </p>
<p>Другой интересный аспект этого метода заключается в том, что он фактически может обрабатывать триангуляцию из нескольких видов. Для этого нужно просто добавить дополнительные строки к матрице $A$, соответствующие новым ограничениям от дополнительных видов.</p>
<p>Однако этот метод не подходит для проективной реконструкции.<br>
Основная причина - особенность разложения методом SVD, которое решается при ограничении $∥P∥ = 1$. 
Ограничение $|P| = 1$ означает, что вектор $P$ нормирован, то есть его длина равна единице. Однако при проективных преобразованиях это свойство не сохраняется, так как такие преобразования изменяют длины векторов. 
Другими словами, сингулярное разложение не является инвариантным относительно проективного преобразования $H$.
Например, предположим, что мы заменяем матрицы камер $M$ и $M'$ на матрицы, подвергнутые проективному преобразованию $MH^{-1}$ и $M'H^{-1}$. Тогда матрица линейных уравнений $A$ становится равной $AH^{-1}$. Следовательно, решение $P$ для предыдущей оценки $AP = 0$ будет соответствовать решению $HP$ для преобразованной задачи $(AH^{-1})(HP) = 0$.</p>
<p>Поэтому линейный метод триангуляции вычислительно простой, но часто не является оптимальным решением задачи триангуляции.</p>
<h4>2. Нелинейный метод триангуляции</h4>
<p>Вместо этого задача триангуляции для реальных сценариев часто математически характеризуется как решение задачи минимизации:</p>
<p>$\min_{\hat{P}} |M\hat{P} - p|^2 + |M'\hat{P} - p'|^2$ (3)</p>
<p>В приведенном уравнении мы стремимся найти точку $\hat{P}$ в 3D пространстве, которая наилучшим образом аппроксимирует $P$, путем нахождения наилучшей оценки методом наименьших квадратов для ошибки репроекции $\hat{P}$ на обоих изображениях.</p>
<p><strong>Ошибка репроекции</strong> для 3D точки на изображении — это расстояние между проекцией этой точки на изображении и соответствующей наблюдаемой точкой в плоскости изображения. В случае нашего примера на рисунке 2, поскольку $M$ — это проективное преобразование из 3D пространства в изображение 1, проецируемая точка $\hat{P}$ на изображении 1 равна $M\hat{P}$. Соответствующее наблюдение точки $\hat{P}$ на изображении 1 — это $p$. Таким образом, ошибка репроекции для точки $P$ на изображении 1 равна расстоянию $|M\hat{P} - p|$.</p>
<p>Общая ошибка репроекции, найденная в уравнении (3), представляет собой сумму ошибок репроекции для всех точек на изображении. В случае более чем двух изображений мы просто добавим дополнительные члены расстояния в целевую функцию:</p>
<p>$\min_{\hat{P}} \sum_i |M\hat{P}_i - p_i|^2$ (4)</p>
<p>На практике существует множество очень сложных методов оптимизации, которые дают хорошие приближения к решению задачи. Однако в рамках курса мы сосредоточимся только на одном из этих методов — алгоритме Гаусса-Ньютона для нелинейных наименьших квадратов.</p>
<p><strong>Общая задача нелинейных наименьших квадратов</strong> заключается в нахождении $x \in \mathbb{R}^n$, который минимизирует:</p>
<p>$|r(x)|^2 = \sum_{i=1}^m r_i(x)^2$ (5)</p>
<p>где $r$ — любая остаточная функция $r: \mathbb{R}^n \rightarrow \mathbb{R}^m$ такая, что $r(x) = f(x) - y$ для некоторой функции $f$, входных данных $x$ и наблюдения $y$. Задача нелинейных наименьших квадратов сводится к обычной линейной задаче наименьших квадратов, когда функция $f$ линейна. Однако помните, что в общем случае наши матрицы камер не являются аффинными.</p>
<p>Если мы обозначим $e_i$ как вектор $2 \times 1$, $e_i = M\hat{P}_i - p_i$, то мы можем переформулировать нашу задачу оптимизации следующим образом:</p>
<p>$\min_{\hat{P}} \sum_i e_i(\hat{P})^2$ (6)</p>
<p>что может быть идеально представлено как задача нелинейных наименьших квадратов.</p>
<p>В этих заметках мы рассмотрим, как можно использовать популярный алгоритм Гаусса-Ньютона для нахождения приближенного решения этой задачи нелинейных наименьших квадратов. Сначала предположим, что у нас есть достаточно разумная оценка 3D точки $\hat{P}$, которую мы можем вычислить с помощью предыдущего линейного метода.</p>
<p>Ключевая идея алгоритма Гаусса-Ньютона заключается в обновлении нашей оценки путем корректировки её в направлении еще лучшей оценки, которая минимизирует ошибку репроекции. На каждом шаге мы хотим обновить нашу оценку $\hat{P}$ на некоторую величину $\delta P$: $\hat{P} = \hat{P} + \delta P$. </p>
<p>Как выбрать параметр обновления δP?
Ключевая идея алгоритма Гаусса-Ньютона заключается в линеаризации остаточной функции вблизи текущей оценки $\hat{P}$. В нашем случае это означает, что остаточная ошибка $e$ точки $P$ может быть представлена как:</p>
<p>$e(\hat{P} + \delta P) \approx e(\hat{P}) + \frac{\partial e}{\partial P} \delta P$ (7)</p>
<p>После этого задача минимизации преобразуется в:</p>
<p>$\min_{\delta P} \left| \frac{\partial e}{\partial P} \delta P - (-e(\hat{P})) \right|^2$ (8)</p>
<p>Когда мы формулируем остаточную функцию таким образом, становится видно, что она принимает формат стандартной задачи линейных наименьших квадратов. Для задачи триангуляции с $N$ изображениями решение линейных наименьших квадратов имеет вид:</p>
<p>$\delta P = -(J^TJ)^{-1}J^Te$ (9)</p>
<p>где:</p>
<p>$e = \begin{bmatrix} e_1 \\ \vdots \\ e_N \end{bmatrix} = \begin{bmatrix} p_1 - M_1\hat{P} \\ \vdots \\ p_n - M_n\hat{P} \end{bmatrix}$ (10)</p>
<p>и</p>
<p>$J = \begin{bmatrix} \frac{\partial e_1}{\partial \hat{P}_1} &amp; \frac{\partial e_1}{\partial \hat{P}_2} &amp; \frac{\partial e_1}{\partial \hat{P}_3} \\ \vdots &amp; \vdots &amp; \vdots \\ \frac{\partial e_N}{\partial \hat{P}_1} &amp; \frac{\partial e_N}{\partial \hat{P}_2} &amp; \frac{\partial e_N}{\partial \hat{P}_3} \end{bmatrix}$ (11)</p>
<p>Важно отметить, что вектор остаточной ошибки для конкретного изображения $e_i$ является вектором размера $2 \times 1$, поскольку в плоскости изображения есть два измерения. Следовательно, в простейшем случае с двумя камерами ($N = 2$) вектор остаточной ошибки $e$ будет иметь размер $2N \times 1 = 4 \times 1$, а матрица Якоби $J$ — размер $2N \times 3 = 4 \times 3$.</p>
<p>Этот метод легко обрабатывает множественные виды, так как дополнительные изображения учитываются путем добавления соответствующих строк к вектору $e$ и матрице $J$. После вычисления обновления $\delta P$ мы можем просто повторить процесс фиксированное количество шагов или до численной сходимости.</p>
<p>Важное свойство алгоритма Гаусса-Ньютона заключается в том, что наше предположение о линейности остаточной функции вблизи оценки не гарантирует сходимость. Поэтому на практике всегда полезно установить верхнюю границу количества обновлений оценки.</p>
<h4>Резюме</h4>
<p><strong>Триангуляция</strong> представляет собой фундаментальный процесс определения местоположения трёхмерной точки по её проекциям на два или более изображений. В основе этого метода лежит работа с двумя камерами, для которых известны внутренние параметры $K$ и $K'$, а также их относительные ориентации и смещения $R$ и $T$.</p>
<p>При наличии трёхмерной точки $P$, которая проецируется на изображения в точках $p$ и $p'$, задача сводится к вычислению линий визирования $\ell$ и $\ell'$, определяемых центрами камер $O_1$ и $O_2$. В идеальном случае точка $P$ находится в точке пересечения этих линий. Однако на практике из-за шума в измерениях и неточностей калибровки камер точное пересечение линий может отсутствовать.</p>
<p>Существует два основных подхода к решению задачи триангуляции.  </p>
<p><strong>Линейный метод</strong> основан на использовании векторного произведения для формирования системы линейных уравнений вида $AP = 0$, которая решается с помощью сингулярного разложения (SVD). Несмотря на вычислительную простоту, этот метод имеет существенные ограничения, главным из которых является невозможность корректной работы с проективными преобразованиями.</p>
<p>Более эффективным является <strong>нелинейный метод триангуляции</strong>, который формулирует задачу как минимизацию ошибки репроекции. Основная идея заключается в поиске такой трёхмерной точки $\hat{P}$, которая обеспечивает минимальное расстояние между её проекциями на изображения и наблюдаемыми точками.</p>
<p>Для решения этой оптимизационной задачи широко применяется <strong>алгоритм Гаусса-Ньютона</strong>. Метод работает путём итеративного обновления оценки точки через вычисление остаточной ошибки $e$ и матрицы Якоби $J$. На каждом шаге происходит корректировка оценки по формуле:</p>
<p>$\delta P = -(J^TJ)^{-1}J^Te$</p>
<p>Важным преимуществом нелинейного подхода является его способность работать с множественными видами — дополнительные изображения просто добавляются в систему уравнений. При этом алгоритм обеспечивает более точную оценку положения точки за счёт минимизации суммарной ошибки репроекции на всех изображениях.</p>
<p>Несмотря на эффективность, метод требует разумной начальной оценки и контроля количества итераций для обеспечения сходимости. Тем не менее, нелинейная триангуляция остаётся предпочтительным выбором для практических приложений, где требуется высокая точность реконструкции трёхмерных сцен.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/epipolar-geometry/" class="u-url">Эпиполярная геометрия </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/epipolar-geometry/" rel="bookmark">
            <time class="published dt-published" datetime="2025-10-02T14:00:00+03:00" itemprop="datePublished" title="2025-10-02 14:00">2025-10-02 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h4>Введение</h4>
<p>В предыдущих разделах мы изучали методы расчёта внутренних и внешних параметров камеры. Это можно сделать с помощью стандартной процедуры калибровки камеры или используя знания о перпендикулярных плоскостях по одному изображению. В результате этих вычислений мы смогли получить определённые характеристики трёхмерного пространства.</p>
<p>Однако в общем случае невозможно восстановить полную структуру трёхмерного мира, опираясь только на одно изображение. Причина этого кроется во внутренней неоднозначности процесса отображения трёхмерного пространства на двумерную плоскость — часть информации неизбежно теряется при таком преобразовании.</p>
<p><img alt="Рисунок 1: Проблема неоднозначности" src="https://storage.yandexcloud.net/yahosting/epipolar/1.jpg"></p>
<p><strong>Рисунок 1: Проблема неоднозначности</strong></p>
<p>Рассмотрим характерный пример, показанный на рисунке 1. На первый взгляд может показаться, что человек действительно удерживает Пизанскую башню. Только при внимательном изучении изображения становится понятно, что это всего лишь оптическая иллюзия, возникшая из-за проецирования объектов с разной глубиной на плоскость изображения.</p>
<p>Если же рассмотреть эту сцену с совершенно другой точки зрения, иллюзия исчезает, и мы можем определить правильное расположение объектов в пространстве. Именно поэтому использование нескольких точек обзора является ключевым для точного понимания структуры сцены.</p>
<h4>1. Эпиполярная геометрия</h4>
<p>Эпиполярная геометрия представляет собой раздел компьютерной геометрии, который изучает взаимосвязь между точками на разных изображениях, ограничения на их расположение при проецировании и геометрические соотношения между камерами.</p>
<p><img alt="Рисунок 2: Основные элементы эпиполярной геометрии" src="https://storage.yandexcloud.net/yahosting/epipolar/2.jpg"></p>
<p><strong>Рисунок 2: Основные элементы эпиполярной геометрии</strong></p>
<p>Рассмотрим основные элементы эпиполярной геометрии, изображённые на рисунке 2:</p>
<ul>
<li>Две камеры наблюдают одну и ту же трёхмерную точку $P$  </li>
<li>Проекции точки $P$ на плоскости изображений находятся в точках $p$ и $p'$  </li>
<li>Центры камер расположены в точках $O_1$ и $O_2$  </li>
<li>Линия, соединяющая центры камер, называется <strong>базисом</strong> (оранжевая линия)  </li>
<li>Плоскость, образованная двумя центрами камер и точкой $P$, называется <strong>эпиполярной плоскостью</strong> (изображена серым цветом)  </li>
<li>Эпиполы — точки пересечения базиса с плоскостями изображений ($e$ и $e'$)   </li>
<li>Эпиполярные линии — прямые, образованные пересечением эпиполярной плоскости с плоскостями изображений (голубые отрезки)  </li>
</ul>
<p><img alt="Рисунок 3: Пример расположения эпиполярных линий и ключевых точек" src="https://storage.yandexcloud.net/yahosting/epipolar/3.jpg"></p>
<p><strong>Рисунок 3: Пример расположения эпиполярных линий и ключевых точек</strong></p>
<p>На рисунке 3 показан пример эпиполярных линий и соответствующих ключевых точек, нанесённых на пару изображений. Эта визуализация демонстрирует, как эпиполярная геометрия помогает установить связь между точками на разных снимках.</p>
<p>Таким образом, эпиполярная геометрия помогает установить связи между изображениями одной и той же сцены, снятыми с разных точек зрения, и восстанавливать трёхмерную структуру.</p>
<p><img alt="Рисунок 4: Частный случай эпиполярной геометрии" src="https://storage.yandexcloud.net/yahosting/epipolar/4.jpg"></p>
<p><strong>Рисунок 4: Частный случай эпиполярной геометрии</strong>  </p>
<p>Рассмотрим интересную ситуацию, когда плоскости изображений расположены параллельны друг другу (см. рисунок 4). 
В этом случае эпиполы $e$ и $e'$ располагаются в бесконечности. 
Это происходит потому, что <strong>базис</strong>, соединяющий центры камер $O_1$ и $O_2$, параллелен плоскостям изображений. 
Эпиполярные линии становятся параллельными оси $u$ на плоскости изображения. </p>
<p>Этот частный случай имеет важное практическое значение, особенно при работе с выравниванием изображений, о чём будет подробно рассказано в следующем разделе.</p>
<p>В практических ситуациях точное расположение трёхмерной точки $P$ неизвестно. 
Но мы можем определить её проекции $p, p'$ на плоскости изображений, местоположение, ориентацию и внутренние параметры камер. </p>
<p>Кроме того, зная положения камер $O_1$, $O_2$ и положение проекции точки $p$ на одном изображении, можно определить эпиполярную плоскость и найти эпиполярные линии на основе этой плоскости. Это существенно упрощает поиск соответствующей ключевой точки на других изображениях. Это свойство делает эпиполярную геометрию мощным инструментом в задачах компьютерного зрения и трёхмерной реконструкции сцены.</p>
<h4>2. Эссенциальная матрица</h4>
<p>Для создания эффективного способа отображения точек и эпиполярных линий между разными видами сцены мы используем базовую структуру эпиполярной геометрии. 
В этой системе матрицы проекции $M$ и $M'$ отвечают за преобразование трёхмерных точек в двумерные координаты на плоскостях изображений.
Мировая система координат связывается с первой камерой, при этом вторая камера смещается относительно первой через последовательное применение поворота $R$ и переноса $T$.</p>
<p><img alt="Рисунок 5: Расположение второй камеры относительно первой" src="https://storage.yandexcloud.net/yahosting/epipolar/5.jpg"></p>
<p><strong>Рисунок 5: Расположение второй камеры относительно первой</strong></p>
<p>В результате того, что за точку отсчета мировых координат мы принимаем центр камеры $O_1$, матрицы проекции принимают следующий вид:</p>
<p>$M = K \begin{bmatrix} I &amp; 0 \end{bmatrix}$ (2)</p>
<p>$M' = K' \begin{bmatrix} R &amp; -RT \end{bmatrix}$</p>
<p>где $K$ и $K'$ представляют внутренние параметры камер, $I$ — единичная матрица, $R$ отвечает за поворот, а $T$ — за перенос (вектор $O_1 O_2$).</p>
<p>Рассмотрим частный случай с каноническими камерами:  </p>
<p>$K = K' = I$  </p>
<p>$p'$ - это координаты проекции точки в системе координат второй камеры. 
Координаты точки $p'$ в системе координат первой камеры определяются как $Rp' + T$.  </p>
<p>Поскольку векторы $Rp' + T$ и $T$ лежат в эпиполярной плоскости, их векторное произведение даёт вектор, перпендикулярный этой плоскости.<br>
Благодаря свойствам дистрибутивности векторного произведения получаем результат: </p>
<p>$T \times (Rp' + T) = T \times (Rp')$ </p>
<p>Точка $p$, лежащая в эпиполярной плоскости, ортогональна вектору $T \times (Rp')$, что даёт ограничение:</p>
<p>$p^T \cdot [T \times (Rp')] = 0$ (3)</p>
<p>Напомним, <strong>векторное произведение</strong> — это операция над двумя векторами в трёхмерном пространстве, результатом которой является новый вектор.
Результат — вектор, перпендикулярный обоим исходным векторам, его длина равна площади параллелограмма, построенного на исходных векторах, а направление определяется правилом правой руки</p>
<p>Пусть даны два вектора:</p>
<p>$\vec{a} = (a_1, a_2, a_3)$</p>
<p>$\vec{b} = (b_1, b_2, b_3)$</p>
<p>Их векторное произведение:</p>
<p>$\vec{a} \times \vec{b} = \begin{vmatrix}
\vec{i} &amp; \vec{j} &amp; \vec{k} \\
a_1 &amp; a_2 &amp; a_3 \\
b_1 &amp; b_2 &amp; b_3
\end{vmatrix}$</p>
<p>где $\vec{i}, \vec{j}, \vec{k}$ — единичные векторы по осям координат.</p>
<p>Формула для вычисления имеет вид: </p>
<p>$\vec{a} \times \vec{b} = (a_2b_3 - a_3b_2, a_3b_1 - a_1b_3, a_1b_2 - a_2b_1)$</p>
<p>Вернемся к эпиполярной геометрии. </p>
<p>Используя аппарат линейной алгебры, векторное произведение можно представить в виде матрично-векторного умножения:</p>
<p>$a \times b = \begin{bmatrix} 0 &amp; -a_z &amp; a_y \\ a_z &amp; 0 &amp; -a_x \\ -a_y &amp; a_x &amp; 0 \end{bmatrix} \begin{bmatrix} b_x \\ b_y \\ b_z \end{bmatrix} = [a\times]b$ (4)</p>
<p>Преобразуя выражение с учётом этого представления, получаем:</p>
<p>$p^T[T\times]Rp' = 0$ (5)</p>
<p>Матрица $E = [T\times]R$ называется <strong>эссенциальной матрицей</strong> и даёт компактную форму эпиполярного ограничения:</p>
<p>$p^TEp' = 0$ (6)</p>
<p>Эссенциальная матрица — это матрица размером $3 \times 3$, содержащая 5 степеней свободы. Она имеет ранг 2 и является сингулярной.</p>
<p>Эта матрица полезна для вычисления эпиполярных линий. Например, $l' = E^Tp$ даёт эпиполярную линию в плоскости изображения второй камеры, а $l = Ep'$ — в плоскости первой камеры.</p>
<p>Важные свойства эссенциальной матрицы:
* Её скалярное произведение с эпиполями равно нулю: $E^Te = Ee' = 0$
* Для любой точки $x$ (кроме $e$) в изображении первой камеры соответствующая эпиполярная линия во второй камере содержит эпиполь $e'$</p>
<p>Таким образом, эссенциальная матрица является фундаментальным инструментом для работы с эпиполярной геометрией и установления связей между точками на разных изображениях. </p>
<h4>3. Фундаментальная матрица</h4>
<p><strong>Фундаментальная матрица</strong> — это важный инструмент в эпиполярной геометрии, который обобщает концепцию эссенциальной матрицы на случай камер с нетривиальными внутренними параметрами.</p>
<p>Рассмотрим матрицы проекции для двух камер:</p>
<p>$M = K \begin{bmatrix} I &amp; 0 \end{bmatrix}$</p>
<p>$M' = K' \begin{bmatrix} R &amp; -RT \end{bmatrix}$ (7)</p>
<p>Для работы с неканоническими камерами введём обозначения:
* $p_c = K^{-1}p$ — проекция точки $p$ для канонической камеры
* $p'_c = K'^{-1}p'$ — проекция точки $p'$ для канонической камеры</p>
<p>В каноническом случае (единичная матрица $K$) выполняется соотношение:</p>
<p>$p_c^T [T \times] R p'_c = 0$ (8)</p>
<p>Однако, с учетом преобразований внутренних параметров камеры, получаем:</p>
<p>$p^T K^{-T} [T \times] R K'^{-1} p' = 0$ (9)</p>
<p>Матрица $F = K'^{-T} [T \times] R K^{-1}$ называется <strong>фундаментальной матрицей</strong>.<br>
Она обобщает свойства эссенциальной матрицы, учитывает параметры камер $K$ и $K'$ и содержит информацию о взаимном положении камер. (вращение $R$ и перенос $T$).
очками на разных изображениях
Фундаментальная матрица имеет 7 степеней свободы (против 5 у эссенциальной матрицы), позволяет находить эпиполярные линии без знания 3D-координат точек и работает даже при неизвестных параметрах камер. </p>
<p>Таким образом, фундаментальная матрица даёт мощный инструмент для установления связей между точками на разных изображениях, не требуя полной информации о параметрах камер или трёхмерных координатах точек.</p>
<h4>4. Алгоритм восьми точек для вычисления фундаментальной матрицы</h4>
<p><strong>Алгоритм восьми точек</strong> — это метод оценки фундаментальной матрицы по двум изображениям сцены без знания параметров камер. Метод был предложен Лонге-Хиггинсом в 1981 году и расширен Хартли в 1995 году.</p>
<p><img alt="Рисунок 6: Ключевые точки и их соответствие на двух изображениях" src="https://storage.yandexcloud.net/yahosting/epipolar/6.jpg"></p>
<p><strong>Рисунок 6: Ключевые точки и их соответствие на двух изображениях</strong></p>
<p>Для работы алгоритма требуется минимум 8 пар соответствующих точек между двумя изображениями. 
Каждая пара точек $p_i = (u_i, v_i, 1)$ и $p'_i = (u'_i, v'_i, 1)$ даёт ограничение $p_i^TFp'_i = 0$. </p>
<p>Математически ограничение можно представить в виде:</p>
<p>$\begin{bmatrix}
u_iu'<em 11>i &amp; v'_iu_i &amp; u_iu'_i &amp; v_iu'_i &amp; v_iv'_i &amp; v_iu'_i &amp; v'_i &amp; 1
\end{bmatrix}
\begin{bmatrix}
F</em>
\end{bmatrix} = 0$} \\ F_{12} \\ F_{13} \\ F_{21} \\ F_{22} \\ F_{23} \\ F_{31} \\ F_{32} \\ F_{33</p>
<p>Практическая реализация для $N ≥ 8$ соответствий формируется система уравнений:</p>
<p>$Wf = 0$,</p>
<p>где:
* $W$ — матрица размером $N × 9$
* $f$ — вектор элементов фундаментальной матрицы</p>
<p>На практике эффективнее использовать больше восьми соответствий и создавать более крупную матрицу W, поскольку это снижает влияние зашумлённых измерений. </p>
<p>Решение этой системы однородных уравнений можно найти методом наименьших квадратов с помощью сингулярного разложения (SVD), так как матрица W является дефектной по рангу. </p>
<p>SVD даёт оценку фундаментальной матрицы $\hat{F}$, которая может иметь полный ранг. Однако истинная фундаментальная матрица имеет ранг 2, поэтому нужно искать решение, которое является наилучшим приближением ранга 2 для $\hat{F}$.</p>
<p>Математически это формулируется как задача оптимизации:</p>
<p>$\min_F ||F - \hat{F}||_F$ при условии $\det(F) = 0$</p>
<p>где:
* $||\cdot||_F$ — норма Фробениуса
* $\det(F) = 0$ — условие, обеспечивающее ранг матрицы равный 2</p>
<p>Напомним, сингулярное разложение (SVD) для приблизительной оценки матрицы имеет вид:</p>
<p>$\hat{F} = U\Sigma V^T$</p>
<p>Искомая матрица $F$ будет иметь наилучшее приближение 2 ранга:</p>
<p>$F = U
   \begin{bmatrix}
   \sigma_1 &amp; 0 &amp; 0 \\
   0 &amp; \sigma_2 &amp; 0 \\
   0 &amp; 0 &amp; 0
   \end{bmatrix}
   V^T$</p>
<p>где $\sigma_1$ и $\sigma_2$ — первые два сингулярных числа матрицы $\hat{F}$.</p>
<p>Такой подход гарантирует схранение геометрических свойств фундаментальной матрицы, минимизацию отклонения от исходной оценки и сохранение ранга 2. </p>
<p>Таким образом, алгоритм позволяет оценить фундаментальную матрицу без знания параметров камер и является основой для многих задач стереовидения и трёхмерной реконструкции. </p>
<h4>5. Нормализованный алгоритм восьми точек</h4>
<p><strong>Стандартная реализация</strong> алгоритма восьми точек часто даёт неточные результаты. Обычное расстояние между точкой $p_i$ и соответствующей эпиполярной линией $l_i = Fp'_i$ может достигать 10 и более пикселей.</p>
<p>Основная проблема заключается в том, что матрица $W$ плохо обусловлена, это создает проблемы для алгоритма SVD. 
Основная причина - большие абсолютные значения координат точек (например, $p_i = (1832, 1023, 1)$)
Проблема усугубляется, если  точки $p_i$ и $p'_i$ находятся в небольшой области изображения, при наличии одного большого сингулярного значения при малых остальных. </p>
<p>Для решения этой проблемы и улучшения точности используется <strong>нормализация координат</strong>. 
1. Сдвиг координат так, чтобы начало новой системы находилось в центре масс точек
2. Масштабирование координат так, чтобы среднеквадратичное расстояние от начала координат равнялось 2 пикселям</p>
<p>Для реализации используются матрицы преобразования $T$ и $T'$, которые выполняют сдвиг на центроид и применяют масштабирующий коэффициент $\left(\frac{2N}{\sum_{i=1}^N||x_i - \bar{x}||^2}\right)^{1/2}$</p>
<p>Нормализованные координаты вычисляются как:<br>
$q_i = Tp_i$<br>
$q'_i = T'p'_i$  </p>
<p>Далее, используя нормализованные координаты, вычисляется матрица $F_q$ стандартным методом и производится денормализация:  </p>
<p>$F = T'^TF_qT$</p>
<p>Нормализованный алгоритм обеспечивает:<br>
- Более точные результаты в реальных приложениях<br>
- Улучшенную обусловленность матрицы $W$<br>
- Снижение влияния больших значений координат<br>
- Повышение точности оценки фундаментальной матрицы  </p>
<p>Такой подход значительно улучшает качество оценки фундаментальной матрицы и является предпочтительным методом для практического применения. </p>
<h4>6. Выравнивание изображений (Image Rectification)</h4>
<p><strong>Особое свойство эпиполярной геометрии</strong> проявляется, когда два изображения параллельны друг другу. 
Рассмотрим частный случай параллельных плоскостей изображений.</p>
<p>Камеры имеют одинаковую матрицу $K$, отсутствует относительное вращение ($R = I$) и есть только перенос вдоль оси $x$ ($T = (T_x, 0, 0)$)</p>
<p>В этом случае эссенциальная матрица принимает вид:</p>
<p>$E = [T×]R = \begin{bmatrix} 
0 &amp; 0 &amp; 0 \\ 
0 &amp; 0 &amp; -T_x \\ 
0 &amp; T_x &amp; 0 
\end{bmatrix}$ (17)</p>
<p>Направление эпиполярной линии для точки $p' = (u', v', 1)$ вычисляется как:</p>
<p>$l = Ep' = \begin{bmatrix} 
0 &amp; 0 &amp; 0 \\ 
0 &amp; 0 &amp; -T_x \\ 
0 &amp; T_x &amp; 0 
\end{bmatrix}
\begin{bmatrix} 
u' \\ 
v' \\ 
1 
\end{bmatrix} = 
\begin{bmatrix} 
0 \\ 
-T_x \\ 
T_xv' 
\end{bmatrix}$ (18)</p>
<p>В этом случае направление эпиполярной линии $l$ горизонтально. 
Аналогично, направление $l'$ также горизонтально, а все эпиполярные линии параллельны друг другу.<br>
Такое выравнивание изображений позволяет значительно упростить поиск соответствий между точками и упрощает стереообработку и трёхмерную реконструкцию сцены.</p>
<p><img alt="Рисунок 7: Ректификация (выравнивание) изображений" src="https://storage.yandexcloud.net/yahosting/epipolar/7.jpg"></p>
<p><strong>Рисунок 7: Ректификация (выравнивание) изображений</strong></p>
<p>Если мы используем <strong>эпиполярное ограничение</strong> $p^T E p' = 0$, то приходим к тому, что $v = v'$. Это показывает, что точки $p$ и $p'$ имеют одинаковую координату $v$.</p>
<p>Следовательно, между соответствующими точками существует очень простая взаимосвязь. Поэтому <strong>выравнивание</strong> (процесс приведения любых двух заданных изображений к параллельному виду) становится полезным при определении взаимосвязей между соответствующими точками на изображениях.</p>
<p><img alt="Рисунок 8: Вычисление гомографий ректификации" src="https://storage.yandexcloud.net/yahosting/epipolar/8.jpg"></p>
<p><strong>Рисунок 8: Вычисление гомографий ректификации</strong></p>
<p>Выравнивание пары изображений не требует знания матриц камер $K$ и $K'$ или относительного преобразования $R$, $T$ между ними. Вместо этого можно использовать <strong>фундаментальную матрицу</strong>, оценённую с помощью <strong>нормализованного алгоритма восьми точек</strong>.</p>
<p>После получения фундаментальной матрицы можно вычислить <strong>эпиполярные линии</strong> $l_i$ и $l'_i$ для каждой пары соответствующих точек $p_i$ и $p'_i$.</p>
<p>На основе набора эпиполярных линий можно оценить <strong>эпиполи</strong> $e$ и $e'$ для каждого изображения. Это возможно потому, что эпиполь лежит в точке пересечения всех эпиполярных линий.</p>
<p>В реальных условиях из-за зашумлённых измерений все эпиполярные линии не пересекаются в одной точке. Поэтому вычисление эпиполя можно найти путём минимизации среднеквадратичной ошибки подгонки точки ко всем эпиполярным линиям.</p>
<p>Каждая эпиполярная линия может быть представлена в виде вектора $l$ так, что все точки на линии (в однородных координатах) принадлежат множеству ${x | l^T x = 0}$. 
Если определить каждую эпиполярную линию как $l_i = [l_{i,1}, l_{i,2}, l_{i,3}]^T$, то можно сформулировать линейную систему уравнений и решить её с помощью <strong>сингулярного разложения</strong> (SVD) для нахождения эпиполя $e$.</p>
<p>$\begin{bmatrix}
l^T_1 \\
\vdots \\
l^T_n
\end{bmatrix} e = 0$</p>
<p>После нахождения эпиполей $e$ и $e'$, мы, скорее всего, обнаружим, что они не являются точками на бесконечности вдоль горизонтальной оси. Если бы это было так, то изображения уже были бы параллельными по определению.</p>
<p>Это наводит на мысль: можно ли найти <strong>гомографию</strong>, которая отобразит эпиполь $e$ в бесконечность вдоль горизонтальной оси?</p>
<p>Все что нам нужно - это найти пару гомографий $H_1$ и $H_2$, применить их к изображениям и отобразить эпиполи в бесконечность. </p>
<p>Начнём с поиска гомографии $H_2$, которая отображает второй эпиполь $e'$ в точку на горизонтальной оси в бесконечности $(f, 0, 0)$.</p>
<p>Хотя существует множество вариантов такой гомографии, на практике хорошо работает условие, при котором гомография действует как преобразование и применяет перенос и поворот к точкам около центра изображения. </p>
<p>Первый шаг — сдвиг второго изображения так, чтобы его центр оказался в точке $(0, 0, 1)$ в однородных координатах. Это достигается применением матрицы переноса.</p>
<p>$T = \begin{bmatrix}
1 &amp; 0 &amp; -\frac{width}{2} \\
0 &amp; 1 &amp; -\frac{height}{2} \\
0 &amp; 0 &amp; 1
\end{bmatrix}$ (20)</p>
<p>После применения переноса мы выполняем поворот, чтобы разместить эпиполь на горизонтальной оси в некоторой точке $(f, 0, 1)$.</p>
<p>Если перенесённый эпиполь $T e'$ находится в однородных координатах $(e'_1, e'_2, 1)$, то применяемый поворот определяется следующим образом:</p>
<p>$R = \begin{bmatrix}
\alpha\frac{e'_1}{\sqrt{e'^2_1 + e'^2_2}} &amp; \alpha\frac{e'_2}{\sqrt{e'^2_1 + e'^2_2}} &amp; 0 \\
-\alpha\frac{e'_2}{\sqrt{e'^2_1 + e'^2_2}} &amp; \alpha\frac{e'_1}{\sqrt{e'^2_1 + e'^2_2}} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}$ (21) </p>
<p>где параметр $\alpha$ определяется следующим образом:<br>
$\alpha = 1$, если $e'_1 \geq 0$<br>
$\alpha = -1$ в противном случае. </p>
<p>После применения этого поворота заметим, что для любой точки $(f, 0, 1)$ перевод её в точку на бесконечности по горизонтальной оси $(f, 0, 0)$ требует применения преобразования:</p>
<p>$G = \begin{bmatrix} 
1 &amp; 0 &amp; 0 \\ 
0 &amp; 1 &amp; 0 \\ 
-\frac{1}{f} &amp; 0 &amp; 1 
\end{bmatrix}$</p>
<p>После применения этого преобразования мы наконец получаем эпиполь в бесконечности, поэтому можем вернуться к обычному пространству изображения.</p>
<p>Таким образом, гомография $H_2$, которую мы применяем ко второму изображению для его выравнивания, имеет вид:</p>
<p>$H_2 = T^{-1}GRT$ (23)</p>
<p>Теперь, когда мы нашли допустимую $H_2$, нам нужно найти подходящую гомографию $H_1$ для первого изображения. Мы делаем это путём поиска такого преобразования $H_1$, которое минимизирует сумму квадратов расстояний между соответствующими точками изображений:</p>
<p>$\arg\min_{H_1} \sum_{i} ||H_1p_i - H_2p'_i||^2$</p>
<p>В результате мы получаем пару гомографий ($H_1$, $H_2$), которые позволяют выровнять изображения, сделать эпиполярные линии горизонтальными и упростить поиск соответствий между точками. </p>
<p>Можно доказать, что подходящая гомография $H_1$ имеет следующий вид:</p>
<p>$H_1 = H_A H_2 M$ (25)</p>
<p>где:
* $F = [e]\times M$
* $H_A$ — специальная матрица вида:</p>
<p>$H_A = \begin{bmatrix} 
a_1 &amp; a_2 &amp; a_3 \\ 
0 &amp; 1 &amp; 0 \\ 
0 &amp; 0 &amp; 1 
\end{bmatrix}$ (26)</p>
<p>Здесь $(a_1, a_2, a_3)$ — компоненты определённого вектора $a$, который будет вычислен позже.</p>
<p>Разберём структуру этого выражения:</p>
<p><strong>Матрица $H_A$</strong> представляет собой линейное преобразование вдоль оси $x$, координаты $y$ и $z$ остаются неизменными. 
$H_2$ — уже известная гомография для второго изображения<br>
$M$ — вспомогательная матрица, связанная с фундаментальной матрицей $F$<br>
$[e]\times$ — кососимметричная матрица, построенная на векторе $e$  </p>
<p><strong>Кососимметричная матрица</strong> обладает свойством $A = A^3$ с точностью до масштаба.</p>
<p>Поскольку:
* Матрица векторного произведения $[e]\times$ — кососимметричная
* Фундаментальная матрица $F$ известна только с точностью до масштаба</p>
<p>Получаем:</p>
<p>$F = [e]\times M = [e]\times[e]\times[e]\times M = [e]\times[e]\times F$ (27)</p>
<p>Отсюда следует:</p>
<p>$M = [e]\times F$ (28)</p>
<p>Важно заметить: если к столбцам $M$ добавить любое скалярное кратное вектора $e$, равенство $F = [e]\times M$ сохраняется.</p>
<p>Поэтому более общий вид $M$:</p>
<p>$M = [e]\times F + ev^T$ (29)</p>
<p>На практике хорошо работает выбор $v^T = [1, 1, 1]$.</p>
<p>Для нахождения $H_1$ нужно вычислить значения вектора $a$ в матрице $H_A$.</p>
<p>Задача сводится к минимизации:</p>
<p>$\arg\min_{H_A} \sum_{i} ||H_A\hat{p}_i - \hat{p}'_i||^2$ (30)</p>
<p>где:
* $\hat{p}_i = H_2Mp_i$
* $\hat{p}'_i = H_2p'_i$</p>
<p>При этом $H_2$ и $M$ уже известны. </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/single-view-metrology/" class="u-url">Измерение углов </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/single-view-metrology/" rel="bookmark">
            <time class="published dt-published" datetime="2025-10-01T14:00:00+03:00" itemprop="datePublished" title="2025-10-01 14:00">2025-10-01 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h4>Введение</h4>
<p>На предыдущих лекциях мы обсуждали, как можно преобразовывать точки из реального трёхмерного мира в цифровые изображения, используя внешние и внутренние характеристики камер. Мы рассмотрели, как можно использовать известную структуру калибровочной установки и соответствующие изображения для определения характеристик камеры. </p>
<p>Теперь мы обратимся к смежной проблеме: можно ли восстановить известную структуру трёхмерного мира, если у нас есть единственное изображение и известны свойства камеры, которой это изображение было сделано? И наконец мы рассмотрим алгоритм калибровки камеры и измерения углов между плоскостями на одиночном изображении. </p>
<h4>1. Преобразования в 2D пространстве</h4>
<p>Чтобы лучше понять, как мы можем извлекать информацию из изображений, сначала необходимо разобраться с различными преобразованиями в двумерном пространстве.</p>
<p><strong>Изометрические преобразования</strong> — это преобразования, сохраняющие расстояния. В своей базовой форме изометрия может быть описана как вращение $R$ и перенос $t$. Математически они определяются следующим образом:</p>
<p>$\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix} = 
\begin{bmatrix}
R &amp; t \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}$</p>
<p>где $(x', y', 1)^T$ — точка, полученная после изометрического преобразования.</p>
<p><strong>Преобразования подобия</strong> — это преобразования, сохраняющие форму. Интуитивно они могут выполнять всё то же, что и изометрические преобразования, плюс масштабирование. Математически они обозначаются так:</p>
<p>$\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix} = 
\begin{bmatrix}
SR &amp; t \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix} $  </p>
<p>$ S = 
\begin{bmatrix}
s &amp; 0 \\
0 &amp; s
\end{bmatrix}$</p>
<p><strong>Преобразования подобия</strong> сохраняют форму объектов, а значит, сохраняют:<br><em> Отношения длин отрезков<br></em> Величины углов  </p>
<p>Важно отметить, что любое <strong>изометрическое преобразование</strong> является частным случаем преобразования подобия при $s = 1$. Однако обратное утверждение неверно.</p>
<p><strong>Аффинные преобразования</strong> сохраняют:<br><em> Точки<br></em> Прямые линии<br>
* Параллельность прямых  </p>
<p>Для вектора $v$ аффинное преобразование $T$ определяется как:
$T(v) = Av + t$, где $A$ — линейное преобразование пространства $R^n$</p>
<p>В однородных координатах аффинные преобразования записываются так:  </p>
<p>$\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix} = 
\begin{bmatrix}
A &amp; t \\
0 &amp; 1
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}$</p>
<p>Из этого уравнения видно, что все преобразования подобия (и, следовательно, изометрии) являются частным случаем аффинных преобразований.</p>
<p><strong>Проективные преобразования</strong> (или гомографии) — это преобразования, которые переводят прямые в прямые, но не обязательно сохраняют параллельность.</p>
<p>В однородных координатах проективные преобразования представляются как: </p>
<p>$\begin{bmatrix}
x' \\
y' \\
1
\end{bmatrix} = 
\begin{bmatrix}
A &amp; t \\
v &amp; b
\end{bmatrix}
\begin{bmatrix}
x \\
y \\
1
\end{bmatrix}$</p>
<p>Это представление является обобщением аффинных преобразований за счёт добавления вектора $v$, который вводит дополнительные степени свободы.</p>
<p>Несмотря на то, что проективные преобразования не сохраняют параллельность, они сохраняют:<br><em> Коллинеарность точек (прямые переходят в прямые)<br></em> Перекрестное отношение четырёх коллинеарных точек.  </p>
<p><strong>Перекрестное отношение</strong> четырёх точек $P_1, P_2, P_3, P_4$, лежащих на одной прямой, вычисляется по формуле:  </p>
<p>$cross\ ratio = \frac{||P_3 - P_1||\ ||P_4 - P_2||}{||P_3 - P_2||\ ||P_4 - P_1||}$ (1)</p>
<p>Доказательство инвариантности перекрестного отношения при проективных преобразованиях предлагается выполнить в качестве учебного упражнения. </p>
<h4>2. Точки и прямые в бесконечности</h4>
<p>Прямые играют важную роль в определении структуры изображений, поэтому важно понимать их представление как в 2D, так и в 3D пространстве.</p>
<p><strong>Прямая на плоскости</strong> может быть представлена однородным вектором $\ell = \begin{bmatrix} a &amp; b &amp; c \end{bmatrix}^T$.  </p>
<p>Отношение $-\frac{a}{b}$ определяет наклон прямой, а отношение $-\frac{c}{b}$ — точку пересечения с осью $y$.  </p>
<p>Для любой точки, лежащей на прямой, справедливо уравнение:</p>
<p>$\forall p = \begin{bmatrix} x \\ y \end{bmatrix} \in \ell, \quad \begin{bmatrix} a &amp; b &amp; c \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix} = 0$ (2)</p>
<p><strong>Пересечение прямых</strong><br>
В общем случае две прямые $\ell$ и $\ell'$ пересекаются в точке $x$, которая определяется как векторное произведение этих прямых.</p>
<ul>
<li>Доказательство: если две прямые пересекаются, точка пересечения $x$ должна лежать на обеих прямых. Следовательно, $x^T\ell = 0$ и $x^T\ell' = 0$. Если мы положим $x = \ell \times \ell'$, то по определению векторного произведения вектор $x$ будет ортогонален обоим векторам $\ell$ и $\ell'$.</li>
</ul>
<p><strong>Параллельные прямые</strong><br>
В школьной геометрии считается, что параллельные прямые не пересекаются. Однако в однородных координатах можно сказать, что они пересекаются в бесконечности.  </p>
<p>Рассмотрим две параллельные прямые $\ell$ и $\ell'$. Когда прямые параллельны, их наклоны равны: $\frac{a}{b} = \frac{a'}{b'}$. Если вычислить точку пересечения в однородных координатах, получим:</p>
<p>$\ell \times \ell' \propto \begin{bmatrix} b \\ -a \\ 0 \end{bmatrix} = x_\infty$ (3)</p>
<p>Это подтверждает, что параллельные прямые пересекаются в бесконечности. Точка пересечения параллельных прямых в бесконечности называется <strong>идеальной точкой</strong>. </p>
<p>В однородных координатах идеальная точка в бесконечности представляется как:</p>
<p>$\begin{bmatrix} x \ y \ 0 \end{bmatrix}^T$ </p>
<p><strong>Свойство идеальных точек</strong>
Все параллельные прямые с одинаковым наклоном $-\frac{a}{b}$ проходят через идеальную точку:</p>
<p>$\ell^T x_\infty = \begin{bmatrix} a &amp; b &amp; c \end{bmatrix} \begin{bmatrix} b \\ -a \\ 0 \end{bmatrix} = 0$ (4)</p>
<p><strong>Бесконечно удалённые точки</strong> позволяют определить прямую в бесконечности. Рассмотрим несколько пар параллельных прямых. Каждая пара пересекается в своей точке бесконечности $x_{\infty,i}$. Прямая $\ell_\infty$, проходящая через все эти точки, должна удовлетворять условию:</p>
<p>$\forall i, \ell_\infty^T x_{\infty,i} = 0$</p>
<p><img alt="Рисунок 1: Точки в бесконечности образуют прямые в бесконечности" src="https://storage.yandexcloud.net/yahosting/photo_metro/1.jpg"></p>
<p><strong>Рисунок 1: Точки в бесконечности образуют прямые в бесконечности</strong>  </p>
<p>Такая прямая имеет вид $\ell_\infty = \begin{bmatrix} 0 &amp; 0 &amp; c \end{bmatrix}^T$. Поскольку $c$ — произвольное значение, можно принять:</p>
<p>$\ell_\infty = \begin{bmatrix} 0 &amp; 0 &amp; 1 \end{bmatrix}^T$</p>
<p><strong>Проективное преобразование</strong> точки в бесконечности:</p>
<p>При применении проективного преобразования $H$ к точке в бесконечности $p_\infty$ получаем:</p>
<p>$p' = Hp_\infty = \begin{bmatrix} A &amp; t \\ v &amp; b \end{bmatrix} \begin{bmatrix} 1 \\ 1 \\ 0 \end{bmatrix} = \begin{bmatrix} p'_x \\ p'_y \\ p'_z \end{bmatrix}$ (5)</p>
<p>Заметим, что последний элемент $p'$ может стать ненулевым. Это означает, что проективное преобразование обычно переводит точки в бесконечности в точки, которые уже не находятся в бесконечности. Т.е. имеют конечные евклидовы координаты, пусть и за пределами изображения. </p>
<p><strong>Аффинные преобразования</strong> ведут себя иначе и всегда переводят точку из бесконечности в бесконечность:</p>
<p>$p' = Hp_\infty = \begin{bmatrix} A &amp; t \\ 0 &amp; 1 \end{bmatrix} \begin{bmatrix} 1 \\ 1 \\ 0 \end{bmatrix} = \begin{bmatrix} p'_x \\ p'_y \\ 0 \end{bmatrix}$ (6)</p>
<p><strong>Преобразование прямых</strong></p>
<p>При применении проективного преобразования $H$ к прямой $\ell$ получаем новую прямую $\ell'$. Все точки $x$, лежащие на прямой, должны удовлетворять условию $x^T\ell = 0$. В преобразованном пространстве прямые переходят в прямые, то есть $x'^T\ell' = 0$. Используя свойство тождественного преобразования, получаем:</p>
<p>$x^TI\ell = x^TH^TH^{-T}\ell = 0$</p>
<p>При применении <strong>проективного преобразования</strong> к прямой происходит преобразование всех точек, лежащих на ней. Если $x$ — точка исходной прямой, то после преобразования получаем:</p>
<p>$x' = Hx$</p>
<p>Используя это преобразование, можно записать:</p>
<p>$x^TH^TH^{-T}\ell = x'^T\ell'$,</p>
<p>откуда следует, что проективное преобразование прямой имеет вид:</p>
<p>$\ell' = H^{-T}\ell$</p>
<p>Важные выводы:<br><em> При проективном преобразовании прямая в бесконечности не обязательно переходит в другую прямую в бесконечности<br></em> В отличие от этого, <strong>аффинные преобразования</strong> сохраняют прямые в бесконечности, переводя их в прямые в бесконечности.  </p>
<p>Эти свойства имеют важное значение для понимания того, как различные типы преобразований влияют на структуру изображения и геометрию сцены. Особенно это касается работы с бесконечно удалёнными точками и прямыми, которые играют ключевую роль в проективной геометрии и компьютерном зрении.</p>
<p>Таким образом, при работе с проективными преобразованиями необходимо учитывать, что они могут существенно изменять геометрию сцены, в том числе расположение прямых и точек в бесконечности, в то время как аффинные преобразования сохраняют некоторые геометрические свойства. </p>
<h4>3. Точки и линии схода</h4>
<p>В трёхмерном пространстве вводится понятие <strong>плоскости</strong>, которая представляется вектором $\begin{bmatrix} a &amp; b &amp; c &amp; d \end{bmatrix}^T$. 
Здесь $(a, b, c)$ образуют вектор нормали, а $d$ — расстояние от начала координат до плоскости в направлении этого вектора. Формально плоскость определяется как множество точек $x$, удовлетворяющих уравнению:</p>
<p>$x^T \begin{bmatrix} a \\ b \\ c \\ d \end{bmatrix} = ax_1 + bx_2 + cx_3 + d = 0$ (7)</p>
<p><strong>Прямые в 3D</strong> определяются как пересечение двух плоскостей. Они имеют четыре степени свободы (точка пересечения и наклоны в трёх измерениях).</p>
<p><strong>Точки в бесконечности</strong> в 3D определяются как точки пересечения параллельных прямых. При проективном преобразовании таких точек получается <strong>точка схода</strong> $p_\infty$ на плоскости изображения.</p>
<p>Существует полезное соотношение между параллельными прямыми в 3D, их точкой схода на изображении и параметрами камеры $K$, $R$, $T$.</p>
<p>Пусть $d = (a, b, c)$ — направление набора параллельных прямых в системе координат камеры. Тогда точка схода $v$ определяется как:</p>
<p>$v = Kd$ (8)</p>
<p>Отсюда можно выразить направление $d$:</p>
<p>$d = \frac{K^{-1}v}{|K^{-1}v|}$ (9)</p>
<p><strong>Линия горизонта</strong> (или линия схода) $l_{horiz}$ — это проекция линии в бесконечности на плоскость изображения. Она проходит через соответствующие точки схода на изображении и вычисляется по формуле:</p>
<p>$l_{horiz} = H^{-T}P l_\infty$ (10)</p>
<p>Точки и линии схода являются важными инструментами для анализа структуры сцены и определения параметров камеры по изображению, т.к. они позволяют восстанавливать трёхмерную геометрию по двумерной проекции. </p>
<p><img alt="Рисунок 2: Линия горизонта как множество точек схода" src="https://storage.yandexcloud.net/yahosting/photo_metro/2.jpg"></p>
<p><strong>Линия горизонта</strong> позволяет нам интуитивно определять свойства изображения, которые могут быть неочевидны с математической точки зрения. Например,  линии на земле не выглядят параллельными на изображении (как показано на рисунке 2), но интуитивно мы все же понимаем, что в трёхмерном пространстве они параллельны.</p>
<p>Линия горизонта позволяет <strong>вычислять</strong> важные характеристики сцены. Существует интересное соотношение между нормалью $n$ плоскости в 3D и соответствующей линией горизонта $l_{horiz}$ на изображении:</p>
<p>$n = K^Tl_{horiz}$ (11)</p>
<p>Это означает, что если мы можем определить линию горизонта, связанную с плоскостью, и знаем внутренние характеристики камеры $K$, мы можем оценить ориентацию этой плоскости.</p>
<p>Теперь давайте рассмотрим понятие <strong>плоскость в бесконечности</strong>.  </p>
<p><img alt="Рисунок 3: Плоскость в бесконечности" src="https://storage.yandexcloud.net/yahosting/photo_metro/3.jpg"></p>
<p><strong>Рисунок 3: Плоскость в бесконечности</strong></p>
<p>Эта плоскость определяется набором из двух или более линий схода. В однородных координатах плоскость описывается вектором:</p>
<p>$Π_\infty = \begin{bmatrix} 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}^T$ </p>
<p>Плоскость в бесконечности поможет нам понять важное свойство, связывающее линии и плоскости в 3D с соответствующими точками и линиями схода на плоскости изображения.  </p>
<p><img alt="Рисунок 4: Определение угла между линиями" src="https://storage.yandexcloud.net/yahosting/photo_metro/4.jpg"></p>
<p><strong>Рисунок 4: Определение угла между линиями</strong>  </p>
<p>Пусть две пары параллельных линий в 3D имеют направления $d_1$ и $d_2$, связанные с точками в бесконечности $x_{1,\infty}$ и $x_{2,\infty}$. 
Пусть $v_1$ и $v_2$ — соответствующие точки схода. 
Тогда угол $θ$ между $d_1$ и $d_2$ определяется по формуле:</p>
<p>$\cos θ = \frac{d_1 \cdot d_2}{|d_1||d_2|} = \frac{v_1^T \omega v_2}{\sqrt{v_1^T \omega v_1} \sqrt{v_2^T \omega v_2}}$ (12)</p>
<p>где $\omega = (KK^T)^{-1}$.  </p>
<p><strong>Матрица $\omega$</strong> определяется через матрицу камеры $K$ следующим образом:</p>
<p>$\omega = (K K^T)^{-1}$</p>
<p>Эта матрица имеет важные свойства:  </p>
<ol>
<li>
<p>Симметричность: матрица $\omega$ является симметричной, так как $K K^T$ — симметричная матрица, а обратная к симметричной матрице также симметрична</p>
</li>
<li>
<p>Связь с параметрами камеры: содержит информацию о внутренних параметрах камеры, зависит от фокусных расстояний, координат главной точки и коэффициента скоса (skew).</p>
</li>
<li>
<p>При стандартных предположениях о камере (нулевой скос, квадратные пиксели) матрица $\omega$ имеет вид:</p>
</li>
</ol>
<p>$\omega = \begin{bmatrix}
\omega_1 &amp; 0 &amp; \omega_4 \\
0 &amp; \omega_1 &amp; \omega_5 \\
\omega_4 &amp; \omega_5 &amp; \omega_6
\end{bmatrix}$</p>
<p>Матрица $\omega$ определяется с точностью до масштабного множителя, что влияет на количество независимых переменных при решении системы уравнений. Это свойство учитывается при калибровке камеры и восстановлении 3D-структуры сцены.</p>
<p>Это соотношение показывает, как можно определить угол между направлениями в пространстве, используя только точки схода на изображении и параметры камеры.</p>
<p>И наконец, расширим рассмотренную концепцию на случай трёхмерных плоскостей, чтобы установить связь между различными плоскостями в 3D пространстве.</p>
<p>Для любой плоскости мы можем:<br><em> Вычислить соответствующую линию горизонта $l_{horiz}$<br></em> Определить нормаль к плоскости $n = K^\ l_{horiz}$  </p>
<p>Угол $\theta$ между двумя плоскостями можно определить через угол между их нормалями $n_1$ и $n_2$. 
Рассмотрим две плоскости с линиями горизонта $l_1$ и $l_2$ соответственно. 
Угол между нормалями этих плоскостей определяется формулой:</p>
<p>$\cos \theta = \frac{n_1 \cdot n_2}{|n_1||n_2|} = \frac{l_1^T \omega^{-1} l_2}{\sqrt{l_1^T \omega^{-1} l_1} \sqrt{l_2^T \omega^{-1} l_2}}$ (13)</p>
<p>Таким образом, используя линии горизонта и параметры камеры, мы можем восстанавливать пространственные отношения между плоскостями в сцене, что является важным инструментом в компьютерном зрении и трёхмерной реконструкции.</p>
<h4>4. Алгоритм калибровки камеры и измерения углов</h4>
<p>Рассмотрим пример решения задачи калибровки камеры по одной фотографии. 
Для этого нам понадобится изображение трёхмерного мира, на котором мы можем выполнить следующие операции:<br><em> Определить три плоскости и на каждой из этих плоскостей пару параллельных линий<br></em> Идентифицировать точки схода $v_1$ $v_2$ и $v_3$<br>
* Использовать априорное знание и том, что плоскости перпендикулярны в 3D пространстве.  </p>
<p><img alt="Рисунок 5: Точки схода на перпендикулярных плоскостях" src="https://storage.yandexcloud.net/yahosting/photo_metro/6.jpg"></p>
<p><strong>Рисунок 5: Точки схода на перпендикулярных плоскостях</strong></p>
<p>Из уравнения (12) мы знаем, что для перпендикулярных плоскостей выполняется соотношение $v_1\omega v_2 = 0$. </p>
<p>Если мы имеем три точки схода для трех взаимно перпендикулярной плоскости, то получаем систему: </p>
<p>$v_1\omega v_2 = 0$<br>
 $v_1\omega v_3 = 0$<br>
 $v_2\omega v_3 = 0$  </p>
<p>При предположении об отсутствии скоса камеры и квадратных пикселях, мы можем решить эту систему относительно элементов матрицы $\omega_1, \omega_4, \omega_5, \omega_6$ (с точностью до масштаба).  </p>
<p>Зная матрицу $\omega$, можно вычислить элементы матрицы камеры $K$ с помощью разложения Холецкого. </p>
<p>Таким образом, мы выполняем калибровку камеры всего по одному изображению. 
После определения $K$ мы можем восстановить 3D-геометрию сцены, вычислить ориентацию всех идентифицированных плоскостей, а также получить обширную информацию о снимаемой сцене с точностью до масштабного коэффициента. </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/camera-calibration/" class="u-url">Калибровка камеры </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/camera-calibration/" rel="bookmark">
            <time class="published dt-published" datetime="2025-09-30T14:00:00+03:00" itemprop="datePublished" title="2025-09-30 14:00">2025-09-30 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <p><strong>Калибровка камеры</strong></p>
<p>Чтобы точно знать преобразование из реального трёхмерного мира в цифровые изображения, необходимо заранее знать многие внутренние параметры камеры. Если у нас есть произвольная камера, мы можем как иметь доступ к этим параметрам, так и не иметь его. Однако у нас есть доступ к изображениям, которые делает камера.</p>
<p>Возникает вопрос: можем ли мы найти способ вывести эти параметры из изображений? Эта задача оценки внешних и внутренних параметров камеры известна как <strong>калибровка камеры</strong>.</p>
<p><strong>Калибровка камеры</strong> — это фундаментальный процесс в компьютерном зрении и обработке изображений, который позволяет нам переходить от наблюдаемых пикселей к реальным координатам в пространстве.</p>
<p><img alt="Рисунок 1: Пример калибровочной установки" src="https://storage.yandexcloud.net/yahosting/calibrate/1.jpg"></p>
<p><strong>Рисунок 1: Пример калибровочной установки</strong></p>
<p>Процесс калибровки камеры заключается в определении <strong>внутренней матрицы камеры</strong> $K$ и <strong>внешних параметров</strong> $R$, $T$ из уравнения (1).  </p>
<p>$P' = K \begin{bmatrix} R &amp; T \end{bmatrix} P_w = MP_w$     (1)</p>
<p>Рассмотрим этот процесс в контексте калибровочной установки, подобной показанной на рисунке 1.</p>
<p><strong>Калибровочная установка</strong> обычно состоит из простого шаблона (например, шахматной доски) с известными размерами. Кроме того, установка определяет нашу мировую систему координат с началом $O_w$ и осями $i_w$, $j_w$, $k_w$.</p>
<p>Из известного шаблона мы получаем точки в мировой системе координат $P_1, ..., P_n$. Найдя эти точки на изображении, полученном с камеры, мы получаем соответствующие точки изображения $p_1, ..., p_n$.</p>
<p>Мы составляем линейную систему уравнений из $n$ соответствий, таких что для каждого соответствия $P_i$, $p_i$ и матрицы камеры $M$, строки которой $m_1$, $m_2$, $m_3$:</p>
<p>$p_i = \begin{pmatrix} u_i \\ v_i \end{pmatrix} = MP_i = \begin{pmatrix} \frac{m_1P_i}{m_3P_i} \\ \frac{m_2P_i}{m_3P_i} \end{pmatrix}$ (2)</p>
<p>Уравнение (2) даёт нам два ограничения для нахождения неизвестных параметров, содержащихся в $m$.</p>
<p>Мы знаем, что матрица камеры имеет 11 неизвестных параметров (6 внешних и 5 внутренних). Это означает, что нам нужно как минимум 6 соответствий для решения. Однако в реальном мире мы часто используем больше соответствий, поскольку измерения часто зашумлены.</p>
<p>Для каждой точки $P_i$ мы можем вывести пару уравнений, связывающих координаты на плоскости $u_i, v_i$ с 3D координатами:</p>
<p>$u_i(m_3P_i) − m_1P_i = 0$<br>
$v_i(m_3P_i) − m_2P_i = 0$</p>
<p>При наличии $n$ таких соответствующих точек вся линейная система уравнений принимает вид:</p>
<p>$u_1(m_3P_1)−m_1P_1 = 0$<br>
$v_1(m_3P_1)−m_2P_1 = 0$<br>
...<br>
$u_n(m_3P_n)−m_1P_n = 0$<br>
$v_n(m_3P_n)−m_2P_n = 0$  </p>
<p>Мы можем вынести вектора $m_1 , m_2, m_3$ и представить эту систему уравнений в виде матричного произведения:</p>
<p>$\begin{bmatrix}
P_1^T &amp; 0^T &amp; -u_1P_1^T  \\
0^T &amp; P_1^T &amp; -v_1P_1^T  \\
\vdots &amp; \vdots &amp; \vdots \\
P_n^T &amp; 0^T &amp; -u_nP_n^T  \\
0^T &amp; P_n^T &amp; -v_nP_n^T
\end{bmatrix}
\begin{bmatrix}
m_1^T \\
m_2^T \\
m_3^T
\end{bmatrix} = Pm = 0$ (3)</p>
<p>Когда $2n &gt; 11$, наша однородная линейная система является переопределённой. Для такой системы $m = 0$ всегда является тривиальным решением. Более того, даже если существует ненулевое решение $m$, то для любого $\rho \in \mathbb{R}$, $km$ также будет решением.</p>
<p>Поэтому для ограничения решения мы выполняем следующую минимизацию:</p>
<p>$\min_{m} |Pm|^2 \quad \text{при условии} \quad |m|^2 = 1$ (4)</p>
<p>Для решения этой задачи минимизации используется сингулярное разложение. Если обозначить $P = UDV^T$, то решение задачи минимизации заключается в том, чтобы установить $m$ равным последнему столбцу матрицы $V$.
Обоснование данного решения выходит за рамки этого курса. Для более подробного изучения вы можете обратиться к разделу 5.3 книги Hartley &amp; Zisserman стр. 592–593. </p>
<p>В этом разделе вы найдёте:<br>
- Математическое обоснование метода<br>
- Подробное доказательство решения<br>
- Дополнительные технические детали  </p>
<p>После преобразования вектора $m$ в матрицу $M$ мы хотим явно найти внешние и внутренние параметры камеры.</p>
<p>C помощью SVD мы вычислили матрицу $M$, с точностью до масштабного множителя $\rho$. </p>
<p>$\rho M = \begin{bmatrix}
\alpha r_1^T - \alpha \cot \theta r_2^T + c_x r_3^T &amp; \alpha t_x - \alpha \cot \theta t_y + c_x t_z \\
\frac{\beta}{\sin \theta} r_2^T + c_y r_3^T &amp; \frac{\beta}{\sin \theta} t_y + c_y t_z \\
r_3^T &amp; t_z
\end{bmatrix}$ (5)</p>
<p>где $r_1^T$, $r_2^T$, и $r_3^T$ — это три строки матрицы вращения $R$.</p>
<p>Разделим на скаляр $\rho$ и обозначим первый столбец как матрицу $A$, а второй столбец как вектор $b$:</p>
<p>$M = \frac{1}{\rho} \begin{bmatrix}
\alpha r_1^T - \alpha \cot \theta r_2^T + c_x r_3^T &amp; \alpha t_x - \alpha \cot \theta t_y + c_x t_z \\
\frac{\beta}{\sin \theta} r_2^T + c_y r_3^T &amp; \frac{\beta}{\sin \theta} t_y + c_y t_z \\
r_3^T &amp; t_z
\end{bmatrix} =
\begin{bmatrix}
A &amp; b
\end{bmatrix} =
\begin{bmatrix}
a_1^T &amp; b_1 \\
a_2^T &amp; b_2 \\
a_3^T &amp; b_3
\end{bmatrix}$</p>
<p>Теперь мы можем вычислить внутренние параметры камеры через элементы известной матрицы $M$, она же $A$ и $b$: (6)</p>
<p>Масштабный множитель:<br>
$\rho = \pm \frac{1}{|a_3|}$  </p>
<p>Координаты главной точки:<br>
$c_x = \rho^2 (a_1 \cdot a_3)$<br>
$c_y = \rho^2 (a_2 \cdot a_3)$  </p>
<p>Угол скоса:<br>
$\theta = \cos^{-1} \left( -\frac{(a_1 \times a_3) \cdot (a_2 \times a_3)}{|a_1 \times a_3| \cdot |a_2 \times a_3|} \right)$ </p>
<p>Масштабные коэффициенты:<br>
$\alpha = \rho^2 |a_1 \times a_3| \sin \theta$<br>
$\beta = \rho^2 |a_2 \times a_3| \sin \theta$  </p>
<p>Формулы для вычисления внешних параметров (7)</p>
<p>Матрица вращения:<br>
  $r_1 = \frac{a_2 \times a_3}{|a_2 \times a_3|}$<br>
  $r_2 = r_3 \times r_1$<br>
  $r_3 = \rho a_3$  </p>
<p>Вектор переноса:<br>
  $T = \rho K^{-1} b$</p>
<p>При подготовке данных для процедуры калибровки важно учитывать особые случаи, при которых процесс может дать некорректные результаты. 
 <strong>Вырожденные конфигурации</strong> возникают, когда точки $P_i$ располагаются в одной плоскости или лежат на кривой пересечения двух квадрик. В таких случаях система уравнений становится неразрешимой, что приводит к невозможности корректного определения параметров камеры.
Чтобы избежать подобных проблем, следует тщательно подходить к процессу калибровки. Необходимо использовать точки с различной глубиной расположения, обеспечивать разнообразие положений калибровочной мишени в пространстве и внимательно следить за распределением точек. Важно также проверять качество получаемых данных и анализировать корректность результатов на тестовых наборах.
Для более глубокого понимания теоретических аспектов рекомендуется обратиться к разделу 1.3.1 учебника Forsyth &amp; Ponce, где подробно рассматриваются вырожденные конфигурации и методы их предотвращения.</p>
<h4>2. Компенсация искажений при калибровке камеры</h4>
<p>До этого момента мы рассматривали идеальные линзы, свободные от любых искажений. Однако в реальности объективы могут отклоняться от прямолинейной проекции, что требует применения более сложных методов обработки. В этом разделе мы кратко рассмотрим подходы к работе с искажениями.</p>
<p>Благодаря физической симметрии линзы <strong>радиальные искажения</strong> тоже обладают симметрией. 
 Для моделирования радиальных искажений используется изотропное преобразование $Q$:</p>
<p>$Q P_i =
\begin{bmatrix}
q_1 \\ q_2 \\ q_3
\end{bmatrix} P_i = 
\begin{bmatrix}
\frac{1}{\lambda} &amp; 0 &amp; 0 \\
0 &amp; \frac{1}{\lambda} &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix} M P_i = 
\begin{bmatrix}
u_i \\
v_i
\end{bmatrix} = p_i$ (8)</p>
<p>Переписав в систему векторных уравнений, получаем:  </p>
<p>$u_i q_3 P_i = q_1 P_i$ <br>
$v_i q_3 P_i = q_2 P_i$   </p>
<p>Однако такая система перестаёт быть линейной, и для её решения требуются методы <strong>нелинейной оптимизации</strong>, которые подробно рассматриваются в разделе 22.2 учебника Forsyth &amp; Ponce.</p>
<p>Упростить процесс нелинейной оптимизации при калибровке можно, сделав определённые допущения. В случае радиальных искажений важно отметить, что соотношение между координатами $u_i$ и $v_i$ остаётся неизменным. Это соотношение можно вычислить следующим образом:</p>
<p>$\frac{u_i}{v_i} = \frac{\frac{m_1P_i}{m_3P_i}}{\frac{m_2P_i}{m_3P_i}} = \frac{m_1P_i}{m_2P_i}$ (18)</p>
<p>При наличии $n$ соответствий мы можем составить систему линейных уравнений следующего вида:</p>
<p>$v_1(m_1P_1) - u_1(m_2P_1) = 0$<br>
$\vdots$<br>
$v_n(m_1P_n) - u_n(m_2P_n) = 0$  </p>
<p>Эта система может быть представлена в виде матрично-векторного произведения, решаемого с помощью <strong>сингулярного разложения (SVD)</strong>:</p>
<p>$L n = \begin{bmatrix}
v_1P_1^T &amp; -u_1P_1^T \\
\vdots &amp; \vdots \\
v_nP_n^T &amp; -u_nP_n^T
\end{bmatrix}
\begin{bmatrix}
m_1^T \\
m_2^T
\end{bmatrix}$ (19)</p>
<p>После оценки векторов $m_1$ и $m_2$ вектор $m_3$ может быть выражен как <strong>нелинейная функция</strong> от $m_1$, $m_2$ и $\lambda$. Это приводит к необходимости решения задачи <strong>нелинейной оптимизации</strong>, которая значительно проще исходной задачи оценки элементов матрицы $Q$.</p>
<p>Процесс решения включает следующие этапы:</p>
<ol>
<li>Формирование матрицы $L n$ на основе известных соответствий между точками  </li>
<li>Применение SVD для нахождения $m_1$ и $m_2$  </li>
<li>Вычисление $m_3$ через нелинейную зависимость  </li>
</ol>
<p>Используем условие ортогональности:  </p>
<p>$m_1 \cdot m_3 = 0$ и $m_2 \cdot m_3 = 0$  </p>
<p>Учитываем нормировку:  </p>
<p>$|m_3| = 1$</p>
<p>Вводим зависимость от параметра $\lambda$, итоговая формула для вычисления $m_3$ имеет вид:  </p>
<p>$m_3 = \frac{m_1 \times m_2}{|m_1 \times m_2|} \cdot g(\lambda)$  </p>
<p>где $g(\lambda)$ — некоторая функция от параметра $\lambda$, зависящая от конкретной модели искажений.</p>
<p>Вид функции $g(\lambda)$ зависит от требуемой точности модели. </p>
<p><strong>Полиномиальная модель</strong> общего вида: </p>
<p>$g(\lambda) = 1 + k_1\lambda^2 + k_2\lambda^4 + k_3\lambda^6 + ...$  </p>
<p>где $k_1, k_2, k_3$ — коэффициенты радиальных искажений.</p>
<p>На практике используют вычислительно несложные модели:  </p>
<p>$g(\lambda) = 1 + k_1\lambda^2$</p>
<p>или</p>
<p>$g(\lambda) = 1 + k_1\lambda^2 + k_2\lambda^4$</p>
<p><strong>Модель Брауна</strong> включает как радиальные, так и тангенциальные искажения:</p>
<p>$x_{distorted} = x(1 + k_1r^2 + k_2r^4) + 2p_1xy + p_2(r^2 + 2x^2)$  </p>
<p>$y_{distorted} = y(1 + k_1r^2 + k_2r^4) + p_1(r^2 + 2y^2) + 2p_2xy$  </p>
<p>где $r^2 = x^2 + y^2$  </p>
<h4>Резюме</h4>
<p>Калибровка камеры — это комплексный процесс определения внутренних и внешних параметров оптической системы для точного преобразования координат между трёхмерным пространством и двумерным изображением. 
В основе калибровки лежит использование калибровочной мишени с известными координатами, что позволяет установить соответствие между мировыми и экранными координатами. Процесс включает определение матрицы камеры, которая содержит информацию о фокусном расстоянии, координатах главной точки и коэффициентах искажения.</p>
<p>Важным этапом является учёт искажений, которые неизбежно присутствуют в реальных объективах. Для их компенсации применяются специальные математические модели, чаще всего основанные на полиномиальных функциях радиальных искажений. 
При калибровке необходимо избегать вырожденных конфигураций, когда точки располагаются в одной плоскости, что делает невозможным корректное определение параметров. 
Практическая реализация требует достаточного количества калибровочных изображений с разнообразным расположением мишени относительно камеры. После завершения калибровки получается набор параметров, позволяющий компенсировать искажения и восстанавливать пространственные координаты по изображениям с точностью до удаления $z$. </p>
<p>Качество калибровки напрямую влияет на точность последующих измерений и является критически важным этапом в системах компьютерного зрения и машинного обучения.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/base-3d/" class="u-url">Основы трехмерного компьютерного зрения </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/base-3d/" rel="bookmark">
            <time class="published dt-published" datetime="2025-09-29T14:00:00+03:00" itemprop="datePublished" title="2025-09-29 14:00">2025-09-29 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h4>1. Введение</h4>
<p>Камера является одним из важнейших инструментов в компьютерном зрении. Это механизм, с помощью которого мы можем фиксировать окружающий мир и использовать получаемые результаты — фотографии — для различных приложений. Поэтому один из фундаментальных вопросов трехмерного компьютерного зрения звучит так: как мы можем смоделировать камеру? </p>
<h4>2. Камера-обскура</h4>
<p>Камера-обскура — это простейшая система, которая позволяет фиксировать изображение объекта или сцены в трёхмерном мире. Такая система может быть создана путём размещения преграды с небольшим отверстием (апертурой) между трёхмерным объектом и фотоплёнкой или светочувствительным сенсором.</p>
<p><img alt="Рисунок 1: Модель камеры обскуры" src="https://storage.yandexcloud.net/yahosting/3d/1.jpg"></p>
<p><strong>Рисунок 1: Модель камеры обскуры</strong></p>
<p>Как показано на рисунке 1, каждая точка на трёхмерном объекте испускает множество световых лучей во все стороны. Без преграды каждая точка на плёнке подвергалась бы воздействию световых лучей, исходящих от каждой точки трёхмерного объекта. Благодаря наличию преграды через отверстие проходит только один (или несколько) из этих лучей света и попадает на плёнку.</p>
<p>Таким образом, мы можем установить взаимно-однозначное соответствие между точками на трёхмерном объекте и точками на плёнке. В результате плёнка получает «изображение» трёхмерного объекта посредством такого отображения. Эта простая модель известна как модель камеры-обскуры.</p>
<p><img alt="Рисунок 2: Формальная модель камеры-обскуры" src="https://storage.yandexcloud.net/yahosting/3d/2.jpg"></p>
<p><strong>Рисунок 2: Формальная модель модели камеры-обскуры</strong></p>
<p>Более формальное построение камеры-обскуры показано на рисунке 2. В этой конструкции плёнка обычно называется <strong>плоскостью изображения</strong> или <strong>сетчаткой</strong>. Отверстие называется <strong>точечным отверстием</strong> O или центром камеры. Расстояние между плоскостью изображения и точечным отверстием O называется <strong>фокусным расстоянием</strong> f.</p>
<p>Иногда плоскость сетчатки размещается между точкой O и трёхмерным объектом на расстоянии f от O. В этом случае она называется <strong>виртуальной плоскостью изображения</strong> или <strong>виртуальной плоскостью сетчатки</strong>. Важно отметить, что проекция объекта на плоскость изображения и изображение объекта на виртуальной плоскости изображения идентичны с точностью до масштабного (подобного) преобразования.</p>
<p>Теперь рассмотрим, как использовать камеры-обскуры. Пусть P = [x y z]ᵀ — точка на некотором трёхмерном объекте, видимом для камеры-обскуры. Точка P будет отображена или спроецирована на плоскость изображения Π', в результате чего получится точка P' = [x' y']ᵀ.</p>
<p>Аналогично, само точечное отверстие может быть спроецировано на плоскость изображения, что даст новую точку C'. Здесь мы можем определить систему координат [i j k], центрированную в точке отверстия O, так что ось k перпендикулярна плоскости изображения и направлена к ней. Эта система координат часто известна как <strong>система отсчёта камеры</strong> или <strong>система координат камеры</strong>.</p>
<p>Линия, определяемая точками C' и O, называется <strong>оптической осью</strong> системы камеры. </p>
<p>Напомним, что точка $P_0$ получается в результате проекции трёхмерной точки $P$ на плоскость изображения $Π'$. 
Следовательно, если мы выведем соотношение между трёхмерной точкой $P$ и точкой $P'$ на плоскости изображения, мы сможем понять, как трёхмерный мир отображается на снимке, сделанном камерой-обскурой.</p>
<p>Обратите внимание, что треугольник $P' C'O$ подобен треугольнику, образованному точками $P$, $O$ и $(0, 0, z)$. 
Используя теорему о подобных треугольниках, мы получаем:</p>
<p>$P' = \begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} \frac{fx}{z} \\ \frac{fy}{z} \end{pmatrix}$ (1)</p>
<p>Важно отметить, что в этой модели камеры-обскуры мы делаем одно существенное допущение: апертура (отверстие) считается одной точкой. Однако в большинстве реальных ситуаций мы не можем предполагать, что апертура может быть бесконечно малой. Возникает вопрос: как влияет изменение размера апертуры на результат?</p>
<p><img alt="Рисунок 3: Влияние размера апертуры на изображение" src="https://storage.yandexcloud.net/yahosting/3d/3.jpg"></p>
<p><strong>Рисунок 3: Влияние размера апертуры на изображение</strong></p>
<p>При уменьшении размера апертуры изображение становится более резким, но более тёмным.</p>
<p>По мере увеличения размера апертуры количество световых лучей, проходящих через преграду, соответственно возрастает. При большем количестве проходящих лучей каждая точка на плёнке может подвергаться воздействию световых лучей от нескольких точек в трёхмерном пространстве, что приводит к размытию изображения.</p>
<p>Хотя может показаться заманчивым сделать апертуру как можно меньше, следует помнить, что меньший размер апертуры пропускает меньше световых лучей, в результате чего изображение получается более чётким, но более тёмным.</p>
<p>Таким образом, мы приходим к фундаментальной проблеме, возникающей при использовании  камеры-обскуры: возможно ли создать камеру, которая делает одновременно чёткие и яркие изображения?</p>
<h4>3. Камеры и линзы</h4>
<p>В современных камерах указанное противоречие между резкостью и яркостью изображения решается с помощью <strong>линз</strong> — устройств, способных фокусировать или рассеивать свет.</p>
<p>Если заменить отверстие (апертуру) камеры-обскуры на линзу, которая правильно расположена и имеет подходящий размер, то она будет обладать следующим свойством: все световые лучи, испускаемые некоторой точкой $P$, преломляются линзой таким образом, что они сходятся в одной точке $P'$. </p>
<p><img alt="Рисунок 4: Схема простой модели линзы" src="https://storage.yandexcloud.net/yahosting/3d/4.jpg"></p>
<p><strong>Рисунок 4: Схема простой модели линзы</strong></p>
<p>На рисунке 4 показано, как лучи от верхней точки дерева хорошо сходятся на плёнке. Однако точка, находящаяся на другом расстоянии от линзы, приводит к тому, что лучи не сходятся идеально на плёнке.</p>
<p>Благодаря линзе проблема блокировки большинства световых лучей из-за малого отверстия устраняется (см. рисунок 4). Однако важно отметить, что это свойство выполняется не для всех точек трёхмерного пространства, а только для определённой точки $P$.</p>
<p>Рассмотрим другую точку $Q$, которая находится ближе или дальше от плоскости изображения, чем точка $P$. Соответствующая проекция на изображение будет размытой или не в фокусе. Таким образом, у линз есть определённое расстояние, на котором объекты находятся «в фокусе».
Эффективный диапазон, в пределах которого камеры могут делать чёткие снимки называется <strong>глубина резкости</strong>. </p>
<p><img alt="Рисунок 5: Фокусировка световых лучей с помощью линзы" src="https://storage.yandexcloud.net/yahosting/3d/5.jpg"></p>
<p><strong>Рисунок 5: Фокусировка световых лучей с помощью линзы</strong></p>
<p>На данном рисунке демонстрируется, как линза фокусирует световые лучи, параллельные оптической оси, в <strong>фокусе</strong> (фокальной точке). Эта схема также иллюстрирует <strong>модель параксиального преломления</strong> — упрощённую модель, которая помогает установить взаимосвязь между точками на плоскости изображения и объектами в трёхмерном пространстве для камер с линзами.</p>
<p><strong>Параксиальное преломление</strong> — это приближение, используемое в оптике, которое позволяет:<br>
- точно рассчитывать траектории световых лучей;<br>
- определять положение точек в пространстве;<br>
- вычислять параметры фокусировки;<br>
- моделировать работу оптических систем.  </p>
<p>Такая модель является фундаментальной для понимания принципов работы современных камер и систем компьютерного зрения. </p>
<p><strong>Объективы камер</strong> обладают ещё одним важным свойством: они фокусируют все световые лучи, движущиеся параллельно оптической оси, в одну точку, известную как <strong>фокусная точка</strong> (см. рисунок 5). Расстояние между фокусной точкой и центром линзы называется <strong>фокусным расстоянием</strong> $f$.</p>
<p>Кроме того, световые лучи, проходящие через центр линзы, не отклоняются. Благодаря этому мы можем построить конструкцию, аналогичную модели камеры-обскуры, которая связывает точку $P$ в трёхмерном пространстве с соответствующей точкой $P'$ на плоскости изображения:</p>
<p>$P' = \begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} z' \frac{x}{z} \\ z' \frac{y}{z} \end{pmatrix}$ (2)</p>
<p>Важно отметить следующие различия между моделями:<br>
- В модели камеры-обскуры $z' = f$<br>
- В модели с линзой $z' = f + z_0$  </p>
<p>Данное соотношение основано на <strong>параксиальном приближении</strong> (или предположении о «тонкой линзе»), а такая модель называется <strong>моделью параксиального преломления</strong>. Подробное доказательство этой модели выходит за рамки данного курса. </p>
<p><img alt="Рисунок 6: Подушкообразное и бочкообразное искажение изображения" src="https://storage.yandexcloud.net/yahosting/3d/6.jpg"></p>
<p><strong>Рисунок 6: Подушкообразное и бочкообразное искажение изображения</strong></p>
<p>Поскольку модель параксиального преломления использует приближение тонкой линзы, может возникать ряд аберраций. Наиболее распространённой из них является <strong>радиальное искажение</strong>, которое приводит к уменьшению или увеличению увеличения изображения в зависимости от расстояния до оптической оси.</p>
<p>Мы классифицируем радиальное искажение следующим образом:<br>
- <strong>Подушкообразное искажение</strong> — когда увеличение возрастает<br>
- <strong>Бочкообразное искажение</strong> — когда увеличение уменьшается.  </p>
<p>Радиальное искажение возникает из-за того, что различные участки линзы имеют разные фокусные расстояния. Это явление наглядно показано на рисунке 6, где можно увидеть, как эти типы искажений влияют на конечное изображение.</p>
<p>Такие искажения особенно заметны:
- По краям кадра
- При использовании широкоугольных объективов
- В системах компьютерного зрения, где важна точность геометрических измерений </p>
<h4>4. Матричная модель камеры</h4>
<p>В этом разделе мы рассмотрим детали параметров, которые необходимо учитывать при моделировании проекции из трёхмерного пространства на известные нам цифровые изображения. Все полученные результаты будут использовать модель камеры-обскуры, но они также применимы и к модели параксиального преломления.</p>
<p>Как обсуждалось ранее, точка $P$ в трёхмерном пространстве может быть отображена (или спроецирована) в двумерную точку $P'$ на плоскости изображения $Π'$. Такое отображение $R^3 → R^2$ называется <strong>проективным преобразованием</strong>.</p>
<p>Однако такая проекция трёхмерных точек на плоскость изображения не соответствует напрямую тому, что мы видим в реальных цифровых изображениях по нескольким причинам:</p>
<ol>
<li>Точки в цифровых изображениях, как правило, находятся в другой системе отсчёта, чем точки в плоскости изображения.</li>
<li>Цифровые изображения разделены на дискретные пиксели, тогда как точки в плоскости изображения являются непрерывными.</li>
<li>Физические датчики могут вносить нелинейные искажения в отображение.</li>
</ol>
<p>Чтобы учесть эти различия, мы введём ряд дополнительных преобразований, которые позволят нам отображать любую точку из трёхмерного мира в координаты пикселей.</p>
<p>Таким образом, нам необходимо: <br>
- Учесть различия в системах координат;<br>
- Преобразовать непрерывные координаты в дискретные пиксельные;<br>
- Компенсировать возможные искажения сенсора.  </p>
<p><strong>Матричная модель камеры</strong> описывает набор важных параметров, влияющих на то, как точка мира $P$ отображается в координаты изображения $P'$. Как следует из названия, эти параметры представлены в матричной форме.</p>
<p>Рассмотрим основные параметры:</p>
<p><strong>Параметры $c_x$ и $c_y$</strong> описывают разницу между координатами плоскости изображения и цифровыми координатами изображения через перенос.<br>
   - Координаты плоскости изображения имеют начало координат $C_0$ в центре изображения, где ось $k$ пересекает плоскость изображения.<br>
   - Цифровые координаты изображения обычно имеют начало в левом нижнем углу изображения.<br>
   - Таким образом, 2D точки на плоскости изображения и 2D точки в цифровом изображении смещаются на вектор переноса $\begin{pmatrix} c_x \\ c_y \end{pmatrix}^T$.  </p>
<p>С учётом этого изменения систем координат отображение теперь выглядит так:</p>
<p>$P' = \begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} \frac{f}{z}x + c_x \\ \frac{f}{z}y + c_y \end{pmatrix}$ (3)</p>
<p><strong>Второй важный эффект</strong> — это то, что точки в цифровых изображениях выражаются в пикселях, в то время как точки на плоскости изображения представлены в физических измерениях (например, сантиметрах).</p>
<p>Для учёта этого изменения единиц измерения необходимо ввести два новых параметра $k$ и $l$. Эти параметры имеют размерность [пиксель на сантиметр], соответствуют изменению единиц измерения по двум осям плоскости изображения. Важно отметить, что $k$ и $l$ могут быть разными, поскольку соотношение сторон пикселя не обязательно равно единице. Если $k = l$, мы говорим, что камера имеет квадратные пиксели. 
Мы модифицируем наше предыдущее отображение следующим образом:</p>
<p>$P_0 = \begin{pmatrix} x' \\ y' \end{pmatrix} = \begin{pmatrix} f k \frac{x}{z} + c_x \\ f l \frac{y}{z} + c_y \end{pmatrix} = \begin{pmatrix} \alpha\frac{x}{z} + c_x \\ \beta\frac{y}{z} + c_y \end{pmatrix}$ (4)</p>
<p>где<br>
$\alpha = f \cdot k$<br>
$\beta = f \cdot l$<br>
$f$ — фокусное расстояние в мм,<br>
$k$ — размер пикселя по оси x, пикс/мм. <br>
$l$ — размер пикселя по оси x, пикс/мм.  </p>
<p>Сокращение размерностей приводит к тому, что параметры $\alpha$ и $\beta$ выражаются в пикселях.<br>
Это логично, так как коэффициенты связывают физические измерения (метры) с дискретными единицами цифрового изображения (пиксели).</p>
<p>Геометрический смысл состоит в том, сколько в пикселях будет объект, размер которого на плоскости проекции равен фокусному расстоянию камеры. </p>
<p>Таким образом, измерение $\alpha$ и $\beta$ в пикселях является необходимым для:<br>
- Точного проецирования точек;<br>
- Корректной калибровки камеры;<br>
- Работы алгоритмов обработки изображений;<br>
- Взаимодействия между физическим и цифровым пространством.  </p>
<h4>5. Однородные координаты</h4>
<p>Теперь рассмотрим вопрос: существует ли линейный способ представления проецирования $P \rightarrow P'$?</p>
<p>Линейное преобразование на практике является более удобным, т.к. его можно представить как произведение входного вектора $P$ на некоторую матрицу. 
Из уравнения (4) видно, что  проецирование $P \rightarrow P'$ не является линейным, поскольку операция включает деление на один из входных параметров, а именно на $z$.
Тем не менее, представление этого проецирования в виде произведения вектора на матрицу возможно.
Решение заключается в использовании <strong>однородных координат</strong>. </p>
<p>Рассмотрим этот подход:</p>
<ol>
<li>
<strong>Введение новой координаты</strong>:<br>
Любая точка на плоскости $P' = (x', y')$ преобразуется в $(x', y', 1)$<br>
Любая точка в трехмерном пространстве $P = (x, y, z)$ преобразуется в $(x, y, z, 1)$  </li>
</ol>
<p>Такое расширенное пространство называется <strong>системой однородных координат</strong>.</p>
<ol>
<li>
<strong>Преобразование координат</strong>:<br>
Для преобразования евклидова вектора $(v_1, ..., v_n)$ в однородные координаты мы просто добавляем 1 в новое измерение, получая $(v_1, ..., v_n, 1)$<br>
Важно отметить: равенство между вектором и его однородными координатами выполняется только когда последняя координата равна единице<br>
При обратном преобразовании из произвольных однородных координат $(v_1, ..., v_n, w)$ мы получаем евклидовы координаты $(\frac{v_1}{w}, ..., \frac{v_n}{w})$  </li>
</ol>
<p>Используя однородные координаты, мы можем сформулировать преобразование следующим образом:</p>
<p>$P'_h = \begin{bmatrix} \alpha x + c_x z \\ \beta y + c_y z \\ z \end{bmatrix} = \begin{bmatrix} \alpha &amp; 0 &amp; c_x &amp; 0 \\ 0 &amp; \beta &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} \alpha &amp; 0 &amp; c_x &amp; 0 \\ 0 &amp; \beta &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} P_h$ (5)</p>
<p>Преимущества использования однородных координат:<br>
- Позволяют представить нелинейное преобразование в виде матричного умножения;<br>
- Упрощают дальнейшие математические выкладки;<br>
- Обеспечивают единый способ работы с проективными преобразованиями.  </p>
<p>С этого момента будем работать преимущественно в <strong>однородных координатах</strong>, если не указано иное. Индекс $h$ опустим, подразумевая, что любая точка $P$ или $P'$ задана в однородных координатах.</p>
<p>Как видно из уравнения (5), мы можем представить связь между точкой в трёхмерном пространстве и её координатами изображения в виде матрично-векторного соотношения:</p>
<p>$P' = \begin{bmatrix} x' \\ y' \\ z \end{bmatrix} = \begin{bmatrix} \alpha &amp; 0 &amp; c_x &amp; 0 \\ 0 &amp; \beta &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} \begin{bmatrix} x \\ y \\ z \\ 1 \end{bmatrix} = \begin{bmatrix} \alpha &amp; 0 &amp; c_x &amp; 0 \\ 0 &amp; \beta &amp; c_y &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \end{bmatrix} P = MP$ (6)</p>
<p>где:
- $M$ — <strong>матрица камеры</strong><br>
- $P$ — точка в однородных координатах трёхмерного пространства<br>
- $P'$ — проекция точки на плоскость изображения  </p>
<h4>6. Внутренние параметры камеры</h4>
<p>Важные параметры матрицы камеры:<br>
- $\alpha$ и $\beta$ — масштабные коэффициенты в направлениях $x$ и $y$<br>
- $c_x$ и $c_y$ — координаты главной точки (principal point)<br>
- Последний столбец матрицы $M$ содержит нули, что характерно для проективных преобразований.  </p>
<p>Давайте разберем это матричное разложение более подробно:</p>
<p>Мы можем представить преобразование в виде:</p>
<p>$P' = MP = \begin{bmatrix} \alpha &amp; 0 &amp; c_x \\ 0 &amp; \beta &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix} \begin{bmatrix} I &amp; 0 \end{bmatrix} P = K \begin{bmatrix} I &amp; 0 \end{bmatrix} P$ (7)</p>
<p>где:
- $P'$ — координаты точки на плоскости изображения<br>
- $M$ — полная матрица преобразования<br>
- $K$ — *<em>матрица камеры</em>- (внутренняя калибровка)<br>
- $I$ — единичная матрица размером 3×3<br>
- $0$ — нулевой вектор размером 3×1<br>
- $P$ — координаты точки в пространстве в однородных координатах.  </p>
<p><img alt="Рисунок 7: Проекция точки с помощью матрицы камеры" src="https://storage.yandexcloud.net/yahosting/3d/7.jpg"></p>
<p><strong>Рисунок 7: Проекция точки с помощью матрицы камеры</strong></p>
<p>Матрица камеры $K$ имеет следующий вид:</p>
<p>$K = \begin{bmatrix} \alpha &amp; 0 &amp; c_x \\ 0 &amp; \beta &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$</p>
<p>где:
- $\alpha$ и $\beta$ — масштабные коэффициенты, связанные с фокусным расстоянием<br>
- $c_x$ и $c_y$ — координаты главной точки (principal point)<br>
- Последняя строка [0 0 1] обеспечивает сохранение однородных координат  </p>
<p>Такое разложение позволяет:
- Выделить внутренние параметры камеры и работать с ними отдельно от внешних;<br>
- Упрощать вычисления при работе с проективными преобразованиями;<br>
- Более эффективно выполнять калибровку камеры;<br>
- Разделять влияние различных параметров на процесс проецирования.  </p>
<p>Матрица $K$ содержит всю необходимую информацию об <strong>внутренней калибровке</strong> камеры, что делает её ключевым элементом в задачах компьютерного зрения и обработки изображений. </p>
<p><img alt="Рисунок 8: Расположение главной точки С'" src="https://storage.yandexcloud.net/yahosting/3d/8.jpg"></p>
<p><strong>Рисунок 8: Расположение главной точки С'</strong></p>
<p>Полная матричная модель камеры $K$ содержит ключевые параметры, описывающие характеристики камеры и её модель, включая параметры $c_x$, $c_y$, $k$ и $l$, как обсуждалось ранее.</p>
<p>В текущей формулировке отсутствуют два важных параметра:
* <strong>Скос (skewness)</strong>
* <strong>Дисторсия (distortion)</strong></p>
<p><strong>Скос изображения</strong> возникает, когда система координат камеры имеет неточный угол между осями (отличающийся от 90 градусов). Большинство камер имеют нулевой скос, однако некоторое его значение может появиться из-за погрешностей при производстве сенсора.</p>
<p>Матрица камеры с учётом скоса имеет вид:</p>
<p>$K = \begin{bmatrix} x' \\ y' \\ z \end{bmatrix} = \begin{bmatrix} \alpha &amp; -\alpha \cot \theta &amp; c_x \\ 0 &amp; \frac{\beta}{\sin \theta} &amp; c_y \\ 0 &amp; 0 &amp; 1 \end{bmatrix}$ (8)</p>
<p>где:<br>
- $\alpha$ и $\beta$ — масштабные коэффициенты<br>
- $\theta$ — угол скоса<br>
- $c_x$ и $c_y$ — координаты главной точки  </p>
<p>В рамках данного курса мы рассматриваем матрицу камеры $K$ с 5 степенями свободы:<br>
- 2 параметра для фокусного расстояния <br>
- 2 параметра для смещения<br>
- 1 параметр для скоса  </p>
<p>Эти параметры называются <strong>внутренними параметрами камеры</strong> (intrinsic parameters), так как они:<br>
- Уникальны для каждой конкретной камеры<br>
- Связаны с её конструктивными особенностями<br>
- Определяются при производстве  </p>
<p>Важно отметить, что большинство методов компьютерного зрения игнорируют эффекты дисторсии, позволяя состедоточиться на 4 основных параметрах камеры.</p>
<h4>7. Внешние параметры камеры</h4>
<p>До сих пор мы описывали отображение точки $P$ из трёхмерной системы координат камеры в точку $P'$ на двумерной плоскости изображения, используя внутренние параметры камеры в матричной форме.</p>
<p>Однако возникает вопрос: что делать, если информация о трёхмерном мире представлена в другой системе координат? В этом случае необходимо добавить дополнительное преобразование, связывающее точки из мировой системы координат с системой координат камеры.</p>
<p>Это преобразование описывается:
- <strong>Матрицей вращения</strong> $R$
- <strong>Вектором переноса</strong> $T$</p>
<p>Таким образом, для точки $P_w$ в мировой системе координат её координаты в системе камеры можно вычислить следующим образом:</p>
<p>$P = \begin{bmatrix} R &amp; T \\ 0 &amp; 1 \end{bmatrix} P_w$ (9)</p>
<p>где:
- $R$ — матрица вращения размером 3×3<br>
- $T$ — вектор переноса размером 3×1<br>
- $P_w$ — координаты точки в мировой системе<br>
- $P$ — координаты точки в системе камеры  </p>
<p>Подставляя это в уравнение (7) и упрощая, получаем:</p>
<p>$P' = K \begin{bmatrix} R &amp; T \end{bmatrix} P_w = MP_w$ (10)</p>
<p>Параметры $R$ и $T$ называются <strong>внешними параметрами</strong>, поскольку они:<br>
- Находятся вне камеры<br>
- Не зависят от характеристик камеры  </p>
<p>Это завершает описание отображения трёхмерной точки $P$ из произвольной мировой системы координат на плоскость изображения.</p>
<h4>Резюме</h4>
<p>Полная матрица проекции $M$ состоит из двух типов параметров:
- <strong>Внутренние параметры</strong> (intrinsic parameters) — содержатся в матрице камеры $K$, меняются при смене типа камеры<br>
- <strong>Внешние параметры</strong> (extrinsic parameters) — включают вращение и перенос, не зависят от конструкции камеры  </p>
<p>Полная матрица проекции $M$ размером 3×4 имеет 11 степеней свободы:<br>
- 5 степеней свободы от внутренней матрицы камеры<br>
- 3 степени свободы от внешнего вращения<br>
- 3 степени свободы от внешнего переноса  </p>
<p>Таким образом, мы получили полное описание процесса проецирования точки из трёхмерного пространства на плоскость изображения, учитывающее как характеристики самой камеры, так и её положение в пространстве относительно наблюдаемой сцены.</p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/software-setup/" class="u-url">Настройка программного обеспечения </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/software-setup/" rel="bookmark">
            <time class="published dt-published" datetime="2025-07-02T14:00:00+03:00" itemprop="datePublished" title="2025-07-02 14:00">2025-07-02 14:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Настройка программного обеспечения</h2>
<p>Для работы с нейросетями можно работать через <a href="https://colab.research.google.com/">Google Colaboratory</a>. Однако, если у вас уже есть хорошая видеокарта (Nvidia) и вы предпочитаете работать локально, здесь вы найдет инструкции по настройке виртуальной среды.<br>
- <a href="posts/software-setup/">Удаленная работа в Google Colaboratory</a><br>
- <a href="posts/software-setup/">Работа локально на вашем компьютере</a><br>
    - <a href="posts/software-setup/">Виртуальная среда Anaconda</a><br>
    - <a href="posts/software-setup/">Python venv</a><br>
    - <a href="posts/software-setup/">Установка пакетов</a>  </p>
<h4>Удаленная работа в Google Colaboratory</h4>
<p><em>Google Colaboratory</em> — это, по сути, комбинация <em>Jupyter notebook</em> и <em>Google Drive</em>. 
Он полностью работает в облаке и поставляется с множеством предустановленных заранее пакетами (например, <em>PyTorch</em> и <em>Tensorflow</em>), поэтому у всех есть доступ к одному и тому же широкому перечню библиотек. 
Кроме того, <em>Google Colab</em> дает бесплатный доступ к аппаратным ускорителям например, <em>K80</em>, <em>P100</em> и TPU (Tensor Processing Unit).  </p>
<p><strong>Требования</strong>. 
Чтобы использовать <em>Colab</em>, у вас должен быть аккаунт <em>Google</em> со связанным <strong>Google диском</strong>. 
Предполагается, что у вас есть и то, и другое, вы можете подключить <em>Colab</em> к <strong>G-drive</strong>, выполнив следующие действия:</p>
<ol>
<li>Нажмите на колесико в правом верхнем углу и выберите <code>Settings</code>.  </li>
<li>Нажмите на вкладку <code>Manage Apps</code>.  </li>
<li>Вверху выберите <code>Connect more apps</code>, что должно вызвать окно <code>GSuite Marketplace</code>.  </li>
<li>Найдите <strong>Colab</strong> и нажмите <code>Add</code>.  </li>
</ol>
<p><strong>Рекомендации</strong>. Есть несколько вещей, о которых вы должны знать при работе с <em>Colab</em>:  </p>
<ol>
<li>
<p>Постоянное наличие ресурсов не гарантировано (это плата за бесплатность).  </p>
</li>
<li>
<p>Если вы бездействуете в течение определенного времени или общее время подключения превышает максимально допустимое время (<em>~12 часов</em>), виртуальная машина <em>Colab</em> будет отключена. Это означает, что любой несохраненный прогресс будет потерян. </p>
</li>
</ol>
<p><font color="red"><strong><br>
Таким образом, выработайте привычку часто сохранять свой код и веса моделей во время работы! 
</strong></font>  </p>
<p>Чтобы узнать больше об ограничениях ресурсов в <em>Colab</em>, ознакомьтесь с их часто задаваемыми вопросами <a href="https://research.google.com/colaboratory/faq.html">здесь</a>.</p>
<p><strong>Использование графического процессора (GPU)</strong>. 
Использовать графический процессор очень просто, нужно просто переключить среду выполнения в <em>Colab</em>. 
Перейдите в настройки по следующему пути: <code>Runtime -&gt; Change runtime type -&gt; Hardware Accelerator -&gt; GPU</code> , и <em>Colab</em> будет автоматически подкреплен вычислительными мощностями графического процессора.  </p>
<p>Если вы хотите узнать больше о <em>Colab</em>, рекомендую вам посетить следующие ресурсы:
- <a href="https://www.youtube.com/watch?v=inN8seMm7UI">Введение в Google Colab</a>
- <a href="https://colab.research.google.com/notebooks/intro.ipynb">Добро пожаловать в Colab</a>
- <a href="https://colab.research.google.com/notebooks/basic_features_overview.ipynb">Обзор функций Colab</a>  </p>
<h4>Работа на локальном компьютере</h4>
<p>Если вы хотите работать локально, вам следует использовать виртуальную среду <code>venv</code>. 
Вы можете установить ее через <em>Anaconda</em> или через модуль <em>python -m venv</em>. </p>
<h5>Виртуальная среда Anaconda</h5>
<p>Бесплатный <a href="https://www.anaconda.com/download/">дистрибутив Anaconda Python</a> предоставляет собой набор пакетов для научных вычислений. 
Приятная вещь в <em>Anaconda</em> заключается в том, что она поставляется с <a href="https://docs.anaconda.com/mkl-optimizations/">оптимизацией MKL</a> по умолчанию, 
Это означает, что ваши библиотеки <code>numpy</code> и <code>scipy</code> код получают значительное ускорение без необходимости изменять ни одной строки кода. </p>
<p>После установки Anaconda имеет смысл создать виртуальную среду для отдельного проекта. 
Если вы не не будете использовать виртуальную среду (<em>настоятельно не рекомендуется!</em>), все зависимости будут установлены глобально на вашем компьютере. 
Чтобы настроить виртуальную среду с именем <code>mldl</code>, выполните следующие действия в терминале:  </p>
<div class="code"><pre class="code literal-block">conda create -n mldl python=3.12
</pre></div>

<p>Чтобы активировать и войти в среду, запустите </p>
<div class="code"><pre class="code literal-block">conda activate mldl
</pre></div>

<p>Чтобы отключить среду, закройте терминал или используйте команду</p>
<div class="code"><pre class="code literal-block">conda deactivate
</pre></div>

<p>Вы можете обратиться к <a href="https://docs.conda.io/projects/conda/en/latest/user-guide/tasks/manage-environments.html">этой странице</a> за более подробными инструкциями по управлению виртуальными средами с помощью Anaconda.  </p>
<h4>Python venv</h4>
<p>Начиная с версии <em>3.3</em>, <em>Python</em> поставляется с облегченным модулем виртуальной среды под названием <a href="https://docs.python.org/3/library/venv.html">venv</a>. 
Каждая виртуальная среда упаковывает свой собственный независимый набор установленных пакетов (библиотек) <em>Python</em>.
Это позволяет изолировать проект от общесистемных пакетов <em>Python</em> и запускать нужную версию <em>Python</em>. 
Чтобы настроить виртуальную среду с именем <code>mldl</code>, выполните команду в терминале:</p>
<div class="code"><pre class="code literal-block">python3.12 -m venv mldl
</pre></div>

<p>Чтобы активировать и войти в среду, запустите <code>source mldl/bin/activate</code>. 
Чтобы отключить среду, запустите в терминале <code>deactivate</code> или выйдите из него. 
Обратите внимание, что каждый раз, когда вы хотите поработать над проектом, вы должны повторно активировать среду. </p>
<h4>Установка пакетов</h4>
<p>После того как вы <strong>настроили</strong> и <strong>активировали</strong> свою виртуальную среду (с помощью <code>conda</code> или <code>venv</code>), вы должны установить библиотеки, необходимые для выполнения назначений с помощью <code>pip</code>. 
Для этого выполните команду:</p>
<div class="code"><pre class="code literal-block">pip install -r requirements.txt  
</pre></div>

<h3>Python IDE</h3>
<p>Использование Ide для работы над проектами очень упрощает создание и настройку python. 
Кроме того, интеграция с Git и другие полезные утилиты позволяют повысить эффективность разработки, не отвлекаясь на рутинные операции. 
Используйте PyCharm, VsCode или любую другую IDE на ваш вкус. 
Мой выбор - VsCode с расширениями (Extentions): Python (Microsoft), Black Formatter, JetBrains IDE KeyMapping. </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/numpy-tutorial/" class="u-url">Tutorial python Numpy</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/numpy-tutorial/" rel="bookmark">
            <time class="published dt-published" datetime="2025-07-02T09:42:16+03:00" itemprop="datePublished" title="2025-07-02 09:42">2025-07-02 09:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Python numpy (с Jupyter и Colab)</h2>
<p><a href="https://colab.research.google.com/github/cs231n/cs231n.github.io/blob/master/python-colab.ipynb">Блокнот Colab</a></p>
<p>Этот урок был первоначально предоставлен <a href="http://cs.stanford.edu/people/jcjohns/">Джастином Джонсоном</a>.  </p>
<p>Мы будем использовать язык программирования <em>python</em> для всех заданий этого курса. 
<em>Python</em> сам по себе является отличным языком программирования общего назначения, но с помощью нескольких популярных библиотек (<em>numpy</em>, <em>scipy</em>, <em>matplotlib</em>) он становится мощной средой для научных вычислений.</p>
<p>Мы ожидаем, что многие из вас имеют некоторый опыт работы с <em>python</em> и <em>numpy</em>. 
Если нет, то этот раздел послужит кратким ускоренным курсом по обоим направлениям языка программирования <em>python</em> и его использованию для научных исследований и вычислений. 
Мы также познакомимся с Jupyter-notebooks, которые являются очень удобным способом работы с кодом на <em>python</em>. </p>
<p>Ссылки на полезные ресурсы: 
- <a href="https://stepik.org/course/67/promo">Stepic курс по python</a>
- <a href="https://numpy.org/doc/stable/user/numpy-for-matlab-users.html">NumPy для пользователей Matlab</a>, 
- <a href="http://www.data-analysis-in-python.org/python_for_r.html">python для пользователей R</a> ,
- <a href="https://nbviewer.jupyter.org/github/RandyBetancourt/pythonForSASUsers/tree/master/">python для пользователей SAS</a>.  </p>
<p>Содержание
- <a href="posts/numpy-tutorial/">Блокноты Jupyter и Colab</a><br>
- <a href="posts/numpy-tutorial/">Питон</a><br>
    - <a href="posts/numpy-tutorial/">Версии python</a><br>
    - <a href="posts/numpy-tutorial/">Основные типы данных</a><br>
    - <a href="posts/numpy-tutorial/">Контейнеры</a><br>
        - <a href="posts/numpy-tutorial/">Списках</a><br>
        - <a href="posts/numpy-tutorial/">Словари</a><br>
        - <a href="posts/numpy-tutorial/">Множество</a><br>
        - <a href="posts/numpy-tutorial/">Кортежи</a><br>
    - <a href="posts/numpy-tutorial/">Функции</a><br>
    - <a href="posts/numpy-tutorial/">Классы</a><br>
- <a href="posts/numpy-tutorial/">Numpy</a><br>
    - <a href="posts/numpy-tutorial/">Массивы</a><br>
    - <a href="posts/numpy-tutorial/">Индексация массивов</a><br>
    - <a href="posts/numpy-tutorial/">Типы данных</a><br>
    - <a href="posts/numpy-tutorial/">Математические операции с массивами</a><br>
    - <a href="posts/numpy-tutorial/">Broadcasting</a><br>
    - <a href="posts/numpy-tutorial/">Документация Numpy</a> <br>
- <a href="posts/numpy-tutorial/">SciPy</a><br>
    - <a href="posts/numpy-tutorial/">Операции с изображениями</a><br>
    - <a href="posts/numpy-tutorial/">Файлы MATLAB</a><br>
    - <a href="posts/numpy-tutorial/">Расстояние между точками</a><br>
- <a href="posts/numpy-tutorial/">Matplotlib</a><br>
    - <a href="posts/numpy-tutorial/">Постоение кривой</a><br>
    - <a href="posts/numpy-tutorial/">Побочные сюжеты</a><br>
    - <a href="posts/numpy-tutorial/">Изображения</a>  </p>
<h2>Блокноты Jupyter и Colab</h2>
<p>Прежде чем мы углубимся в <em>python</em>, мы хотели бы кратко поговорить о <em>блокнотах</em>. 
Блокнот <em>Jupyter</em> позволяет писать и выполнять код <em>python</em> <em>локально</em> в вашем веб-браузере. 
<em>Jupyter notebooks</em> yпрощает работу с кодом и выполняет его по блокам. 
По этой причине он широко используется в научных вычислениях. 
<em>Colab</em>, с другой стороны, является разновидностью <em>Google-блокнота</em> <em>Jupyter</em>, который особенно подходит для машинных алгоритмов обучения и анализа данных, которые сохраняют функционал в <em>облаке</em>. 
<em>Colab</em> — это, по сути, <em>Jupyter</em> notebook на стероидах: он бесплатный, не требует настройки, поставляется с предустановленными пакетами, им легко поделиться со всем миром. 
В нем присутствуют преимущества бесплатного доступа к аппаратным ускорителям, таким как графические процессоры и <em>TPU</em> (с некоторыми оговорками).  </p>
<p><strong>Запустите Tutorial в Colab (рекомендуется)</strong>. Если вы хотите выполнить это руководство полностью в <em>Colab</em>, нажмите на значок <code>Open in Colab</code> в самом верху этой страницы.</p>
<p><strong>Запустите Tutorial в блокноте Jupyter</strong>. Если вы хотите запустить блокнот локально с помощью <em>Jupyter</em>, убедитесь, что ваша виртуальная среда установлена правильно (в соответствии с <a href="https://cs231n.github.io/setup-instructions/">инструкциями по настройке</a>), активируйте ее, а затем запустите <code>pip install notebook</code> для установки блокнота <em>Jupyter</em>. Затем <a href="https://raw.githubusercontent.com/cs231n/cs231n.github.io/master/jupyter-notebook-tutorial.ipynb">откройте блокнот</a> и загрузите его в каталог по вашему выбору, щелкнув правой кнопкой мыши по странице и выбрав <code>Save Page As</code>. Затем <code>cd</code> в этот каталог и запустите <code>jupyter notebook</code>.     </p>
<p><img alt="" src="https://cs231n.github.io/assets/ipython-tutorial/file-browser.png"></p>
<p>Это должно автоматически запустить сервер блокнотов по адресу <code>http://localhost:8888</code>. Если все работало правильно, вы должны увидеть такой экран, показывающий все доступные записные книжки в текущем каталоге. Нажмите <code>jupyter-notebook-tutorial.ipynb</code> и следуйте инструкциям в блокноте. В противном случае вы можете продолжить чтение туториала с фрагментами кода ниже.   </p>
<h2>Python</h2>
<p><strong>Python</strong> — это высокоуровневый, динамически типизированный мультипарадигмальный язык программирования. О коде на <em>python</em> часто говорят, что он похож на псевдокод, поскольку он позволяет вам выражать очень мощные идеи в очень немногих строках кода, оставаясь при этом очень удобочитаемый. В качестве примера приведем реализацию алгоритма классической быстрой сортировки на <em>python</em>:  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">quicksort</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>
    <span class="n">pivot</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
    <span class="n">left</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">middle</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arr</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">middle</span> <span class="o">+</span> <span class="n">quicksort</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">quicksort</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]))</span>
<span class="c1"># Prints "[1, 1, 2, 3, 6, 8, 10]"</span>
</pre></div>

<h3>Версии python</h3>
<p>С 1 января 2020 года python <a href="https://www.python.org/doc/sunset-python-2/">официально прекратил поддержку</a> второй версии. 
<strong>Поэтому во всех примерах код написан на python 3.7</strong>. Убедитесь, что вы правильно установили виртуальную среду, прежде чем продолжить работу с этим руководством. Вы можете проверить свою версию в командной строке после активации среды, запустив команду: <code>python --version</code>  </p>
<h3>Основные типы данных</h3>
<p>Как и большинство языков, <em>python</em> имеет ряд основных типов: <em>int</em>, <em>floats</em>, <em>booleans</em> и <em>strings</em>. 
Эти типы данных ведут себя так же, как и в большинстве других языков программирования.  </p>
<p><strong>Числа</strong>:  </p>
<div class="code"><pre class="code literal-block"><span class="n">x</span> <span class="o">=</span> <span class="mi">3</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'int'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># Prints "3"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Addition; prints "4"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>   <span class="c1"># Subtraction; prints "2"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Multiplication; prints "6"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Exponentiation; prints "9"</span>
<span class="n">x</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints "4"</span>
<span class="n">x</span> <span class="o">*=</span> <span class="mi">2</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Prints "8"</span>
<span class="n">y</span> <span class="o">=</span> <span class="mf">2.5</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">y</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'float'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Prints "2.5 3.5 5.0 6.25"</span>
</pre></div>

<p>Обратите внимание, что в отличие от многих языков, в python нет унарного инкремента (<code>x++</code>) или декремента (<code>x--</code>).   </p>
<p><em>Python</em> также имеет встроенные типы для комплексных чисел; 
Все подробности можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#numeric-types-int-float-complex">в документации</a>.</p>
<p><strong>Логический тип данных</strong>: <em>python</em> реализует все обычные операторы для булевой логики, но использует английские слова, а не символы (<code>&amp;&amp;</code>, <code>||</code> , и т. д.):   </p>
<div class="code"><pre class="code literal-block"><span class="n">t</span> <span class="o">=</span> <span class="kc">True</span>
<span class="n">f</span> <span class="o">=</span> <span class="kc">False</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="c1"># Prints "&lt;class 'bool'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="ow">and</span> <span class="n">f</span><span class="p">)</span> <span class="c1"># Logical AND; prints "False"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="ow">or</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Logical OR; prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="ow">not</span> <span class="n">t</span><span class="p">)</span>   <span class="c1"># Logical NOT; prints "False"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">f</span><span class="p">)</span>  <span class="c1"># Logical XOR; prints "True"</span>
</pre></div>

<p><strong>Строки</strong>: <em>python</em> имеет отличную поддержку строк:  </p>
<div class="code"><pre class="code literal-block"><span class="n">hello</span> <span class="o">=</span> <span class="s1">'hello'</span>    <span class="c1"># String literals can use single quotes</span>
<span class="n">world</span> <span class="o">=</span> <span class="s2">"world"</span>    <span class="c1"># or double quotes; it does not matter.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>       <span class="c1"># Prints "hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">hello</span><span class="p">))</span>  <span class="c1"># String length; prints "5"</span>
<span class="n">hw</span> <span class="o">=</span> <span class="n">hello</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="n">world</span>  <span class="c1"># String concatenation</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hw</span><span class="p">)</span>  <span class="c1"># prints "hello world"</span>
<span class="n">hw12</span> <span class="o">=</span> <span class="s1">'</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1"> </span><span class="si">%d</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">hello</span><span class="p">,</span> <span class="n">world</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span>  <span class="c1"># sprintf style string formatting</span>
<span class="nb">print</span><span class="p">(</span><span class="n">hw12</span><span class="p">)</span>  <span class="c1"># prints "hello world 12"  </span>
</pre></div>

<p>Строковые объекты имеют множество полезных методов:  </p>
<div class="code"><pre class="code literal-block"><span class="n">s</span> <span class="o">=</span> <span class="s2">"hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">capitalize</span><span class="p">())</span>  <span class="c1"># Capitalize a string; prints "Hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>       <span class="c1"># Convert a string to uppercase; prints "HELLO"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">rjust</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>      <span class="c1"># Right-justify a string, padding with spaces; prints "  hello"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="mi">7</span><span class="p">))</span>     <span class="c1"># Center a string, padding with spaces; prints " hello "</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">'l'</span><span class="p">,</span> <span class="s1">'(ell)'</span><span class="p">))</span>  <span class="c1"># Replace all instances of one substring with another;</span>
                                <span class="c1"># prints "he(ell)(ell)o"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'  world '</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>  <span class="c1"># Strip leading and trailing whitespace; prints "world"</span>
</pre></div>

<p>Список всех строковых методов можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#string-methods">в документации</a>.</p>
<h3>Контейнеры</h3>
<p>Python включает в себя несколько встроенных типов контейнеров: списки, словари, наборы и кортежи.</p>
<h4>Списки</h4>
<p>Список в <em>python</em> является эквивалентом массива, но его размер можно изменять и он можетё содержать элементы разных типов:  </p>
<div class="code"><pre class="code literal-block"><span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>    <span class="c1"># Create a list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># Prints "[3, 1, 2] 2"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>     <span class="c1"># Negative indices count from the end of the list; prints "2"</span>
<span class="n">xs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'foo'</span>     <span class="c1"># Lists can contain elements of different types</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>         <span class="c1"># Prints "[3, 1, 'foo']"</span>
<span class="n">xs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">)</span>  <span class="c1"># Add a new element to the end of the list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">xs</span><span class="p">)</span>         <span class="c1"># Prints "[3, 1, 'foo', 'bar']"</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">xs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>      <span class="c1"># Remove and return the last element of the list</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>      <span class="c1"># Prints "bar [3, 1, 'foo']"  </span>
</pre></div>

<p>Как обычно, вы можете найти подробности о <a href="https://docs.python.org/3.9/tutorial/datastructures.html#more-on-lists">списках в документации</a>.  </p>
<p><strong>Разрезание на ломтики</strong>: В дополнение к доступу к элементам списка по одному, <em>python</em> предоставляет лаконичный синтаксис для доступа к подспискам; Это называется нарезкой:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>     <span class="c1"># range is a built-in function that creates a list of integers</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>               <span class="c1"># Prints "[0, 1, 2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">])</span>          <span class="c1"># Get a slice from index 2 to 4 (exclusive); prints "[2, 3]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>           <span class="c1"># Get a slice from index 2 to the end; prints "[2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>           <span class="c1"># Get a slice from the start to index 2 (exclusive); prints "[0, 1]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:])</span>            <span class="c1"># Get a slice of the whole list; prints "[0, 1, 2, 3, 4]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>          <span class="c1"># Slice indices can be negative; prints "[0, 1, 2, 3]"</span>
<span class="n">nums</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]</span>        <span class="c1"># Assign a new sublist to a slice</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>               <span class="c1"># Prints "[0, 1, 8, 9, 4]" </span>
</pre></div>

<p>Мы снова увидим нарезку в контексте массивов numpy.  </p>
<p><strong>Петли</strong>: Вы можете перебирать элементы списка следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
<span class="c1"># Prints "cat", "dog", "monkey", each on its own line.</span>
</pre></div>

<p>Если вы хотите получить доступ к индексу каждого элемента в теле цикла, воспользуйтесь встроенной функцией:<code>enumerate</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'monkey'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">animal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">animals</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'#</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">animal</span><span class="p">))</span>
<span class="c1"># Prints "#1: cat", "#2: dog", "#3: monkey", each on its own line  </span>
</pre></div>

<p><strong>Список включений</strong>: при программировании мы часто хотим преобразовать один тип данных в другой. В качестве простого примера рассмотрим следующий код, который вычисляет квадратные числа:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">:</span>
    <span class="n">squares</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># Prints [0, 1, 4, 9, 16]</span>
</pre></div>

<p>Вы можете упростить этот код с помощью <strong>спискового понимания</strong>:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">squares</span><span class="p">)</span>   <span class="c1"># Prints [0, 1, 4, 9, 16]</span>
</pre></div>

<p>Включения списка также могут содержать условия:    </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">even_squares</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">even_squares</span><span class="p">)</span>  <span class="c1"># Prints "[0, 4, 16]"</span>
</pre></div>

<h4>Словари</h4>
<p>Словарь хранит пары (ключ, значение), аналогично <code>Map</code> в <em>Java</em> или объекту в <em>Javascript</em>. Вы можете использовать его следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">:</span> <span class="s1">'cute'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">:</span> <span class="s1">'furry'</span><span class="p">}</span>  <span class="c1"># Create a new dictionary with some data</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'cat'</span><span class="p">])</span>       <span class="c1"># Get an entry from a dictionary; prints "cute"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'cat'</span> <span class="ow">in</span> <span class="n">d</span><span class="p">)</span>     <span class="c1"># Check if a dictionary has a given key; prints "True"</span>
<span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'wet'</span>     <span class="c1"># Set an entry in a dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">])</span>      <span class="c1"># Prints "wet"</span>
<span class="c1"># print(d['monkey'])  # KeyError: 'monkey' not a key of d</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'monkey'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span>  <span class="c1"># Get an element with a default; prints "N/A"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span>    <span class="c1"># Get an element with a default; prints "wet"</span>
<span class="k">del</span> <span class="n">d</span><span class="p">[</span><span class="s1">'fish'</span><span class="p">]</span>         <span class="c1"># Remove an element from a dictionary</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">,</span> <span class="s1">'N/A'</span><span class="p">))</span> <span class="c1"># "fish" is no longer a key; prints "N/A"</span>
</pre></div>

<p>Все, что вам нужно знать о словарях, вы можете найти <a href="https://docs.python.org/3.9/library/stdtypes.html#dict">в документации</a>.  </p>
<p><strong>Петли</strong>: Перебирать ключи в словаре очень просто:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'person'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'spider'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">d</span><span class="p">:</span>
    <span class="n">legs</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">animal</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'A </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> legs'</span> <span class="o">%</span> <span class="p">(</span><span class="n">animal</span><span class="p">,</span> <span class="n">legs</span><span class="p">))</span>
<span class="c1"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs" </span>
</pre></div>

<p>Если вы хотите получить доступ к ключам и их соответствующим значениям, используйте метод:<code>items</code>  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'person'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">'cat'</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">'spider'</span><span class="p">:</span> <span class="mi">8</span><span class="p">}</span>
<span class="k">for</span> <span class="n">animal</span><span class="p">,</span> <span class="n">legs</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'A </span><span class="si">%s</span><span class="s1"> has </span><span class="si">%d</span><span class="s1"> legs'</span> <span class="o">%</span> <span class="p">(</span><span class="n">animal</span><span class="p">,</span> <span class="n">legs</span><span class="p">))</span>
<span class="c1"># Prints "A person has 2 legs", "A cat has 4 legs", "A spider has 8 legs"</span>
</pre></div>

<p><strong>Словарное понимание</strong>: Они похожи на включения списков, но позволяют легко создавать cловари. Например:  </p>
<div class="code"><pre class="code literal-block"><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
<span class="n">even_num_to_square</span> <span class="o">=</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">**</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nums</span> <span class="k">if</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">even_num_to_square</span><span class="p">)</span>  <span class="c1"># Prints "{0: 0, 2: 4, 4: 16}"</span>
</pre></div>

<h4>Наборы</h4>
<p>Наборы — это неупорядоченное множество отдельных элементов. В качестве простого примера рассмотрим следующее:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'cat'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>   <span class="c1"># Check if an element is in a set; prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'fish'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>  <span class="c1"># prints "False"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'fish'</span><span class="p">)</span>       <span class="c1"># Add an element to a set</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">'fish'</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">)</span>  <span class="c1"># Prints "True"</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Number of elements in a set; prints "3"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)</span>        <span class="c1"># Adding an element that is already in the set does nothing</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Prints "3"</span>
<span class="n">animals</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">'cat'</span><span class="p">)</span>     <span class="c1"># Remove an element from a set</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">animals</span><span class="p">))</span>       <span class="c1"># Prints "2"</span>
</pre></div>

<p>Как обычно, все, что вы хотите знать о множествах, можно найти <a href="https://docs.python.org/3.9/library/stdtypes.html#set">в документации</a>.  </p>
<p><strong>Петли</strong>: Перебор набора имеет тот же синтаксис, что и перебор списка; 
Однако, поскольку наборы не упорядочены, вы не можете делать предположения о порядке, в которых вы посещаете элементы набора:  </p>
<div class="code"><pre class="code literal-block"><span class="n">animals</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'cat'</span><span class="p">,</span> <span class="s1">'dog'</span><span class="p">,</span> <span class="s1">'fish'</span><span class="p">}</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">animal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">animals</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">'#</span><span class="si">%d</span><span class="s1">: </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">animal</span><span class="p">))</span>
<span class="c1"># Prints "#1: fish", "#2: dog", "#3: cat"  </span>
</pre></div>

<p><strong>Набор понятий</strong>: подобно спискам и словарям, мы можем легко создавать наборы, используя включения множеств:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span>
<span class="n">nums</span> <span class="o">=</span> <span class="p">{</span><span class="nb">int</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">30</span><span class="p">)}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span>  <span class="c1"># Prints "{0, 1, 2, 3, 4, 5}"</span>
</pre></div>

<h4>Кортежи</h4>
<p>Кортеж — это (<em>неизменяемый</em>) упорядоченный список значений. Кортеж во многом похож на список; Одним из наиболее важных отличий является то, что кортежи можно использовать как ключи в словарях и как элементы множеств, а списки — нет. Вот банальный пример:  </p>
<div class="code"><pre class="code literal-block"><span class="n">d</span> <span class="o">=</span> <span class="p">{(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span> <span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)}</span>  <span class="c1"># Create a dictionary with tuple keys</span>
<span class="n">t</span> <span class="o">=</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>        <span class="c1"># Create a tuple</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>    <span class="c1"># Prints "&lt;class 'tuple'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>       <span class="c1"># Prints "5"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>  <span class="c1"># Prints "1"</span>
</pre></div>

<p><a href="https://docs.python.org/3.9/tutorial/datastructures.html#tuples-and-sequences">В документации</a> есть больше информации о кортежах.  </p>
<h3>Функции</h3>
<p>Функции python определяются с помощью ключевого слова. Например:<code>def</code>  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">sign</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'positive'</span>
    <span class="k">elif</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'negative'</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s1">'zero'</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
<span class="c1"># Prints "negative", "zero", "positive"</span>
</pre></div>

<p>Мы часто определяем функции, принимающие необязательные аргументы ключевых слов, например:  </p>
<div class="code"><pre class="code literal-block"><span class="k">def</span><span class="w"> </span><span class="nf">hello</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">loud</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'HELLO, </span><span class="si">%s</span><span class="s1">!'</span> <span class="o">%</span> <span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">'Hello, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="n">name</span><span class="p">)</span>

<span class="n">hello</span><span class="p">(</span><span class="s1">'Bob'</span><span class="p">)</span> <span class="c1"># Prints "Hello, Bob"</span>
<span class="n">hello</span><span class="p">(</span><span class="s1">'Fred'</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># Prints "HELLO, FRED!" </span>
</pre></div>

<p>В <a href="https://docs.python.org/3.9/tutorial/controlflow.html#defining-functions">документации</a> есть гораздо больше информации о функциях <em>python</em>.  </p>
<h4>Классы</h4>
<p>Синтаксис для определения классов в <em>python</em> прост:  </p>
<div class="code"><pre class="code literal-block"><span class="k">class</span><span class="w"> </span><span class="nc">Greeter</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="c1"># Constructor</span>
    <span class="k">def</span><span class="w"> </span><span class="o">**</span><span class="n">init</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>  <span class="c1"># Create an instance variable</span>

    <span class="c1"># Instance method</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">greet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loud</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">loud</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'HELLO, </span><span class="si">%s</span><span class="s1">!'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">'Hello, </span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">Greeter</span><span class="p">(</span><span class="s1">'Fred'</span><span class="p">)</span>  <span class="c1"># Construct an instance of the Greeter class</span>
<span class="n">g</span><span class="o">.</span><span class="n">greet</span><span class="p">()</span>            <span class="c1"># Call an instance method; prints "Hello, Fred"</span>
<span class="n">g</span><span class="o">.</span><span class="n">greet</span><span class="p">(</span><span class="n">loud</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>   <span class="c1"># Call an instance method; prints "HELLO, FRED!"</span>
</pre></div>

<p>Вы можете прочитать гораздо больше о классах <em>python</em> <a href="https://docs.python.org/3.9/tutorial/classes.html">в документации</a>.  </p>
<h2>Numpy</h2>
<p><a href="http://www.numpy.org/">Numpy</a> — это основная библиотека для научных вычислений на языке <em>python</em>. Она предоставляет высокопроизводительный многомерный массив объектов и инструменты для работы с ними Массивы. Если вы уже знакомы с <em>MATLAB</em>, <a href="https://docs.scipy.org/doc/numpy/user/numpy-for-matlab-users.html">то этот урок может быть вам полезен</a> для начала работы с <em>Numpy</em>.  </p>
<h3>Массивы</h3>
<p>Массив numpy представляет собой сетку значений одного и того же типа, индексирующую кортежем неотрицательные целые числа. Количество измерений — это ранг массива; Форма массива представляет собой кортеж целых чисел, задающий размер массива вдоль каждого измерения.  </p>
<p>Мы можем инициализировать массивы <em>numpy</em> из вложенных списков <em>python</em>, и получить доступ к элементам с помощью квадратных скобок:  </p>
<div class="code"><pre class="code literal-block"> <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>   <span class="c1"># Create a rank 1 array</span>
<span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>            <span class="c1"># Prints "&lt;class 'numpy.ndarray'&gt;"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>            <span class="c1"># Prints "(3,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>   <span class="c1"># Prints "1 2 3"</span>
<span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span>                  <span class="c1"># Change an element of the array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>                  <span class="c1"># Prints "[5, 2, 3]"</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>    <span class="c1"># Create a rank 2 array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>                     <span class="c1"># Prints "(2, 3)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>   <span class="c1"># Prints "1 2 4"  </span>
</pre></div>

<p><em>Numpy</em> также предоставляет множество функций для создания массивов:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>   <span class="c1"># Create an array of all zeros</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>              <span class="c1"># Prints "[[ 0.  0.]</span>
                      <span class="c1">#          [ 0.  0.]]"</span>

<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>    <span class="c1"># Create an array of all ones</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>              <span class="c1"># Prints "[[ 1.  1.]]"</span>

<span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span>  <span class="c1"># Create a constant array</span>
<span class="nb">print</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>               <span class="c1"># Prints "[[ 7.  7.]</span>
                       <span class="c1">#          [ 7.  7.]]"</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>         <span class="c1"># Create a 2x2 identity matrix</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>              <span class="c1"># Prints "[[ 1.  0.]</span>
                      <span class="c1">#          [ 0.  1.]]"</span>

<span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># Create an array filled with random values</span>
<span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>                     <span class="c1"># Might print "[[ 0.91940167  0.08143941]</span>
                             <span class="c1">#               [ 0.68744134  0.87236687]]"</span>
</pre></div>

<p><strong>О других способах создания массивов вы можете прочитать</strong> <a href="http://docs.scipy.org/doc/numpy/user/basics.creation.html#arrays-creation">в документации</a>.</p>
<h3>Индексация массивов</h3>
<p><em>Numpy</em> предлагает несколько способов индексации в массивы.  </p>
<p><strong>Разрезание на ломтики</strong>: как и в случае со списками <em>python</em>, массивы numpy могут быть разделены на срезы. Поскольку массивы могут быть многомерными, необходимо указать срез для каждого измерения массива:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create the following rank 2 array with shape (3, 4)</span>
<span class="c1"># [[ 1  2  3  4]</span>
<span class="c1">#  [ 5  6  7  8]</span>
<span class="c1">#  [ 9 10 11 12]]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>

<span class="c1"># Use slicing to pull out the subarray consisting of the first 2 rows</span>
<span class="c1"># and columns 1 and 2; b is the following array of shape (2, 2):</span>
<span class="c1"># [[2 3]</span>
<span class="c1">#  [6 7]]</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>

<span class="c1"># A slice of an array is a view into the same data, so modifying it</span>
<span class="c1"># will modify the original array.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># Prints "2"</span>
<span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">77</span>     <span class="c1"># b[0, 0] is the same piece of data as a[0, 1]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>   <span class="c1"># Prints "77"</span>
</pre></div>

<p>Вы также можете сочетать целочисленное индексирование с индексированием срезов. Однако это приведет к получению массива более низкого ранга, чем исходный массив. Обратите внимание, что это сильно отличается от способа, которым <em>MATLAB</em> работает с массивами при разрезании на ломтики:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create the following rank 2 array with shape (3, 4)</span>
<span class="c1"># [[ 1  2  3  4]</span>
<span class="c1">#  [ 5  6  7  8]</span>
<span class="c1">#  [ 9 10 11 12]]</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">],</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">11</span><span class="p">,</span><span class="mi">12</span><span class="p">]])</span>

<span class="c1"># Two ways of accessing the data in the middle row of the array.</span>
<span class="c1"># Mixing integer indexing with slices yields an array of lower rank,</span>
<span class="c1"># while using only slices yields an array of the same rank as the</span>
<span class="c1"># original array:</span>
<span class="n">row_r1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>    <span class="c1"># Rank 1 view of the second row of a</span>
<span class="n">row_r2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># Rank 2 view of the second row of a</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_r1</span><span class="p">,</span> <span class="n">row_r1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[5 6 7 8] (4,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">row_r2</span><span class="p">,</span> <span class="n">row_r2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[[5 6 7 8]] (1, 4)"</span>

<span class="c1"># We can make the same distinction when accessing columns of an array:</span>
<span class="n">col_r1</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
<span class="n">col_r2</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">col_r1</span><span class="p">,</span> <span class="n">col_r1</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[ 2  6 10] (3,)"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">col_r2</span><span class="p">,</span> <span class="n">col_r2</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2]</span>
                             <span class="c1">#          [ 6]</span>
                             <span class="c1">#          [10]] (3, 1)"</span>
</pre></div>

<p><strong>Индексация целочисленного массива</strong>: Когда вы индексируете массивы <em>numpy</em> с помощью слайсинга, результирующее представление массива всегда будет подмассивом исходного массива. В противоположность этому, индексация целочисленного массива позволяет создавать произвольные массивы, используя данные из другого массива. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="c1"># An example of integer array indexing.</span>
<span class="c1"># The returned array will have shape (3,) and</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>  <span class="c1"># Prints "[1 4 5]"</span>

<span class="c1"># The above example of integer array indexing is equivalent to this:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]))</span>  <span class="c1"># Prints "[1 4 5]"</span>

<span class="c1"># When using integer array indexing, you can reuse the same</span>
<span class="c1"># element from the source array:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>  <span class="c1"># Prints "[2 2]"</span>

<span class="c1"># Equivalent to the previous integer array indexing example</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]))</span>  <span class="c1"># Prints "[2 2]"</span>
</pre></div>

<p>Одним из полезных приемов при индексации целочисленных массивов является выбор или изменение в одногм из них каждой строки матрицы:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Create a new array from which we will select elements</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># prints "array([[ 1,  2,  3],</span>
          <span class="c1">#                [ 4,  5,  6],</span>
          <span class="c1">#                [ 7,  8,  9],</span>
          <span class="c1">#                [10, 11, 12]])"</span>

<span class="c1"># Create an array of indices</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

<span class="c1"># Select one element from each row of a using the indices in b</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">])</span>  <span class="c1"># Prints "[ 1  6  7 11]"</span>

<span class="c1"># Mutate one element from each row of a using the indices in b</span>
<span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">b</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">10</span>

<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>  <span class="c1"># prints "array([[11,  2,  3],</span>
          <span class="c1">#                [ 4,  5, 16],</span>
          <span class="c1">#                [17,  8,  9],</span>
          <span class="c1">#                [10, 21, 12]])</span>
</pre></div>

<p><strong>Индексация логических массивов</strong>: Логическое индексирование массива позволяет выделять произвольные элементы массива. Часто этот тип индексации используется для выбора элементов массива которые удовлетворяют какому-либо условию. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>

<span class="n">bool_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>   <span class="c1"># Find the elements of a that are bigger than 2;</span>
                     <span class="c1"># this returns a numpy array of Booleans of the same</span>
                     <span class="c1"># shape as a, where each slot of bool_idx tells</span>
                     <span class="c1"># whether that element of a is &gt; 2.</span>

<span class="nb">print</span><span class="p">(</span><span class="n">bool_idx</span><span class="p">)</span>      <span class="c1"># Prints "[[False False]</span>
                     <span class="c1">#          [ True  True]</span>
                     <span class="c1">#          [ True  True]]"</span>

<span class="c1"># We use boolean array indexing to construct a rank 1 array</span>
<span class="c1"># consisting of the elements of a corresponding to the True values</span>
<span class="c1"># of bool_idx</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">bool_idx</span><span class="p">])</span>  <span class="c1"># Prints "[3 4 5 6]"</span>

<span class="c1"># We can do all of the above in a single concise statement:</span>
<span class="nb">print</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">a</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">])</span>     <span class="c1"># Prints "[3 4 5 6]"</span>
</pre></div>

<p>Для краткости мы опустили много подробностей об индексации массива <em>numpy</em>; Если вы хотите узнать больше, вам следует <a href="http://docs.scipy.org/doc/numpy/reference/arrays.indexing.html">прочитать документацию</a>.  </p>
<h3>Типы данных</h3>
<p>Каждый массив <em>numpy</em> представляет собой сетку элементов одного типа. <em>Numpy</em> предоставляет большой набор числовых типов данных, которые можно использовать для создания массивов. <em>Numpy</em> пытается определить тип данных при создании массива, но функции, создающие массивы, обычно также включают необязательный аргумент для явного указания типа данных. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>   <span class="c1"># Let numpy choose the datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>         <span class="c1"># Prints "int64"</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">])</span>   <span class="c1"># Let numpy choose the datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>             <span class="c1"># Prints "float64"</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>   <span class="c1"># Force a particular datatype</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>                         <span class="c1"># Prints "int64"</span>
</pre></div>

<p>Вы можете прочитать все о типах данных <em>numpy</em> <a href="http://docs.scipy.org/doc/numpy/reference/arrays.dtypes.html">в документации</a>.</p>
<h3>Математические операции с массивами</h3>
<p>Основные математические функции работают с массивами поэлементно и доступны как в виде перегрузок операторов, так и в виде функций в модуле <em>numpy</em>:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

<span class="c1"># Elementwise sum; both produce the array</span>
<span class="c1"># [[ 6.0  8.0]</span>
<span class="c1">#  [10.0 12.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise difference; both produce the array</span>
<span class="c1"># [[-4.0 -4.0]</span>
<span class="c1">#  [-4.0 -4.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise product; both produce the array</span>
<span class="c1"># [[ 5.0 12.0]</span>
<span class="c1">#  [21.0 32.0]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise division; both produce the array</span>
<span class="c1"># [[ 0.2         0.33333333]</span>
<span class="c1">#  [ 0.42857143  0.5       ]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="n">y</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

<span class="c1"># Elementwise square root; produces the array</span>
<span class="c1"># [[ 1.          1.41421356]</span>
<span class="c1">#  [ 1.73205081  2.        ]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>

<p>Обратите внимание, что в отличие от <em>MATLAB</em>,<code>*</code>- это поэлементное умножение, а не матрица умножение. Вместо этого мы используем функцию <code>dot</code> для вычисления скалярного произведения векторов, умножить вектор на матрицу, и умножения матриц. <code>dot</code> доступен как функция в numpy и в качестве экземпляра метода объектов массива:    </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">]])</span>

<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">9</span><span class="p">,</span><span class="mi">10</span><span class="p">])</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">])</span>

<span class="c1"># Inner product of vectors; both produce 219</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>

<span class="c1"># Matrix / vector product; both produce the rank 1 array [29 67]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

<span class="c1"># Matrix / matrix product; both produce the rank 2 array</span>
<span class="c1"># [[19 22]</span>
<span class="c1">#  [43 50]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</pre></div>

<p><em>Numpy</em> предоставляет множество полезных функций для выполнения вычислений на массивах; Одной из самых полезных является:<code>sum</code>  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>

<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>  <span class="c1"># Compute sum of all elements; prints "10"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>  <span class="c1"># Compute sum of each column; prints "[4 6]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Compute sum of each row; prints "[3 7]"</span>
</pre></div>

<p>Полный список математических функций, предоставляемых <em>numpy</em>, вы можете найти <a href="http://docs.scipy.org/doc/numpy/reference/routines.math.html">в документации</a>.</p>
<p>Помимо вычисления математических функций с помощью массивов, мы часто должны изменять форму данных в массивах или иным образом манипулировать ими. Самый простой пример. Одним из таких видов операции является транспонирование матрицы; для транспонирования матрицы, просто используйте атрибут <code>T</code> объекта массива:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>    <span class="c1"># Prints "[[1 2]</span>
            <span class="c1">#          [3 4]]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Prints "[[1 3]</span>
            <span class="c1">#          [2 4]]"</span>

<span class="c1"># Note that taking the transpose of a rank 1 array does nothing:</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>    <span class="c1"># Prints "[1 2 3]"</span>
<span class="nb">print</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>  <span class="c1"># Prints "[1 2 3]"</span>
</pre></div>

<p><em>Numpy</em> предоставляет гораздо больше функций для работы с массивами; С полным списком можно ознакомиться <a href="http://docs.scipy.org/doc/numpy/reference/routines.array-manipulation.html">в документации</a>.</p>
<h3>Вещание</h3>
<p><strong>Вещание</strong> - это мощный механизм, который позволяет <em>numpy</em> работать с массивами различных фигур при выполнении арифметических действий. Часто у нас есть меньший массив и больший массив, и мы хотим использовать меньший массив несколько раз для выполнения какой-либо операции на более крупном массиве.  </p>
<p>Например, предположим, что мы хотим добавить вектор константы к каждой строке матрицы. Мы могли бы сделать это следующим образом:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>   <span class="c1"># Create an empty matrix with the same shape as x</span>

<span class="c1"># Add the vector v to each row of the matrix x with an explicit loop</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
    <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">v</span>

<span class="c1"># Now y is the following</span>
<span class="c1"># [[ 2  2  4]</span>
<span class="c1">#  [ 5  5  7]</span>
<span class="c1">#  [ 8  8 10]</span>
<span class="c1">#  [11 11 13]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> 
</pre></div>

<p>Это работает, однако, когда матрица <code>x</code> очень большая, вычисление явного цикла в <em>python</em> может быть медленным. Обратите внимание, что добавление вектора <code>v</code> к каждой строке матрицы <code>x</code> эквивалентно формированию матрицы <code>vv</code> путем наложения нескольких копий <code>v</code> по вертикали, затем выполнение поэлементного суммирования <code>x</code> и <code>vv</code> мы могли бы реализовать этот подход следующим образом:        </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">vv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>   <span class="c1"># Stack 4 copies of v on top of each other</span>
<span class="nb">print</span><span class="p">(</span><span class="n">vv</span><span class="p">)</span>                 <span class="c1"># Prints "[[1 0 1]</span>
                          <span class="c1">#          [1 0 1]</span>
                          <span class="c1">#          [1 0 1]</span>
                          <span class="c1">#          [1 0 1]]"</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">vv</span>  <span class="c1"># Add x and vv elementwise</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2  2  4</span>
          <span class="c1">#          [ 5  5  7]</span>
          <span class="c1">#          [ 8  8 10]</span>
          <span class="c1">#          [11 11 13]]"</span>
</pre></div>

<p>Массивы Numpy позволяют выполнять вычисления без фактического создания нескольких копий <code>v</code>. Рассмотрим эту версию с использованием массивов:</p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># We will add the vector v to each row of the matrix x,</span>
<span class="c1"># storing the result in the matrix y</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">9</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">]])</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">v</span>  <span class="c1"># Add v to each row of x using broadcasting</span>
<span class="nb">print</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>  <span class="c1"># Prints "[[ 2  2  4]</span>
          <span class="c1">#          [ 5  5  7]</span>
          <span class="c1">#          [ 8  8 10]</span>
          <span class="c1">#          [11 11 13]]"</span>
</pre></div>

<p>Строка <code>y = x + v</code> работает, несмотря на то, что <code>x</code> имеет форму  <code>(4, 3)</code>и <code>v</code> имеет форму <code>(3,)</code> благодаря вещанию; Эта линия работает так, как будто <code>v</code> на самом деле имеет форму <code>(4, 3)</code>, где каждая строка была копией , а сумма <code>v</code> выполнялась по элементам.     </p>
<p>Трансляция двух массивов одновременно выполняется по следующим правилам:
1. Если массивы имеют разный ранг, добавьте в начало форму массива с меньшим рангом с <strong>1s</strong> до тех пор, пока обе фигуры не будут иметь одинаковую длину.
2. Два массива считаются <em>совместимыми</em> в размерности, если они имеют одинаковое значение size в измерении, или если один из массивов имеет размер <strong>1</strong> в этом измерении.
3. Массивы могут транслироваться вместе, если они совместимы во всех измерениях.
4. После трансляции каждый массив ведет себя так, как если бы он имел форму, равную поэлементной максимальное количество форм двух входных массивов.
5. В любом измерении, где один массив имеет размер <strong>1</strong>, а другой массив больше <strong>1</strong>, первый массив ведет себя так, как если бы он был скопирован по этому размеру  </p>
<p>Если это объяснение не имеет смысла, попробуйте прочитать объяснение <a href="http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html">из документации</a> или <a href="https://scipy.github.io/old-wiki/pages/EricsBroadcastingDoc">это объяснение</a>.  </p>
<p>Функции, поддерживающие широковещательную рассылку, называются <em>универсальными функциями</em>. Вы можете найти Список всех универсальных функций <a href="http://docs.scipy.org/doc/numpy/reference/ufuncs.html#available-ufuncs">в документации</a>.  </p>
<p>Вот некоторые области применения вещания:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="c1"># Compute outer product of vectors</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>  <span class="c1"># v has shape (3,)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">])</span>    <span class="c1"># w has shape (2,)</span>
<span class="c1"># To compute an outer product, we first reshape v to be a column</span>
<span class="c1"># vector of shape (3, 1); we can then broadcast it against w to yield</span>
<span class="c1"># an output of shape (3, 2), which is the outer product of v and w:</span>
<span class="c1"># [[ 4  5]</span>
<span class="c1">#  [ 8 10]</span>
<span class="c1">#  [12 15]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>

<span class="c1"># Add a vector to each row of a matrix</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">]])</span>
<span class="c1"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span>
<span class="c1"># giving the following matrix:</span>
<span class="c1"># [[2 4 6]</span>
<span class="c1">#  [5 7 9]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

<span class="c1"># Add a vector to each column of a matrix</span>
<span class="c1"># x has shape (2, 3) and w has shape (2,).</span>
<span class="c1"># If we transpose x then it has shape (3, 2) and can be broadcast</span>
<span class="c1"># against w to yield a result of shape (3, 2); transposing this result</span>
<span class="c1"># yields the final result of shape (2, 3) which is the matrix x with</span>
<span class="c1"># the vector w added to each column. Gives the following matrix:</span>
<span class="c1"># [[ 5  6  7]</span>
<span class="c1">#  [ 9 10 11]]</span>
<span class="nb">print</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">w</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="c1"># Another solution is to reshape w to be a column vector of shape (2, 1);</span>
<span class="c1"># we can then broadcast it directly against x to produce the same</span>
<span class="c1"># output.</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>

<span class="c1"># Multiply a matrix by a constant:</span>
<span class="c1"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span>
<span class="c1"># these can be broadcast together to shape (2, 3), producing the</span>
<span class="c1"># following array:</span>
<span class="c1"># [[ 2  4  6]</span>
<span class="c1">#  [ 8 10 12]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  
</pre></div>

<p>Широковещательная рассылка обычно делает ваш код более кратким и быстрым, поэтому вы должен стремиться использовать ее там, где это возможно.  </p>
<h3>Документация Numpy</h3>
<p>Этот краткий обзор затронул многие важные вещи, которые вам необходимо знать о <em>numpy</em>, но далеко не полны. Ознакомьтесь <a href="http://docs.scipy.org/doc/numpy/reference/">со справочником numpy</a>, чтобы узнать больше о numpy.</p>
<h2>SciPy</h2>
<p><em>Numpy</em> предоставляет высокопроизводительный многомерный массив и основные инструменты для выполняйте вычисления с помощью этих массивов и управляйте ими. 
<a href="http://docs.scipy.org/doc/scipy/reference/">SciPy</a> опирается на это и предоставляет большое количество функций, которые работают с массивами <em>numpy</em> и полезны для различных видов научных и инженерных приложений.  </p>
<p>Лучший способ познакомиться с <em>SciPy</em> - <a href="http://docs.scipy.org/doc/scipy/reference/index.html">это просмотреть документацию</a>. 
Мы выделим некоторые части <em>SciPy</em>, которые могут быть вам полезны для этого класса.</p>
<h3>Операции с изображениями</h3>
<p><em>SciPy</em> предоставляет некоторые основные функции для работы с изображениями. 
Например, в нем есть функции чтения изображений с диска в массивы <em>numpy</em>, для записи массивов <em>numpy</em> на диск в виде изображений, а также для изменения размера изображений. 
Вот простой пример, демонстрирующий эти функции:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">imread</span><span class="p">,</span> <span class="n">imsave</span><span class="p">,</span> <span class="n">imresize</span>

<span class="c1"># Read an JPEG image into a numpy array</span>
<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">'assets/cat.jpg'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>  <span class="c1"># Prints "uint8 (400, 248, 3)"</span>

<span class="c1"># We can tint the image by scaling each of the color channels</span>
<span class="c1"># by a different scalar constant. The image has shape (400, 248, 3);</span>
<span class="c1"># we multiply it by the array [1, 0.95, 0.9] of shape (3,);</span>
<span class="c1"># numpy broadcasting means that this leaves the red channel unchanged,</span>
<span class="c1"># and multiplies the green and blue channels by 0.95 and 0.9</span>
<span class="c1"># respectively.</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

<span class="c1"># Resize the tinted image to be 300 by 300 pixels.</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">imresize</span><span class="p">(</span><span class="n">img_tinted</span><span class="p">,</span> <span class="p">(</span><span class="mi">300</span><span class="p">,</span> <span class="mi">300</span><span class="p">))</span>

<span class="c1"># Write the tinted image back to disk</span>
<span class="n">imsave</span><span class="p">(</span><span class="s1">'assets/cat_tinted.jpg'</span><span class="p">,</span> <span class="n">img_tinted</span><span class="p">)</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/cat.jpg"><br><img alt="" src="https://cs231n.github.io/assets/cat_tinted.jpg"><br><strong>Сверху</strong>: исходное изображение. <strong>Снизу</strong>: Затемненное изображение с измененным размером.  </p>
<h3>Файлы MATLAB</h3>
<p>Функции <code>scipy.io.loadmat</code> и <code>scipy.io.savemat</code> позволяют считывать и писать файлы <em>MATLAB</em>. О них можно прочитать в <a href="http://docs.scipy.org/doc/scipy/reference/io.html">документации</a>.</p>
<h3>Расстояние между точками</h3>
<p><em>SciPy</em> определяет некоторые полезные функции для вычисления расстояний между наборами точек.  </p>
<p>Функция <code>scipy.spatial.distance.pdist</code> вычисляет расстояние между всеми парами точек в заданном наборе:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.spatial.distance</span><span class="w"> </span><span class="kn">import</span> <span class="n">pdist</span><span class="p">,</span> <span class="n">squareform</span>

<span class="c1"># Create the following array where each row is a point in 2D space:</span>
<span class="c1"># [[0 1]</span>
<span class="c1">#  [1 0]</span>
<span class="c1">#  [2 0]]</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Compute the Euclidean distance between all rows of x.</span>
<span class="c1"># d[i, j] is the Euclidean distance between x[i, :] and x[j, :],</span>
<span class="c1"># and d is the following array:</span>
<span class="c1"># [[ 0.          1.41421356  2.23606798]</span>
<span class="c1">#  [ 1.41421356  0.          1.        ]</span>
<span class="c1">#  [ 2.23606798  1.          0.        ]]</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">squareform</span><span class="p">(</span><span class="n">pdist</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">'euclidean'</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
</pre></div>

<p>Все подробности об этой функции вы можете прочитать в <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.pdist.html">документации</a>.  </p>
<p>Аналогичная функция (<code>scipy.spatial.distance.cdist</code>) вычисляет расстояние между всеми парами по двум группам точек; Вы можете прочитать об этом <a href="http://docs.scipy.org/doc/scipy/reference/generated/scipy.spatial.distance.cdist.html">в документации</a> .</p>
<h2>Matplotlib</h2>
<p><a href="http://matplotlib.org/">Matplotlib</a> — библиотека для построения графиков. В этом разделе дается краткое введение в модуль <code>matplotlib.pyplot</code>, который обеспечивает систему построения графиков, аналогичную системе <em>MATLAB</em>.</p>
<h3>Постоение графиков</h3>
<p>Наиболее важной функцией в <em>matplotlib</em> является <code>plot</code>, что позволяет строить графики <em>2D</em> данных. Вот простой пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on a sine curve</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Plot the points using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>  <span class="c1"># You must call plt.show() to make graphics appear.</span>
</pre></div>

<p>Выполнение этого кода создает следующий график:  </p>
<p><img alt="" src="https://cs231n.github.io/assets/sine.png"></p>
<p>Приложив немного дополнительной работы, мы можем легко построить несколько линий и добавить заголовок, легенду и подписи осям:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on sine and cosine curves</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Plot the points using matplotlib</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_sin</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_cos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">'x axis label'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'y axis label'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Sine and Cosine'</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">'Sine'</span><span class="p">,</span> <span class="s1">'Cosine'</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/sine_cosine.png"></p>
<p>Гораздо больше о функции <code>plot</code> вы можете прочитать <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.plot">в документации</a>.</p>
<h3>Подзаголовки</h3>
<p>С помощью <code>subplot</code> функции на одном и том же рисунке можно изобразить разные объекты. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Compute the x and y coordinates for points on sine and cosine curves</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
<span class="n">y_sin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_cos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="c1"># Set up a subplot grid that has height 2 and width 1,</span>
<span class="c1"># and set the first such subplot as active.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c1"># Make the first plot</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_sin</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Sine'</span><span class="p">)</span>

<span class="c1"># Set the second subplot as active, and make the second plot.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_cos</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">'Cosine'</span><span class="p">)</span>

<span class="c1"># Show the figure.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/sine_cosine_subplot.png"></p>
<p>Гораздо больше о функции <code>subplot</code> вы можете прочитать <a href="http://matplotlib.org/api/pyplot_api.html#matplotlib.pyplot.subplot">в документации</a>.</p>
<h3>Изображения</h3>
<p>Вы можете использовать функцию <code>imshow</code> для показа изображений. Вот пример:  </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">imread</span><span class="p">,</span> <span class="n">imresize</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="n">img</span> <span class="o">=</span> <span class="n">imread</span><span class="p">(</span><span class="s1">'assets/cat.jpg'</span><span class="p">)</span>
<span class="n">img_tinted</span> <span class="o">=</span> <span class="n">img</span> <span class="o">*</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]</span>

<span class="c1"># Show the original image</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>

<span class="c1"># Show the tinted image</span>
<span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

<span class="c1"># A slight gotcha with imshow is that it might give strange results</span>
<span class="c1"># if presented with data that is not uint8. To work around this, we</span>
<span class="c1"># explicitly cast the image to uint8 before displaying it.</span>
<span class="n">plt</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">(</span><span class="n">img_tinted</span><span class="p">))</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>

<p><img alt="" src="https://cs231n.github.io/assets/cat_tinted_imshow.png"></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/image-classification/" class="u-url">Классификация изображений </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/image-classification/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-14T08:00:00+03:00" itemprop="datePublished" title="2025-03-14 08:00">2025-03-14 08:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Классификация изображений</h2>
<p>В этой лекции мы познакомимся с проблемой классификации изображений. 
Решение проблемы заключается в подходе, основанном на большом объеме размеченных данных.   </p>
<p>Содержание:<br>
- <a href="posts/image-classification/#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8E-%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9">Введение в классификацию изображений</a><br>
  - <a href="posts/image-classification/#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B5%D0%B3%D0%BE-%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B0">Классификатор ближайшего соседа</a><br>
  - <a href="posts/image-classification/#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-k---%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B8%D1%85-%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B5%D0%B9">Классификатор k - ближайших соседей</a> <br>
  - <a href="posts/image-classification/#%D0%BD%D0%B0%D0%B1%D0%BE%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2">Наборы данных для настройки гиперпараметров</a><br>
  - <a href="posts/image-classification/#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-knn-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B5">Применение kNN на практике</a><br>
    - <a href="posts/image-classification/#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B">Дополнительные материалы</a> </p>
<h3>Введение в классификацию изображений</h3>
<p><strong>Мотивация</strong>. В этом разделе мы рассмотрим задачу классификации изображений. Задача заключается в присвоении входному изображению одной метки из фиксированного набора категорий. Это одна из основных задач компьютерного зрения, которая, несмотря на свою простоту, имеет множество практических применений. Более того, многие другие задачи компьютерного зрения (детекция объектов, сегментация) могут быть сведены к классификации изображений.   </p>
<p><strong>Пример</strong>. Например, на изображении ниже модель классификации изображений принимает одно изображение и присваивает вероятности четырём меткам: <em>{«кошка», «собака», «шляпа», «кружка»}</em>. Как показано на изображении, для компьютера изображение представляет собой один большой трёхмерный массив чисел. В этом примере изображение кошки имеет ширину <strong>248</strong> пикселей, высоту <strong>400</strong> пикселей и три цветовых канала: красный, зелёный, синий (или сокращённо <em>RGB</em>). Таким образом, изображение состоит из <strong>248 x 400 x 3</strong> чисел, или в общей сложности 297 600 чисел. Каждое число представляет собой целое число от 0 (чёрный) до 255 (белый). Наша задача — превратить эти четверть миллиона чисел в одну метку, например <em>«кошка»</em>.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/classify.png"></p>
<p>Задача классификации изображений состоит в том, чтобы предсказать одну метку для заданного изображения. Так же мы можем предсказать распределение вероятностей для всех меток, что отражает степень нашей уверенности в результате классификации.   Изображения представляют собой трёхмерные массивы целых чисел от 0 до 255 размером «ширина x высота x 3». Число 3 обозначает три цветовых канала: красный, зелёный и синий.  </p>
<hr>
<p><strong>Проблемы</strong>.  Поскольку задача распознавания визуального образа (например, кошки) относительно проста для человека, стоит рассмотреть связанные с ней проблемы с точки зрения алгоритма компьютерного зрения.<br>
Ниже мы приводим (неполный) список проблем, не забывая о том, что изображения представлены в виде трёхмерного массива значений яркости:<br>
- <strong>Изменение точки обзора</strong>. Один экземпляр объекта может быть ориентирован по-разному относительно камеры.<br>
- <strong>Изменение масштаба</strong>. Визуальные классы часто различаются по размеру (размеру в реальном мире, а не только по размеру на изображении).<br>
- <strong>Деформация</strong>. Многие интересующие нас объекты не являются твёрдыми телами и могут сильно деформироваться.<br>
- <strong>Окклюзия</strong>. Интересующие нас объекты могут быть частично скрыты. Иногда видна лишь небольшая часть объекта (всего несколько пикселей).<br>
- <strong>Условия освещения</strong>. Влияние освещения на пиксели очень велико.<br>
- <strong>Фоновый шум</strong>. Интересующие нас объекты могут сливаться с окружающей средой, что затрудняет их идентификацию.<br>
- <strong>Внутриклассовые различия</strong>. Классы, представляющие интерес, часто могут быть относительно обширными, например, <em>стулья</em>. 
Существует множество различных типов этих предметов, каждый из которых имеет отличный от других элементов класса внешний вид.    </p>
<p>Хорошая модель классификации изображений должна быть инвариантна к перекрёстному произведению всех этих вариаций, сохраняя при этом чувствительность к межклассовым вариациям.   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/challenges.jpeg"></p>
<hr>
<p><strong>Подход, основанный на данных</strong>. Как бы мы могли написать алгоритм, который сможет классифицировать изображения по отдельным категориям? В отличие от написания алгоритма, например, для сортировки списка чисел, не очевидно, как можно написать алгоритм для распознавания кошек на изображениях. Поэтому вместо того, чтобы пытаться описать каждую из интересующих нас категорий непосредственно в коде, мы воспользуемся подходом, похожим на обучение ребёнка. Мы предоставим компьютеру множество примеров, а затем используем алгоритм обучения, который связывает визуальное представление с меткой каждого класса. Этот подход предполагает, что у нас есть обучающий набор с размеченными изображениями. Вот пример того, как может выглядеть такой набор данных:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/trainset.jpg"></p>
<p>Пример обучающего набора для четырёх визуальных категорий. 
На практике у нас могут быть тысячи категорий и сотни тысяч изображений для каждой категории.  </p>
<hr>
<p><strong>Конвейер классификации изображений</strong>.  Мы увидели, что задача классификации изображений состоит в том, чтобы взять массив пикселей изображения и присвоить ему метку. 
Наш полный конвейер можно формализовать следующим образом:<br>
- <strong>Входные данные</strong>: состоят из набора <strong><em>N</em></strong> изображений, каждое из которых помечено одним из <strong><em>K</em></strong> различных классов. 
Эти данные называются <em>обучающей выборкой</em>.<br>
- <strong>Обучение</strong>: наша задача использовать обучающую выборку, чтобы узнать, как выглядит каждый из классов. 
Мы называем этот этап <em>обучением классификатора</em> или <em>обучением модели</em>.<br>
- <strong>Оценка</strong>: в конце мы оцениваем качество классификатора. 
Для этого нужно задать вопрос о том, какие метки предскажет классификатор для нового набора изображений, которые он никогда раньше не видел. 
Затем мы сравниваем истинные метки этих изображений с теми, которые предсказал классификатор. 
Интуитивно мы надеемся, что многие прогнозы совпадут с истинными ответами. 
Данные, которые используются для оценки точности классификатора называются <em>тестовой выборкой</em>. </p>
<h4>Классификатор ближайшего соседа</h4>
<p>В качестве первого подхода мы используем так называемый <strong>классификатор ближайшего соседа</strong>. 
Этот классификатор не имеет ничего общего со свёрточными нейронными сетями и очень редко используется на практике. 
Однако он позволит нам получить представление о том, как решается задача классификации изображений.   </p>
<p><strong>Пример набора данных для классификации изображений: CIFAR-10</strong>.<br>
Одним из популярных наборов данных для классификации изображений является <a href="https://www.cs.toronto.edu/~kriz/cifar.html">набор данных CIFAR-10</a>. Этот набор данных состоит из 60 000 крошечных изображений высотой и шириной 32 пикселя. Каждое изображение относится к одному из 10 классов: самолет, автомобиль, птица и т. д. Эти 60 000 изображений разделены на обучающую выборку из 50 000 изображений и тестовую выборку из 10 000 изображений. 
На изображении ниже вы можете увидеть 10 случайных примеров изображений для каждого класса.    </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn.jpg"></p>
<p>Слева: примеры изображений из набора данных CIFAR-10.<br>
Справа: в первом столбце показаны несколько тестовых изображений.<br>
Рядом с каждым изображением мы видим 10 наиболее похожих "картинок" из обучающей выборки. </p>
<hr>
<p>Изначально, у нас есть обучающая выборка CIFAR-10 из 50 000 изображений (по 5000 изображений для каждой из 10 категорий). 
Мы хотим классифицировать оставшиеся 10 000. Классификатор ближайших соседей работает следующим образом. Берется тестовое изображение и сравается с каждым изображением из обучающей выборки. Будем считать, что метка тестового изображения будет такой же, как и у самого похожего на него изображения.  </p>
<p>На изображении выше и справа вы можете увидеть пример результата такой процедуры для 10 тестовых изображений. Обратите внимание, что только в 3 из 10 изображений являются элементами того же класса, в то время как в остальных 7 примерах возникает ошибка определения класса. Например, в 8-м ряду ближайшим обучающим изображением к голове лошади является красный автомобиль, предположительно из-за сильного чёрного фона. В результате этого, изображение лошади в данном случае будет ошибочно помечено как автомобиль. </p>
<p>Мы не уточнили, как именно мы сравниваем два изображения. 
Технически изображения представляют собой просто два блока (тензора) размером 32 x 32 x 3. 
Один из самых простых способов — сравнивать изображения попиксельно и суммировать все разности. 
Другими словами, если у вас есть два изображения, представленные в виде векторов $I_1$, $I_2$, разумным выбором для их сравнения может быть <strong>расстояние L1</strong>:   </p>
<p>$$
d_1 (I_1, I_2) = \sum_{p} \left| I^p_1 - I^p_2 \right|
$$   </p>
<p>Сумма берется по всем пикселям. 
Вот как выглядит эта процедура:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nneg.jpeg"></p>
<p>Пример использования попиксельных различий для сравнения двух изображений с помощью расстояния $L_1$ (в данном примере для одного цветового канала). 
Два изображения вычитаются поэлементно, а затем все различия суммируются до получения одного числа. 
Если два изображения идентичны, результат будет равен нулю. 
Но если изображения сильно отличаются, результат будет большим.   </p>
<hr>
<p>Давайте также посмотрим, как можно реализовать классификатор в коде. Сначала загрузим данные CIFAR-10 в память в виде четырех массивов: обучающие данные/метки и тестовые данные/метки. В приведенном ниже коде <code>Xtr</code> хранятся все изображения из обучающей выборки  (объем 50 000 x 32 x 32 x 3), а соответствующий одномерный массив <code>Ytr</code> (длиной 50 000) содержит обучающие метки (от 0 до 9):   </p>
<div class="code"><pre class="code literal-block"><span class="n">Xtr</span><span class="p">,</span> <span class="n">Ytr</span><span class="p">,</span> <span class="n">Xte</span><span class="p">,</span> <span class="n">Yte</span> <span class="o">=</span> <span class="n">load_CIFAR10</span><span class="p">(</span><span class="s1">'data/cifar10/'</span><span class="p">)</span> <span class="c1"># a magic function we provide</span>
<span class="c1"># flatten out all images to be one-dimensional </span>
<span class="n">Xtr_rows</span> <span class="o">=</span> <span class="n">Xtr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Xtr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Xtr_rows becomes 50000 x 3072</span>
<span class="n">Xte_rows</span> <span class="o">=</span> <span class="n">Xte</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Xte</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Xte_rows becomes 10000 x 3072 </span>
</pre></div>

<p>Теперь, когда все изображения вытянуты в ряд, мы можем обучить и оценить классификатор:   </p>
<div class="code"><pre class="code literal-block"><span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbor</span><span class="p">()</span> <span class="c1"># create a Nearest Neighbor classifier class</span>
<span class="n">nn</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">Xtr_rows</span><span class="p">,</span> <span class="n">Ytr</span><span class="p">)</span> <span class="c1"># train the classifier on the training images and labels</span>
<span class="n">Yte_predict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xte_rows</span><span class="p">)</span> <span class="c1"># predict labels on the test images</span>
<span class="c1"># and now print the classification accuracy, which is the average number</span>
<span class="c1"># of examples that are correctly predicted (i.e. label matches)</span>
<span class="nb">print</span> <span class="s1">'accuracy: </span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Yte_predict</span> <span class="o">==</span> <span class="n">Yte</span><span class="p">)</span> <span class="p">)</span>
</pre></div>

<p>Обратите внимание, что в качестве критерия оценки обычно используется метрика <strong>accuracy</strong>, 
Эта метрика измеряет долю правильных прогнозов в тестовой выборке. 
Обратите внимание, что все классификаторы, которые мы создадим, имеют общий интерфейс (API). 
У них есть метод <code>train(X,y)</code>, который принимает на вход данные и метки для обучения. 
Внутри класса должна быть построена своего рода модель, которая предсказывает метки на основе данных. 
Метод <code>predict(X)</code> принимает новые данные и предсказывает метки. </p>
<p>Пример реализации простого классификатора ближайшего соседа с расстоянием $L_1$, который реализует интерфейс классификатора:   </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">class</span><span class="w"> </span><span class="nc">NearestNeighbor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" X is N x D where each row is an example. Y is 1-dimension of size N</span>
<span class="sd">        The nearest neighbor classifier simply remembers all the training data """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtr</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ytr</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" X is N x D where each row is an example we wish to predict label for """</span>
        <span class="n">num_test</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># lets make sure that the output type matches the input type</span>
        <span class="n">Ypred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ytr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># loop over all test rows</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_test</span><span class="p">):</span>
        <span class="c1"># find the nearest training image to the i'th test image</span>
        <span class="c1"># using the L1 distance (sum of absolute value differences)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtr</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="c1"># get the index with smallest distance</span>
        <span class="n">Ypred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ytr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="c1"># predict the label of the nearest example</span>

        <span class="k">return</span> <span class="n">Ypred</span>
</pre></div>

<p>Если вы запустите этот код, то увидите, что классификатор достигает точности <strong>38,6%</strong> на тестовой выборке CIFAR-10. 
Это более впечатляющий результат, чем случайное угадывание (которое дало бы <strong>10%</strong> точности для 10 классов). 
Но он далёк от результатов человека, которые <a href="https://karpathy.github.io/2011/04/27/manually-classifying-cifar10/">оцениваются примерно в 94%</a>.  Еще лучший результат можно получить с помощью свёрточных нейронных сетей, которые достигают примерно 95% (см. таблицу соревнования <a href="https://www.kaggle.com/c/cifar-10/leaderboard">Kaggle</a> по CIFAR-10).  </p>
<p><strong>Выбор расстояния</strong>.  Существует множество других способов вычисления расстояний между векторами. Одним из распространённых вариантов может быть использование <strong>расстояния $L_2$</strong>, которое имеет геометрическую интерпретацию вычисления евклидова расстояния между двумя векторами. 
Формула для вычисления этого расстояния имеет вид:  </p>
<p>$$
d_2 (I_1, I_2) = \sqrt{\sum_{p} \left( I^p_1 - I^p_2 \right)^2}
$$  </p>
<p>Другими словами, мы вычисляем разницу по пикселям, как и раньше, но на этот раз возводим их в квадрат, складываем и, наконец, извлекаем квадратный корень. 
Используя приведенный выше код с numpy, нам нужно заменить только одну строку:   </p>
<div class="code"><pre class="code literal-block"><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtr</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>

<p>Обратите внимание на вычисление корня в функции <code>np.sqrt</code>. 
В практической реализации метода ближайшего соседа мы могли бы не использовать операцию извлечения квадратного корня, потому что он является <em>монотонной функцией</em>. 
То есть он масштабирует абсолютные значения расстояний, но сохраняет порядок. 
Поэтому с ним или без него, ближайшие соседи будут идентичны. 
Однако если применить классификатор ближайшего соседа к CIFAR-10 с $L_2$ расстоянием, получится всего <strong>35,4%</strong> точности. 
Это немного ниже, чем результат с расстоянием <strong>$L_1$</strong>.   </p>
<p><strong>Расстояние $L_1$ против $L_2$ .</strong>  Различие между этими двумя метриками в том, что расстояние <strong>$L_2$</strong> более строгое, чем расстояние <strong>$L_1$</strong>. Это значит, что если имеется множество небольших расхождений и всего одно большое, расстояние $L_2$ будет больше, чем $L_1$. Понятия расстояний <strong>$L_1$</strong> и  <strong>$L_2$</strong>  эквивалентно нормам, которые являются частными случаями <a href="https://planetmath.org/vectorpnorm">p-нормы</a>.   </p>
<h4>Классификатор k - ближайших соседей</h4>
<p>Когда мы хотим сделать более точный прогноз, нам не обязательно использовать только одну метку ближайшего изображения. Действительно, почти всегда можно добиться лучшего результата, используя так называемый <strong>классификатор k-ближайших соседей</strong>. 
Идея очень проста: вместо того, чтобы искать одно ближайшее изображение в обучающем наборе, мы найдём <strong>k</strong> ближайших изображений. 
Дальше мы сравним их и устроим "голосование" за метку тестового изображения. 
В частности, когда <em>k = 1</em>, мы получаем классификатор ближайшего соседа. 
Интуитивно понятно, что чем больше значений <strong>k</strong> мы возьмем, тем больше будет сглаживающий эффект. 
Это первый пример гиперпараметра, который делает классификатор более устойчивым к ошибкам:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/knn.jpeg"></p>
<p>Пример разницы между классификатором «один ближайший сосед» и классификатором «ближайшие 5 соседей» с использованием двумерных точек и 3 классов (красный, синий, зелёный). 
Цветные области показывают <strong>границы решений</strong>, создаваемые классификатором с использованием расстояния  $L_2$. 
Белые области показывают точки, которые классифицируются неоднозначно - голоса за классы равны как минимум для двух классов. 
Обратите внимание, что в случае классификатора 1-соседа ошибки создают небольшие островки вероятных неверных прогнозов. 
Например, зелёная точка в середине облака синих точек. 
В это же время классификатор 5-соседей сглаживает эти неровности, что, приводит к лучшему <strong>обобщению</strong> на тестовых данных. 
Также обратите внимание, что серые области на изображении 5-соседей вызваны равенством голосов ближайших соседей. 
Например, 2 соседа красные, следующие два соседа синие, последний сосед зелёный. </p>
<hr>
<p>На практике почти всегда используется метод k-ближайших соседей. 
Но какое значение k следует использовать? 
Давайте рассмотрим этот вопрос поподробнее.   </p>
<h4>Наборы данных и настройки гиперпараметров</h4>
<p>Классификатор k-ближайших соседей требует настройки параметра <em>k</em>. 
Интуитивно можно предположить, что существует число, которое подходит лучше всего. 
Кроме того, мы увидели, что существует множество различных функций расстояния, которые мы могли бы использовать: норма  <strong>$L_1$</strong>, норма <strong>$L_2$</strong>, а также множество других вариантов, которые мы даже не рассматривали (например, скалярные произведения). 
Эти варианты называются <strong>гиперпараметрами</strong>, и они очень часто используются при разработке многих алгоритмов машинного обучения, которые обучаются на данных. 
Часто не очевидно, какие значения/настройки следует выбрать.   </p>
<p>У вас может возникнуть соблазн предложить попробовать множество различных значений и посмотреть, что работает лучше всего. 
Это хорошая идея, и именно это мы и сделаем, но делать это нужно очень осторожно. 
В частности, <strong>мы не можем использовать тестовый набор данных для настройки гиперпараметров</strong>. 
Всякий раз, когда вы разрабатываете алгоритмы машинного обучения, вы должны относиться к тестовому набору данных как к очень ценному ресурсу, к которому, в идеале, не следует прикасаться до самого конца. 
В противном случае существует реальная опасность того, что вы настроите гиперпараметры так, чтобы они хорошо работали на тестовом наборе данных, но при развёртывании модели показывали значительное снижение производительности. 
На практике можно сказать, что произошло <strong>переобучение</strong> на тестовом наборе данных. 
С другой стороны, если вы настраиваете гиперпараметры на тестовом наборе данных, вы фактически используете тестовый набор данных в качестве обучающего. 
По этой причине точность, которую вы достигаете на нём, будет слишком оптимистичной по сравнению с тем, что будет наблюдаться на реальных данных при развёртывании модели. 
Но если вы используете тестовый набор данных только один раз в конце, он остаётся хорошим показателем для того, чтобы измерить степень <strong>обобщения</strong> вашего классификатора.   </p>
<p><strong>Итого: Оценивайте модель на тестовой выборке только один раз, в самом конце!</strong></p>
<p>Существует правильный способ настройки гиперпараметров, который никак не затрагивает тестовый набор данных. 
Идея состоит в том, чтобы разделить обучающую выборку на две части: немного меньший обучающий набор и то, что называется <strong>выборкой для валидации</strong>. 
Используя в качестве примера CIFAR-10, мы могли бы использовать 49 000 обучающих изображений для обучения и оставить 1000 для валидации. 
Этот набор данных по сути используется для настройки гиперпараметров.   </p>
<p>Вот как это может выглядеть в случае CIFAR-10:   </p>
<div class="code"><pre class="code literal-block"><span class="c1"># assume we have Xtr_rows, Ytr, Xte_rows, Yte as before</span>
<span class="c1"># recall Xtr_rows is 50,000 x 3072 matrix</span>
<span class="n">Xval_rows</span> <span class="o">=</span> <span class="n">Xtr_rows</span><span class="p">[:</span><span class="mi">1000</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># take first 1000 for validation</span>
<span class="n">Yval</span> <span class="o">=</span> <span class="n">Ytr</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">Xtr_rows</span> <span class="o">=</span> <span class="n">Xtr_rows</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,</span> <span class="p">:]</span> <span class="c1"># keep last 49,000 for train</span>
<span class="n">Ytr</span> <span class="o">=</span> <span class="n">Ytr</span><span class="p">[</span><span class="mi">1000</span><span class="p">:]</span>

<span class="c1"># find hyperparameters that work best on the validation set</span>
<span class="n">validation_accuracies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>

<span class="c1"># use a particular value of k and evaluation on validation data</span>
<span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbor</span><span class="p">()</span>
<span class="n">nn</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">Xtr_rows</span><span class="p">,</span> <span class="n">Ytr</span><span class="p">)</span>
<span class="c1"># here we assume a modified NearestNeighbor class that can take a k as input</span>
<span class="n">Yval_predict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xval_rows</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Yval_predict</span> <span class="o">==</span> <span class="n">Yval</span><span class="p">)</span>
<span class="nb">print</span> <span class="s1">'accuracy: </span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">acc</span><span class="p">,)</span>

<span class="c1"># keep track of what works on the validation set</span>
<span class="n">validation_accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">acc</span><span class="p">))</span>
</pre></div>

<p>По завершении этой процедуры построим график, который показывает, какие значения k работают лучше всего. 
Затем мы остановимся на этом значении и проведем оценку на реальном тестовом наборе данных.   </p>
<p>Разделите обучающую выборку на обучающую и валидационную. 
Используйте проверочную выборку для настройки всех гиперпараметров. 
В конце выполните один запуск на тестовой выборке и оцените производительность.</p>
<p><strong>Кросс-валидация</strong>. В случаях, когда размер обучающих данных (и, следовательно, проверочных данных) может быть небольшим, люди иногда используют более сложный метод настройки гиперпараметров, называемый <strong>кросс-валидацией</strong>.</p>
<p>Если вернуться к нашему предыдущему примеру, то идея заключается в том, что вместо произвольного выбора первых 1000 точек данных в качестве проверочного набора, а остальных — в качестве обучающего, можно получить более точную и менее зашумлённую оценку того, насколько хорошо работает определённое значение <strong>k</strong>, перебирая различные проверочные наборы и усредняя результаты по ним. Например, при 5-кратной перекрёстной проверке мы разделили бы обучающие данные на 5 равных частей, использовали 4 из них для обучения, а 1 — для проверки. Затем мы бы определили, какая из выборок является контрольной, оценили бы производительность и, наконец, усреднили бы производительность по разным выборкам.   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cvplot.png"><br>
Пример 5-кратного выполнения перекрестной проверки для параметра <strong>k</strong>. Для каждого значения <strong>k</strong> мы тренируемся на 4 сгибах и оцениваем на 5-м. Следовательно, для каждого k мы получаем 5 значений точности для проверочного сгиба (точность отражается на оси y, и каждый результат равен точке). Линия тренда проводится через среднее значение результатов для каждого <strong>k</strong>, а столбики ошибок указывают на стандартное отклонение. Обратите внимание, что в данном конкретном случае перекрёстная проверка показывает, что значение около <strong>k = 7</strong> лучше всего подходит для этого конкретного набора данных (соответствует пику на графике). Если бы мы использовали более 5 циклов, то могли бы ожидать более плавную (то есть менее шумную) кривую.   </p>
<hr>
<p>На практике люди предпочитают избегать перекрёстной проверки в пользу одного проверочного набора данных, поскольку перекрёстная проверка может быть ресурсозатратной. Обычно люди используют от <strong>50%</strong> до <strong>90%</strong> обучающих данных для обучения и остальную часть для проверки. Однако это зависит от множества факторов: например, если количество гиперпараметров велико, вы можете предпочесть использовать более крупные проверочные наборы данных. Если количество примеров в проверочном наборе невелико (возможно, всего несколько сотен или около того), безопаснее использовать перекрёстную проверку. На практике обычно используется 3-кратная, 5-кратная или 10-кратная перекрёстная проверка.     </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/crossval.jpeg"></p>
<p>Обычное разделение данных. Выделяются обучающий и тестовый наборы данных. Обучающий набор данных делится на части (например, здесь их 5). Части 1-4 становятся обучающим набором данных. Одна часть (например, часть 5, выделенная здесь жёлтым цветом) называется проверочной частью и используется для настройки гиперпараметров. Перекрёстная проверка идёт дальше и позволяет выбрать, какая часть будет проверочной, отдельно от частей 1-5. Это называется 5-кратной перекрёстной проверкой. В самом конце, когда модель обучена и определены все наилучшие гиперпараметры, модель один раз оценивается на тестовых данных (красный цвет). </p>
<hr>
<p><strong>Плюсы и минусы классификатора ближайших соседей.</strong>   </p>
<p>Стоит рассмотреть некоторые преимущества и недостатки классификатора «ближайший сосед». 
Очевидно, что одним из преимуществ является простота реализации и понимания. 
Кроме того, обучение классификатора не занимает много времени, поскольку всё, что требуется, — это хранить и, возможно, индексировать обучающие данные. 
Однако мы платим за это вычислительными затратами во время тестирования, поскольку для классификации тестового примера требуется сравнение с каждым обучающим примером. 
Это неправильно, поскольку на практике мы часто уделяем больше внимания эффективности во время тестирования, чем во время обучения. 
На самом деле, объемные нейронные сети, которые мы будем разрабатывать в этом классе, смещают этот компромисс в другую крайность: их обучение обходится очень дорого, но после завершения обучения классифицировать новый тестовый пример очень дёшево. 
Такой режим работы гораздо более желателен на практике.   </p>
<p>Кроме того, вычислительная сложность классификатора «ближайший сосед» является активной областью исследований, и существует несколько алгоритмов и библиотек <strong>приблизительного поиска ближайшего соседа</strong> (<em>ANN</em>), которые могут ускорить поиск ближайшего соседа в наборе данных (например, <a href="https://github.com/mariusmuja/flann">FLANN</a> ). 
Эти алгоритмы позволяют найти компромисс между точностью поиска ближайшего соседа и его пространственной/временной сложностью во время поиска и обычно полагаются на этап предварительной обработки/индексирования, который включает в себя построение KD-дерева или запуск алгоритма k-средних.  </p>
<p>В некоторых случаях классификатор ближайших соседей может быть хорошим выбором (особенно если данные имеют низкую размерность), но он редко подходит для использования в практических задачах классификации изображений. 
Одна из проблем заключается в том, что изображения — это объекты с высокой размерностью (то есть они часто содержат много пикселей), а расстояния в многомерных пространствах могут быть очень нелогичными. 
На изображении ниже показано, что сходство на основе пикселей, которое мы описали выше, сильно отличается от сходства с точки зрения восприятия:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/samenorm.png"></p>
<p>Расстояния на основе пикселей в многомерных данных (и особенно в изображениях) могут быть очень неинтуитивными. 
Исходное изображение (слева) и три других изображения рядом с ним, которые находятся на одинаковом расстоянии от него на основе пиксельного расстояния <strong>$L_2$</strong>. 
Очевидно, что пиксельное расстояние никак не соответствует перцептивному или семантическому сходству. </p>
<hr>
<p>Вот ещё одна визуализация, которая убедит вас в том, что использование разницы в пикселях для сравнения изображений недостаточно. Мы можем использовать метод визуализации под названием <a href="https://lvdmaaten.github.io/tsne/">t-SNE</a>, чтобы взять изображения CIFAR-10 и разместить их в двух измерениях так, чтобы их  парные (локальные) расстояния сохранялись наилучшим образом. В этой визуализации изображения, которые показаны рядом, считаются очень близкими в соответствии с расстоянием <strong>$L_2$</strong> по пикселям, которое мы разработали выше:    </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/pixels_embed_cifar10.jpg"></p>
<p>Изображения CIFAR-10, размещённые в двух измерениях с помощью <em>t-SNE</em>. Изображения, расположенные рядом на этом изображении, считаются близкими на основе пиксельного расстояния <strong>$L_2$</strong>. 
Обратите внимание на сильное влияние фона, а не семантических различий между классами. 
Нажмите <a href="https://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg">здесь</a>, чтобы увидеть увеличенную версию этой визуализации. </p>
<hr>
<p>В частности, обратите внимание, что изображения, расположенные друг рядом с другом, в большей степени зависят от общего цветового распределения изображений или типа фона, а не от их семантической идентичности. Например, собаку можно увидеть рядом с лягушкой, потому что они обе находятся на белом фоне. В идеале мы хотели бы, чтобы изображения всех 10 классов образовывали собственные кластеры, чтобы изображения одного класса находились рядом друг с другом независимо от нерелевантных характеристик и вариаций (например, фона). Однако, чтобы добиться этого, нам придётся выйти за рамки необработанных пикселей.   </p>
<h4>Применение kNN на практике</h4>
<p>Подводя итог: 
- Мы рассмотрели задачу <strong>классификации изображений</strong>, в которой нам даётся набор изображений, каждое из которых помечено одной категорией. Затем нас просят предсказать эти категории для нового набора тестовых изображений и оценить точность прогнозов.
- Мы представили простой классификатор под названием <em>«классификатор ближайших соседей»</em>.  Мы увидели, что существует множество гиперпараметров (например, значение k или тип расстояния, используемого для сравнения примеров), связанных с этим классификатором, и что не существует очевидного способа их выбора.
- Мы увидели, что правильный способ задать эти гиперпараметры — разделить обучающие данные на две части: <em>обучающий набор</em> и <em>поддельный тестовый набор</em>, который мы называем <strong>набором для проверки</strong>. Мы пробуем разные значения гиперпараметров и оставляем те, которые обеспечивают наилучшую производительность на наборе для проверки.
- Если вас беспокоит нехватка обучающих данных, мы обсудили процедуру под названием <strong>перекрёстная проверка</strong>, которая может помочь уменьшить погрешность при оценке наиболее эффективных гиперпараметров.
- Как только мы находим оптимальные гиперпараметры, мы фиксируем их и проводим одну <strong>оценку</strong> на реальном тестовом наборе данных.
- Мы увидели, что метод ближайшего соседа может обеспечить нам точность около <strong>40%</strong> на CIFAR-10. Он прост в реализации, но требует хранения всего обучающего набора данных, и его сложно оценивать на тестовых изображениях.
- В итоге мы увидели, что использование расстояний <strong>$L_1$</strong> или <strong>$L_2$</strong> по необработанным значениям пикселей нецелесообразно, поскольку эти расстояния сильнее коррелируют с фоном и цветовыми распределениями изображений, чем с их семантическим содержанием.   </p>
<p>На следующих лекциях мы приступим к решению этих задач и в конечном итоге придём к решениям, которые обеспечат точность <strong>90%</strong>, 
позволят полностью отказаться от обучающего набора данных после завершения обучения и позволят оценивать тестовые изображения менее чем за миллисекунду.   </p>
<p>Если вы хотите применить <em>kNN</em> на практике (не на изображениях), действуйте следующим образом:  </p>
<ol>
<li>
<p><strong>Предварительная обработка данных.</strong> 
Нормализуйте признаки в ваших данных (например, один пиксель на изображениях), чтобы среднее значение было равно нулю, а дисперсия — единице. 
Мы рассмотрим этот прием более подробно в следующих разделах. 
Сейчас нормализация данных не используется, потому что распределение яркости пикселей на изображениях достаточно однородны.  </p>
</li>
<li>
<p><strong>Рассмотрите возможность снижения размерности данных</strong>. 
На практике для снижения размерности используются следующие методы: </p>
</li>
<li>метод главных компонент <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">ссылка на вики-страницу</a>, <a href="http://cs229.stanford.edu/notes/cs229-notes10.pdf">ссылка на CS229</a>, <a href="https://web.archive.org/web/20150503165118/http://www.bigdataexaminer.com:80/understanding-dimensionality-reduction-principal-component-analysis-and-singular-value-decomposition/">ссылка на блог</a>, </li>
<li>метод независимых компонент <a href="https://en.wikipedia.org/wiki/Neighbourhood_components_analysis">ссылка на вики-страницу</a>, <a href="https://kevinzakka.github.io/2020/02/10/nca/">ссылка на блог</a> </li>
<li>
<p><a href="https://scikit-learn.org/stable/modules/random_projection.html">случайные проекции</a>.  </p>
</li>
<li>
<p><strong>Разделите обучающие данные случайным образом на обучающую и проверочную (валидационную) выборки.</strong> 
Как правило, в обучающую выборку попадает от <strong>70</strong> до <strong>90%</strong> данных. 
Этот параметр зависит от того, сколько у вас гиперпараметров и насколько сильно они влияют на результат. 
Если нужно оценить множество гиперпараметров, лучше использовать более крупную проверочную выборку для их эффективной оценки. 
Если вас беспокоит размер проверочной выборки, лучше разделить обучающие данные на части и выполнить кросс-валидацию. </p>
</li>
<li>
<p><strong>Обучите и оцените классификатор kNN на кросс-валидации.</strong> 
По возможности выполняйте кросс-валидацию для множества вариантов k и для разных типов расстояний (<strong>$L_1$ и $L_2$</strong> — хорошие кандидаты).<br>
Если вы можете позволить себе потратить больше времени на вычисления, всегда безопаснее использовать кросс-валидацию. 
Чем больше циклов обучения пройдет, тем лучше, но тем дороже с точки зрения вычислений.  </p>
</li>
<li>
<p><strong>Оцените задержку классификатора.</strong> 
Если ваш классификатор kNN работает слишком долгo, рассмотрите возможность использования библиотеки приближённых ближайших соседей. 
Например, библиотека <a href="https://github.com/mariusmuja/flann">FLANN</a> позволяет ускорить поиск за счёт некоторой потери точности.  </p>
</li>
<li>
<p><strong>Обратите внимание на гиперпараметры, которые дали наилучшие результаты.</strong> 
Возникает вопрос, следует ли использовать валидационный набор для финального обучения с наилучшими гиперпараметрами. 
Дело в том, что добавить данные для валидации в набор обучающих данных, оптимальные гиперпараметры могут измениться, поскольку размер данных увеличится. 
На практике лучше не использовать данные валидации в итоговом классификаторе и считать их потерянными при оценке гиперпараметров. </p>
</li>
<li>
<p><strong>Оцените наилучшую модель на тестовом наборе данных.</strong> 
Вычислите точность на тестовой выборке и объявите результат производительностью классификатора <em>kNN</em> на ваших данных.  </p>
</li>
</ol>
<h5>Дополнительные материалы</h5>
<p>Вот несколько дополнительных ссылок, которые могут быть интересными для дальнейшего чтения:<br>
- <a href="https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf">Несколько полезных фактов о машинном обучении</a>, особенно раздел 6, но рекомендуется к прочтению вся статья.<br>
- <a href="https://people.csail.mit.edu/torralba/shortCourseRLOC/index.html">Распознавание и изучение категорий объектов</a>, краткий курс по категоризации объектов на ICCV 2005.  </p>
                </div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="next"><a href="index-2.html" rel="next">Старые записи</a></li>
        </ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\\(","\\\)"] ],
        displayMath: [ ['$$','$$'], ["\\\[","\\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
