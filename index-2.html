<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="Заметки по machine learning, deep learning.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Заметки по ML, DL (2 страница со старыми записями) | Заметки по ML, DL</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="rss.xml">
<link rel="canonical" href="https://mldl.ru/index-2.html">
<link rel="prev" href="." type="text/html">
<link rel="next" href="index-1.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/image-classification/" class="u-url">Классификация изображений </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/andrei-labintsev/">Андрей Лабинцев</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/image-classification/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-14T08:00:00+03:00" itemprop="datePublished" title="2025-03-14 08:00">2025-03-14 08:00</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Классификация изображений</h2>
<p>В этой лекции мы познакомимся с проблемой классификации изображений. 
Решение проблемы заключается в подходе, основанном на большом объеме размеченных данных.   </p>
<p>Содержание:<br>
- <a href="posts/image-classification/#%D0%B2%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8E-%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B9">Введение в классификацию изображений</a><br>
  - <a href="posts/image-classification/#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B5%D0%B3%D0%BE-%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B0">Классификатор ближайшего соседа</a><br>
  - <a href="posts/image-classification/#%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80-k---%D0%B1%D0%BB%D0%B8%D0%B6%D0%B0%D0%B9%D1%88%D0%B8%D1%85-%D1%81%D0%BE%D1%81%D0%B5%D0%B4%D0%B5%D0%B9">Классификатор k - ближайших соседей</a> <br>
  - <a href="posts/image-classification/#%D0%BD%D0%B0%D0%B1%D0%BE%D1%80%D1%8B-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-%D0%B8-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B8-%D0%B3%D0%B8%D0%BF%D0%B5%D1%80%D0%BF%D0%B0%D1%80%D0%B0%D0%BC%D0%B5%D1%82%D1%80%D0%BE%D0%B2">Наборы данных для настройки гиперпараметров</a><br>
  - <a href="posts/image-classification/#%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-knn-%D0%BD%D0%B0-%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B5">Применение kNN на практике</a><br>
    - <a href="posts/image-classification/#%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BC%D0%B0%D1%82%D0%B5%D1%80%D0%B8%D0%B0%D0%BB%D1%8B">Дополнительные материалы</a> </p>
<h3>Введение в классификацию изображений</h3>
<p><strong>Мотивация</strong>. В этом разделе мы рассмотрим задачу классификации изображений. Задача заключается в присвоении входному изображению одной метки из фиксированного набора категорий. Это одна из основных задач компьютерного зрения, которая, несмотря на свою простоту, имеет множество практических применений. Более того, многие другие задачи компьютерного зрения (детекция объектов, сегментация) могут быть сведены к классификации изображений.   </p>
<p><strong>Пример</strong>. Например, на изображении ниже модель классификации изображений принимает одно изображение и присваивает вероятности четырём меткам: <em>{«кошка», «собака», «шляпа», «кружка»}</em>. Как показано на изображении, для компьютера изображение представляет собой один большой трёхмерный массив чисел. В этом примере изображение кошки имеет ширину <strong>248</strong> пикселей, высоту <strong>400</strong> пикселей и три цветовых канала: красный, зелёный, синий (или сокращённо <em>RGB</em>). Таким образом, изображение состоит из <strong>248 x 400 x 3</strong> чисел, или в общей сложности 297 600 чисел. Каждое число представляет собой целое число от 0 (чёрный) до 255 (белый). Наша задача — превратить эти четверть миллиона чисел в одну метку, например <em>«кошка»</em>.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/classify.png"></p>
<p>Задача классификации изображений состоит в том, чтобы предсказать одну метку для заданного изображения. Так же мы можем предсказать распределение вероятностей для всех меток, что отражает степень нашей уверенности в результате классификации.   Изображения представляют собой трёхмерные массивы целых чисел от 0 до 255 размером «ширина x высота x 3». Число 3 обозначает три цветовых канала: красный, зелёный и синий.  </p>
<hr>
<p><strong>Проблемы</strong>.  Поскольку задача распознавания визуального образа (например, кошки) относительно проста для человека, стоит рассмотреть связанные с ней проблемы с точки зрения алгоритма компьютерного зрения.<br>
Ниже мы приводим (неполный) список проблем, не забывая о том, что изображения представлены в виде трёхмерного массива значений яркости:<br>
- <strong>Изменение точки обзора</strong>. Один экземпляр объекта может быть ориентирован по-разному относительно камеры.<br>
- <strong>Изменение масштаба</strong>. Визуальные классы часто различаются по размеру (размеру в реальном мире, а не только по размеру на изображении).<br>
- <strong>Деформация</strong>. Многие интересующие нас объекты не являются твёрдыми телами и могут сильно деформироваться.<br>
- <strong>Окклюзия</strong>. Интересующие нас объекты могут быть частично скрыты. Иногда видна лишь небольшая часть объекта (всего несколько пикселей).<br>
- <strong>Условия освещения</strong>. Влияние освещения на пиксели очень велико.<br>
- <strong>Фоновый шум</strong>. Интересующие нас объекты могут сливаться с окружающей средой, что затрудняет их идентификацию.<br>
- <strong>Внутриклассовые различия</strong>. Классы, представляющие интерес, часто могут быть относительно обширными, например, <em>стулья</em>. 
Существует множество различных типов этих предметов, каждый из которых имеет отличный от других элементов класса внешний вид.    </p>
<p>Хорошая модель классификации изображений должна быть инвариантна к перекрёстному произведению всех этих вариаций, сохраняя при этом чувствительность к межклассовым вариациям.   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/challenges.jpeg"></p>
<hr>
<p><strong>Подход, основанный на данных</strong>. Как бы мы могли написать алгоритм, который сможет классифицировать изображения по отдельным категориям? В отличие от написания алгоритма, например, для сортировки списка чисел, не очевидно, как можно написать алгоритм для распознавания кошек на изображениях. Поэтому вместо того, чтобы пытаться описать каждую из интересующих нас категорий непосредственно в коде, мы воспользуемся подходом, похожим на обучение ребёнка. Мы предоставим компьютеру множество примеров, а затем используем алгоритм обучения, который связывает визуальное представление с меткой каждого класса. Этот подход предполагает, что у нас есть обучающий набор с размеченными изображениями. Вот пример того, как может выглядеть такой набор данных:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/trainset.jpg"></p>
<p>Пример обучающего набора для четырёх визуальных категорий. 
На практике у нас могут быть тысячи категорий и сотни тысяч изображений для каждой категории.  </p>
<hr>
<p><strong>Конвейер классификации изображений</strong>.  Мы увидели, что задача классификации изображений состоит в том, чтобы взять массив пикселей изображения и присвоить ему метку. 
Наш полный конвейер можно формализовать следующим образом:<br>
- <strong>Входные данные</strong>: состоят из набора <strong><em>N</em></strong> изображений, каждое из которых помечено одним из <strong><em>K</em></strong> различных классов. 
Эти данные называются <em>обучающей выборкой</em>.<br>
- <strong>Обучение</strong>: наша задача использовать обучающую выборку, чтобы узнать, как выглядит каждый из классов. 
Мы называем этот этап <em>обучением классификатора</em> или <em>обучением модели</em>.<br>
- <strong>Оценка</strong>: в конце мы оцениваем качество классификатора. 
Для этого нужно задать вопрос о том, какие метки предскажет классификатор для нового набора изображений, которые он никогда раньше не видел. 
Затем мы сравниваем истинные метки этих изображений с теми, которые предсказал классификатор. 
Интуитивно мы надеемся, что многие прогнозы совпадут с истинными ответами. 
Данные, которые используются для оценки точности классификатора называются <em>тестовой выборкой</em>. </p>
<h4>Классификатор ближайшего соседа</h4>
<p>В качестве первого подхода мы используем так называемый <strong>классификатор ближайшего соседа</strong>. 
Этот классификатор не имеет ничего общего со свёрточными нейронными сетями и очень редко используется на практике. 
Однако он позволит нам получить представление о том, как решается задача классификации изображений.   </p>
<p><strong>Пример набора данных для классификации изображений: CIFAR-10</strong>.<br>
Одним из популярных наборов данных для классификации изображений является <a href="https://www.cs.toronto.edu/~kriz/cifar.html">набор данных CIFAR-10</a>. Этот набор данных состоит из 60 000 крошечных изображений высотой и шириной 32 пикселя. Каждое изображение относится к одному из 10 классов: самолет, автомобиль, птица и т. д. Эти 60 000 изображений разделены на обучающую выборку из 50 000 изображений и тестовую выборку из 10 000 изображений. 
На изображении ниже вы можете увидеть 10 случайных примеров изображений для каждого класса.    </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn.jpg"></p>
<p>Слева: примеры изображений из набора данных CIFAR-10.<br>
Справа: в первом столбце показаны несколько тестовых изображений.<br>
Рядом с каждым изображением мы видим 10 наиболее похожих "картинок" из обучающей выборки. </p>
<hr>
<p>Изначально, у нас есть обучающая выборка CIFAR-10 из 50 000 изображений (по 5000 изображений для каждой из 10 категорий). 
Мы хотим классифицировать оставшиеся 10 000. Классификатор ближайших соседей работает следующим образом. Берется тестовое изображение и сравается с каждым изображением из обучающей выборки. Будем считать, что метка тестового изображения будет такой же, как и у самого похожего на него изображения.  </p>
<p>На изображении выше и справа вы можете увидеть пример результата такой процедуры для 10 тестовых изображений. Обратите внимание, что только в 3 из 10 изображений являются элементами того же класса, в то время как в остальных 7 примерах возникает ошибка определения класса. Например, в 8-м ряду ближайшим обучающим изображением к голове лошади является красный автомобиль, предположительно из-за сильного чёрного фона. В результате этого, изображение лошади в данном случае будет ошибочно помечено как автомобиль. </p>
<p>Мы не уточнили, как именно мы сравниваем два изображения. 
Технически изображения представляют собой просто два блока (тензора) размером 32 x 32 x 3. 
Один из самых простых способов — сравнивать изображения попиксельно и суммировать все разности. 
Другими словами, если у вас есть два изображения, представленные в виде векторов $I_1$, $I_2$, разумным выбором для их сравнения может быть <strong>расстояние L1</strong>:   </p>
<p>$$
d_1 (I_1, I_2) = \sum_{p} \left| I^p_1 - I^p_2 \right|
$$   </p>
<p>Сумма берется по всем пикселям. 
Вот как выглядит эта процедура:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nneg.jpeg"></p>
<p>Пример использования попиксельных различий для сравнения двух изображений с помощью расстояния $L_1$ (в данном примере для одного цветового канала). 
Два изображения вычитаются поэлементно, а затем все различия суммируются до получения одного числа. 
Если два изображения идентичны, результат будет равен нулю. 
Но если изображения сильно отличаются, результат будет большим.   </p>
<hr>
<p>Давайте также посмотрим, как можно реализовать классификатор в коде. Сначала загрузим данные CIFAR-10 в память в виде четырех массивов: обучающие данные/метки и тестовые данные/метки. В приведенном ниже коде <code>Xtr</code> хранятся все изображения из обучающей выборки  (объем 50 000 x 32 x 32 x 3), а соответствующий одномерный массив <code>Ytr</code> (длиной 50 000) содержит обучающие метки (от 0 до 9):   </p>
<div class="code"><pre class="code literal-block"><span class="n">Xtr</span><span class="p">,</span> <span class="n">Ytr</span><span class="p">,</span> <span class="n">Xte</span><span class="p">,</span> <span class="n">Yte</span> <span class="o">=</span> <span class="n">load_CIFAR10</span><span class="p">(</span><span class="s1">'data/cifar10/'</span><span class="p">)</span> <span class="c1"># a magic function we provide</span>
<span class="c1"># flatten out all images to be one-dimensional </span>
<span class="n">Xtr_rows</span> <span class="o">=</span> <span class="n">Xtr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Xtr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Xtr_rows becomes 50000 x 3072</span>
<span class="n">Xte_rows</span> <span class="o">=</span> <span class="n">Xte</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">Xte</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="c1"># Xte_rows becomes 10000 x 3072 </span>
</pre></div>

<p>Теперь, когда все изображения вытянуты в ряд, мы можем обучить и оценить классификатор:   </p>
<div class="code"><pre class="code literal-block"><span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbor</span><span class="p">()</span> <span class="c1"># create a Nearest Neighbor classifier class</span>
<span class="n">nn</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">Xtr_rows</span><span class="p">,</span> <span class="n">Ytr</span><span class="p">)</span> <span class="c1"># train the classifier on the training images and labels</span>
<span class="n">Yte_predict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xte_rows</span><span class="p">)</span> <span class="c1"># predict labels on the test images</span>
<span class="c1"># and now print the classification accuracy, which is the average number</span>
<span class="c1"># of examples that are correctly predicted (i.e. label matches)</span>
<span class="nb">print</span> <span class="s1">'accuracy: </span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Yte_predict</span> <span class="o">==</span> <span class="n">Yte</span><span class="p">)</span> <span class="p">)</span>
</pre></div>

<p>Обратите внимание, что в качестве критерия оценки обычно используется метрика <strong>accuracy</strong>, 
Эта метрика измеряет долю правильных прогнозов в тестовой выборке. 
Обратите внимание, что все классификаторы, которые мы создадим, имеют общий интерфейс (API). 
У них есть метод <code>train(X,y)</code>, который принимает на вход данные и метки для обучения. 
Внутри класса должна быть построена своего рода модель, которая предсказывает метки на основе данных. 
Метод <code>predict(X)</code> принимает новые данные и предсказывает метки. </p>
<p>Пример реализации простого классификатора ближайшего соседа с расстоянием $L_1$, который реализует интерфейс классификатора:   </p>
<div class="code"><pre class="code literal-block"><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="k">class</span><span class="w"> </span><span class="nc">NearestNeighbor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">train</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" X is N x D where each row is an example. Y is 1-dimension of size N</span>
<span class="sd">        The nearest neighbor classifier simply remembers all the training data """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Xtr</span> <span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ytr</span> <span class="o">=</span> <span class="n">y</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
<span class="w">    </span><span class="sd">""" X is N x D where each row is an example we wish to predict label for """</span>
        <span class="n">num_test</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># lets make sure that the output type matches the input type</span>
        <span class="n">Ypred</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_test</span><span class="p">,</span> <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ytr</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># loop over all test rows</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_test</span><span class="p">):</span>
        <span class="c1"># find the nearest training image to the i'th test image</span>
        <span class="c1"># using the L1 distance (sum of absolute value differences)</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtr</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span> <span class="c1"># get the index with smallest distance</span>
        <span class="n">Ypred</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ytr</span><span class="p">[</span><span class="n">min_index</span><span class="p">]</span> <span class="c1"># predict the label of the nearest example</span>

        <span class="k">return</span> <span class="n">Ypred</span>
</pre></div>

<p>Если вы запустите этот код, то увидите, что классификатор достигает точности <strong>38,6%</strong> на тестовой выборке CIFAR-10. 
Это более впечатляющий результат, чем случайное угадывание (которое дало бы <strong>10%</strong> точности для 10 классов). 
Но он далёк от результатов человека, которые <a href="https://karpathy.github.io/2011/04/27/manually-classifying-cifar10/">оцениваются примерно в 94%</a>.  Еще лучший результат можно получить с помощью свёрточных нейронных сетей, которые достигают примерно 95% (см. таблицу соревнования <a href="https://www.kaggle.com/c/cifar-10/leaderboard">Kaggle</a> по CIFAR-10).  </p>
<p><strong>Выбор расстояния</strong>.  Существует множество других способов вычисления расстояний между векторами. Одним из распространённых вариантов может быть использование <strong>расстояния $L_2$</strong>, которое имеет геометрическую интерпретацию вычисления евклидова расстояния между двумя векторами. 
Формула для вычисления этого расстояния имеет вид:  </p>
<p>$$
d_2 (I_1, I_2) = \sqrt{\sum_{p} \left( I^p_1 - I^p_2 \right)^2}
$$  </p>
<p>Другими словами, мы вычисляем разницу по пикселям, как и раньше, но на этот раз возводим их в квадрат, складываем и, наконец, извлекаем квадратный корень. 
Используя приведенный выше код с numpy, нам нужно заменить только одну строку:   </p>
<div class="code"><pre class="code literal-block"><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Xtr</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">,:]),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">))</span>
</pre></div>

<p>Обратите внимание на вычисление корня в функции <code>np.sqrt</code>. 
В практической реализации метода ближайшего соседа мы могли бы не использовать операцию извлечения квадратного корня, потому что он является <em>монотонной функцией</em>. 
То есть он масштабирует абсолютные значения расстояний, но сохраняет порядок. 
Поэтому с ним или без него, ближайшие соседи будут идентичны. 
Однако если применить классификатор ближайшего соседа к CIFAR-10 с $L_2$ расстоянием, получится всего <strong>35,4%</strong> точности. 
Это немного ниже, чем результат с расстоянием <strong>$L_1$</strong>.   </p>
<p><strong>Расстояние $L_1$ против $L_2$ .</strong>  Различие между этими двумя метриками в том, что расстояние <strong>$L_2$</strong> более строгое, чем расстояние <strong>$L_1$</strong>. Это значит, что если имеется множество небольших расхождений и всего одно большое, расстояние $L_2$ будет больше, чем $L_1$. Понятия расстояний <strong>$L_1$</strong> и  <strong>$L_2$</strong>  эквивалентно нормам, которые являются частными случаями <a href="https://planetmath.org/vectorpnorm">p-нормы</a>.   </p>
<h4>Классификатор k - ближайших соседей</h4>
<p>Когда мы хотим сделать более точный прогноз, нам не обязательно использовать только одну метку ближайшего изображения. Действительно, почти всегда можно добиться лучшего результата, используя так называемый <strong>классификатор k-ближайших соседей</strong>. 
Идея очень проста: вместо того, чтобы искать одно ближайшее изображение в обучающем наборе, мы найдём <strong>k</strong> ближайших изображений. 
Дальше мы сравним их и устроим "голосование" за метку тестового изображения. 
В частности, когда <em>k = 1</em>, мы получаем классификатор ближайшего соседа. 
Интуитивно понятно, что чем больше значений <strong>k</strong> мы возьмем, тем больше будет сглаживающий эффект. 
Это первый пример гиперпараметра, который делает классификатор более устойчивым к ошибкам:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/knn.jpeg"></p>
<p>Пример разницы между классификатором «один ближайший сосед» и классификатором «ближайшие 5 соседей» с использованием двумерных точек и 3 классов (красный, синий, зелёный). 
Цветные области показывают <strong>границы решений</strong>, создаваемые классификатором с использованием расстояния  $L_2$. 
Белые области показывают точки, которые классифицируются неоднозначно - голоса за классы равны как минимум для двух классов. 
Обратите внимание, что в случае классификатора 1-соседа ошибки создают небольшие островки вероятных неверных прогнозов. 
Например, зелёная точка в середине облака синих точек. 
В это же время классификатор 5-соседей сглаживает эти неровности, что, приводит к лучшему <strong>обобщению</strong> на тестовых данных. 
Также обратите внимание, что серые области на изображении 5-соседей вызваны равенством голосов ближайших соседей. 
Например, 2 соседа красные, следующие два соседа синие, последний сосед зелёный. </p>
<hr>
<p>На практике почти всегда используется метод k-ближайших соседей. 
Но какое значение k следует использовать? 
Давайте рассмотрим этот вопрос поподробнее.   </p>
<h4>Наборы данных и настройки гиперпараметров</h4>
<p>Классификатор k-ближайших соседей требует настройки параметра <em>k</em>. 
Интуитивно можно предположить, что существует число, которое подходит лучше всего. 
Кроме того, мы увидели, что существует множество различных функций расстояния, которые мы могли бы использовать: норма  <strong>$L_1$</strong>, норма <strong>$L_2$</strong>, а также множество других вариантов, которые мы даже не рассматривали (например, скалярные произведения). 
Эти варианты называются <strong>гиперпараметрами</strong>, и они очень часто используются при разработке многих алгоритмов машинного обучения, которые обучаются на данных. 
Часто не очевидно, какие значения/настройки следует выбрать.   </p>
<p>У вас может возникнуть соблазн предложить попробовать множество различных значений и посмотреть, что работает лучше всего. 
Это хорошая идея, и именно это мы и сделаем, но делать это нужно очень осторожно. 
В частности, <strong>мы не можем использовать тестовый набор данных для настройки гиперпараметров</strong>. 
Всякий раз, когда вы разрабатываете алгоритмы машинного обучения, вы должны относиться к тестовому набору данных как к очень ценному ресурсу, к которому, в идеале, не следует прикасаться до самого конца. 
В противном случае существует реальная опасность того, что вы настроите гиперпараметры так, чтобы они хорошо работали на тестовом наборе данных, но при развёртывании модели показывали значительное снижение производительности. 
На практике можно сказать, что произошло <strong>переобучение</strong> на тестовом наборе данных. 
С другой стороны, если вы настраиваете гиперпараметры на тестовом наборе данных, вы фактически используете тестовый набор данных в качестве обучающего. 
По этой причине точность, которую вы достигаете на нём, будет слишком оптимистичной по сравнению с тем, что будет наблюдаться на реальных данных при развёртывании модели. 
Но если вы используете тестовый набор данных только один раз в конце, он остаётся хорошим показателем для того, чтобы измерить степень <strong>обобщения</strong> вашего классификатора.   </p>
<p><strong>Итого: Оценивайте модель на тестовой выборке только один раз, в самом конце!</strong></p>
<p>Существует правильный способ настройки гиперпараметров, который никак не затрагивает тестовый набор данных. 
Идея состоит в том, чтобы разделить обучающую выборку на две части: немного меньший обучающий набор и то, что называется <strong>выборкой для валидации</strong>. 
Используя в качестве примера CIFAR-10, мы могли бы использовать 49 000 обучающих изображений для обучения и оставить 1000 для валидации. 
Этот набор данных по сути используется для настройки гиперпараметров.   </p>
<p>Вот как это может выглядеть в случае CIFAR-10:   </p>
<div class="code"><pre class="code literal-block"><span class="c1"># assume we have Xtr_rows, Ytr, Xte_rows, Yte as before</span>
<span class="c1"># recall Xtr_rows is 50,000 x 3072 matrix</span>
<span class="n">Xval_rows</span> <span class="o">=</span> <span class="n">Xtr_rows</span><span class="p">[:</span><span class="mi">1000</span><span class="p">,</span> <span class="p">:]</span> <span class="c1"># take first 1000 for validation</span>
<span class="n">Yval</span> <span class="o">=</span> <span class="n">Ytr</span><span class="p">[:</span><span class="mi">1000</span><span class="p">]</span>
<span class="n">Xtr_rows</span> <span class="o">=</span> <span class="n">Xtr_rows</span><span class="p">[</span><span class="mi">1000</span><span class="p">:,</span> <span class="p">:]</span> <span class="c1"># keep last 49,000 for train</span>
<span class="n">Ytr</span> <span class="o">=</span> <span class="n">Ytr</span><span class="p">[</span><span class="mi">1000</span><span class="p">:]</span>

<span class="c1"># find hyperparameters that work best on the validation set</span>
<span class="n">validation_accuracies</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">]:</span>

<span class="c1"># use a particular value of k and evaluation on validation data</span>
<span class="n">nn</span> <span class="o">=</span> <span class="n">NearestNeighbor</span><span class="p">()</span>
<span class="n">nn</span><span class="o">.</span><span class="n">train</span><span class="p">(</span><span class="n">Xtr_rows</span><span class="p">,</span> <span class="n">Ytr</span><span class="p">)</span>
<span class="c1"># here we assume a modified NearestNeighbor class that can take a k as input</span>
<span class="n">Yval_predict</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">Xval_rows</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Yval_predict</span> <span class="o">==</span> <span class="n">Yval</span><span class="p">)</span>
<span class="nb">print</span> <span class="s1">'accuracy: </span><span class="si">%f</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">acc</span><span class="p">,)</span>

<span class="c1"># keep track of what works on the validation set</span>
<span class="n">validation_accuracies</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">k</span><span class="p">,</span> <span class="n">acc</span><span class="p">))</span>
</pre></div>

<p>По завершении этой процедуры построим график, который показывает, какие значения k работают лучше всего. 
Затем мы остановимся на этом значении и проведем оценку на реальном тестовом наборе данных.   </p>
<p>Разделите обучающую выборку на обучающую и валидационную. 
Используйте проверочную выборку для настройки всех гиперпараметров. 
В конце выполните один запуск на тестовой выборке и оцените производительность.</p>
<p><strong>Кросс-валидация</strong>. В случаях, когда размер обучающих данных (и, следовательно, проверочных данных) может быть небольшим, люди иногда используют более сложный метод настройки гиперпараметров, называемый <strong>кросс-валидацией</strong>.</p>
<p>Если вернуться к нашему предыдущему примеру, то идея заключается в том, что вместо произвольного выбора первых 1000 точек данных в качестве проверочного набора, а остальных — в качестве обучающего, можно получить более точную и менее зашумлённую оценку того, насколько хорошо работает определённое значение <strong>k</strong>, перебирая различные проверочные наборы и усредняя результаты по ним. Например, при 5-кратной перекрёстной проверке мы разделили бы обучающие данные на 5 равных частей, использовали 4 из них для обучения, а 1 — для проверки. Затем мы бы определили, какая из выборок является контрольной, оценили бы производительность и, наконец, усреднили бы производительность по разным выборкам.   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cvplot.png"><br>
Пример 5-кратного выполнения перекрестной проверки для параметра <strong>k</strong>. Для каждого значения <strong>k</strong> мы тренируемся на 4 сгибах и оцениваем на 5-м. Следовательно, для каждого k мы получаем 5 значений точности для проверочного сгиба (точность отражается на оси y, и каждый результат равен точке). Линия тренда проводится через среднее значение результатов для каждого <strong>k</strong>, а столбики ошибок указывают на стандартное отклонение. Обратите внимание, что в данном конкретном случае перекрёстная проверка показывает, что значение около <strong>k = 7</strong> лучше всего подходит для этого конкретного набора данных (соответствует пику на графике). Если бы мы использовали более 5 циклов, то могли бы ожидать более плавную (то есть менее шумную) кривую.   </p>
<hr>
<p>На практике люди предпочитают избегать перекрёстной проверки в пользу одного проверочного набора данных, поскольку перекрёстная проверка может быть ресурсозатратной. Обычно люди используют от <strong>50%</strong> до <strong>90%</strong> обучающих данных для обучения и остальную часть для проверки. Однако это зависит от множества факторов: например, если количество гиперпараметров велико, вы можете предпочесть использовать более крупные проверочные наборы данных. Если количество примеров в проверочном наборе невелико (возможно, всего несколько сотен или около того), безопаснее использовать перекрёстную проверку. На практике обычно используется 3-кратная, 5-кратная или 10-кратная перекрёстная проверка.     </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/crossval.jpeg"></p>
<p>Обычное разделение данных. Выделяются обучающий и тестовый наборы данных. Обучающий набор данных делится на части (например, здесь их 5). Части 1-4 становятся обучающим набором данных. Одна часть (например, часть 5, выделенная здесь жёлтым цветом) называется проверочной частью и используется для настройки гиперпараметров. Перекрёстная проверка идёт дальше и позволяет выбрать, какая часть будет проверочной, отдельно от частей 1-5. Это называется 5-кратной перекрёстной проверкой. В самом конце, когда модель обучена и определены все наилучшие гиперпараметры, модель один раз оценивается на тестовых данных (красный цвет). </p>
<hr>
<p><strong>Плюсы и минусы классификатора ближайших соседей.</strong>   </p>
<p>Стоит рассмотреть некоторые преимущества и недостатки классификатора «ближайший сосед». 
Очевидно, что одним из преимуществ является простота реализации и понимания. 
Кроме того, обучение классификатора не занимает много времени, поскольку всё, что требуется, — это хранить и, возможно, индексировать обучающие данные. 
Однако мы платим за это вычислительными затратами во время тестирования, поскольку для классификации тестового примера требуется сравнение с каждым обучающим примером. 
Это неправильно, поскольку на практике мы часто уделяем больше внимания эффективности во время тестирования, чем во время обучения. 
На самом деле, объемные нейронные сети, которые мы будем разрабатывать в этом классе, смещают этот компромисс в другую крайность: их обучение обходится очень дорого, но после завершения обучения классифицировать новый тестовый пример очень дёшево. 
Такой режим работы гораздо более желателен на практике.   </p>
<p>Кроме того, вычислительная сложность классификатора «ближайший сосед» является активной областью исследований, и существует несколько алгоритмов и библиотек <strong>приблизительного поиска ближайшего соседа</strong> (<em>ANN</em>), которые могут ускорить поиск ближайшего соседа в наборе данных (например, <a href="https://github.com/mariusmuja/flann">FLANN</a> ). 
Эти алгоритмы позволяют найти компромисс между точностью поиска ближайшего соседа и его пространственной/временной сложностью во время поиска и обычно полагаются на этап предварительной обработки/индексирования, который включает в себя построение KD-дерева или запуск алгоритма k-средних.  </p>
<p>В некоторых случаях классификатор ближайших соседей может быть хорошим выбором (особенно если данные имеют низкую размерность), но он редко подходит для использования в практических задачах классификации изображений. 
Одна из проблем заключается в том, что изображения — это объекты с высокой размерностью (то есть они часто содержат много пикселей), а расстояния в многомерных пространствах могут быть очень нелогичными. 
На изображении ниже показано, что сходство на основе пикселей, которое мы описали выше, сильно отличается от сходства с точки зрения восприятия:   </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/samenorm.png"></p>
<p>Расстояния на основе пикселей в многомерных данных (и особенно в изображениях) могут быть очень неинтуитивными. 
Исходное изображение (слева) и три других изображения рядом с ним, которые находятся на одинаковом расстоянии от него на основе пиксельного расстояния <strong>$L_2$</strong>. 
Очевидно, что пиксельное расстояние никак не соответствует перцептивному или семантическому сходству. </p>
<hr>
<p>Вот ещё одна визуализация, которая убедит вас в том, что использование разницы в пикселях для сравнения изображений недостаточно. Мы можем использовать метод визуализации под названием <a href="https://lvdmaaten.github.io/tsne/">t-SNE</a>, чтобы взять изображения CIFAR-10 и разместить их в двух измерениях так, чтобы их  парные (локальные) расстояния сохранялись наилучшим образом. В этой визуализации изображения, которые показаны рядом, считаются очень близкими в соответствии с расстоянием <strong>$L_2$</strong> по пикселям, которое мы разработали выше:    </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/pixels_embed_cifar10.jpg"></p>
<p>Изображения CIFAR-10, размещённые в двух измерениях с помощью <em>t-SNE</em>. Изображения, расположенные рядом на этом изображении, считаются близкими на основе пиксельного расстояния <strong>$L_2$</strong>. 
Обратите внимание на сильное влияние фона, а не семантических различий между классами. 
Нажмите <a href="https://cs231n.github.io/assets/pixels_embed_cifar10_big.jpg">здесь</a>, чтобы увидеть увеличенную версию этой визуализации. </p>
<hr>
<p>В частности, обратите внимание, что изображения, расположенные друг рядом с другом, в большей степени зависят от общего цветового распределения изображений или типа фона, а не от их семантической идентичности. Например, собаку можно увидеть рядом с лягушкой, потому что они обе находятся на белом фоне. В идеале мы хотели бы, чтобы изображения всех 10 классов образовывали собственные кластеры, чтобы изображения одного класса находились рядом друг с другом независимо от нерелевантных характеристик и вариаций (например, фона). Однако, чтобы добиться этого, нам придётся выйти за рамки необработанных пикселей.   </p>
<h4>Применение kNN на практике</h4>
<p>Подводя итог: 
- Мы рассмотрели задачу <strong>классификации изображений</strong>, в которой нам даётся набор изображений, каждое из которых помечено одной категорией. Затем нас просят предсказать эти категории для нового набора тестовых изображений и оценить точность прогнозов.
- Мы представили простой классификатор под названием <em>«классификатор ближайших соседей»</em>.  Мы увидели, что существует множество гиперпараметров (например, значение k или тип расстояния, используемого для сравнения примеров), связанных с этим классификатором, и что не существует очевидного способа их выбора.
- Мы увидели, что правильный способ задать эти гиперпараметры — разделить обучающие данные на две части: <em>обучающий набор</em> и <em>поддельный тестовый набор</em>, который мы называем <strong>набором для проверки</strong>. Мы пробуем разные значения гиперпараметров и оставляем те, которые обеспечивают наилучшую производительность на наборе для проверки.
- Если вас беспокоит нехватка обучающих данных, мы обсудили процедуру под названием <strong>перекрёстная проверка</strong>, которая может помочь уменьшить погрешность при оценке наиболее эффективных гиперпараметров.
- Как только мы находим оптимальные гиперпараметры, мы фиксируем их и проводим одну <strong>оценку</strong> на реальном тестовом наборе данных.
- Мы увидели, что метод ближайшего соседа может обеспечить нам точность около <strong>40%</strong> на CIFAR-10. Он прост в реализации, но требует хранения всего обучающего набора данных, и его сложно оценивать на тестовых изображениях.
- В итоге мы увидели, что использование расстояний <strong>$L_1$</strong> или <strong>$L_2$</strong> по необработанным значениям пикселей нецелесообразно, поскольку эти расстояния сильнее коррелируют с фоном и цветовыми распределениями изображений, чем с их семантическим содержанием.   </p>
<p>На следующих лекциях мы приступим к решению этих задач и в конечном итоге придём к решениям, которые обеспечат точность <strong>90%</strong>, 
позволят полностью отказаться от обучающего набора данных после завершения обучения и позволят оценивать тестовые изображения менее чем за миллисекунду.   </p>
<p>Если вы хотите применить <em>kNN</em> на практике (не на изображениях), действуйте следующим образом:  </p>
<ol>
<li>
<p><strong>Предварительная обработка данных.</strong> 
Нормализуйте признаки в ваших данных (например, один пиксель на изображениях), чтобы среднее значение было равно нулю, а дисперсия — единице. 
Мы рассмотрим этот прием более подробно в следующих разделах. 
Сейчас нормализация данных не используется, потому что распределение яркости пикселей на изображениях достаточно однородны.  </p>
</li>
<li>
<p><strong>Рассмотрите возможность снижения размерности данных</strong>. 
На практике для снижения размерности используются следующие методы: </p>
</li>
<li>метод главных компонент <a href="https://en.wikipedia.org/wiki/Principal_component_analysis">ссылка на вики-страницу</a>, <a href="http://cs229.stanford.edu/notes/cs229-notes10.pdf">ссылка на CS229</a>, <a href="https://web.archive.org/web/20150503165118/http://www.bigdataexaminer.com:80/understanding-dimensionality-reduction-principal-component-analysis-and-singular-value-decomposition/">ссылка на блог</a>, </li>
<li>метод независимых компонент <a href="https://en.wikipedia.org/wiki/Neighbourhood_components_analysis">ссылка на вики-страницу</a>, <a href="https://kevinzakka.github.io/2020/02/10/nca/">ссылка на блог</a> </li>
<li>
<p><a href="https://scikit-learn.org/stable/modules/random_projection.html">случайные проекции</a>.  </p>
</li>
<li>
<p><strong>Разделите обучающие данные случайным образом на обучающую и проверочную (валидационную) выборки.</strong> 
Как правило, в обучающую выборку попадает от <strong>70</strong> до <strong>90%</strong> данных. 
Этот параметр зависит от того, сколько у вас гиперпараметров и насколько сильно они влияют на результат. 
Если нужно оценить множество гиперпараметров, лучше использовать более крупную проверочную выборку для их эффективной оценки. 
Если вас беспокоит размер проверочной выборки, лучше разделить обучающие данные на части и выполнить кросс-валидацию. </p>
</li>
<li>
<p><strong>Обучите и оцените классификатор kNN на кросс-валидации.</strong> 
По возможности выполняйте кросс-валидацию для множества вариантов k и для разных типов расстояний (<strong>$L_1$ и $L_2$</strong> — хорошие кандидаты).<br>
Если вы можете позволить себе потратить больше времени на вычисления, всегда безопаснее использовать кросс-валидацию. 
Чем больше циклов обучения пройдет, тем лучше, но тем дороже с точки зрения вычислений.  </p>
</li>
<li>
<p><strong>Оцените задержку классификатора.</strong> 
Если ваш классификатор kNN работает слишком долгo, рассмотрите возможность использования библиотеки приближённых ближайших соседей. 
Например, библиотека <a href="https://github.com/mariusmuja/flann">FLANN</a> позволяет ускорить поиск за счёт некоторой потери точности.  </p>
</li>
<li>
<p><strong>Обратите внимание на гиперпараметры, которые дали наилучшие результаты.</strong> 
Возникает вопрос, следует ли использовать валидационный набор для финального обучения с наилучшими гиперпараметрами. 
Дело в том, что добавить данные для валидации в набор обучающих данных, оптимальные гиперпараметры могут измениться, поскольку размер данных увеличится. 
На практике лучше не использовать данные валидации в итоговом классификаторе и считать их потерянными при оценке гиперпараметров. </p>
</li>
<li>
<p><strong>Оцените наилучшую модель на тестовом наборе данных.</strong> 
Вычислите точность на тестовой выборке и объявите результат производительностью классификатора <em>kNN</em> на ваших данных.  </p>
</li>
</ol>
<h5>Дополнительные материалы</h5>
<p>Вот несколько дополнительных ссылок, которые могут быть интересными для дальнейшего чтения:<br>
- <a href="https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf">Несколько полезных фактов о машинном обучении</a>, особенно раздел 6, но рекомендуется к прочтению вся статья.<br>
- <a href="https://people.csail.mit.edu/torralba/shortCourseRLOC/index.html">Распознавание и изучение категорий объектов</a>, краткий курс по категоризации объектов на ICCV 2005.  </p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/visualisation/" class="u-url">Понимание и визуализация</a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/andrei-labintsev/">Андрей Лабинцев</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/visualisation/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-13T19:42:16+03:00" itemprop="datePublished" title="2025-03-13 19:42">2025-03-13 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Понимание и визуализация</h2>
<p><strong><em>(эта страница в настоящее время находится в черновом варианте)</em></strong>  </p>
<p>В литературе было разработано несколько подходов к пониманию и визуализации сверточных сетей, отчасти в ответ на распространенную критику о том, что изученные признаки в нейронной сети не поддаются интерпретации. В этом разделе мы кратко рассмотрим некоторые из этих подходов и связанную с ними работу.</p>
<h3>Визуализация активаций и веса первого слоя</h3>
<p><strong>Активации слоев</strong>. Наиболее простой метод визуализации заключается в том, чтобы показать активации сети во время прямого прохода. В сетях <em>ReLU</em> активации обычно выглядят относительно неровными и плотными, но по мере обучения активации обычно становятся более редкими и локализованными. Одна из опасных ловушек, которую можно легко заметить с помощью этой визуализации, заключается в том, что некоторые карты активации могут быть равны нулю для множества различных входных данных, что может указывать на <em>мертвые фильтры</em> и может быть симптомом высокой скорости обучения.    </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnnvis/act1.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/cnnvis/act2.jpeg"><br>
Типичные активации на первом слое <em>CONV</em> (<strong>сверху</strong>) и на 5-м слое <em>CONV</em> (снизу) обученного <em>AlexNet</em> смотрят на изображение кошки. В каждом боксе отображается карта активации, соответствующая какому-либо фильтру. Обратите внимание, что активации редкие (большинство значений равны нулю, на этой визуализации показаны черным цветом) и в основном локальные.  </p>
<hr>
<p><strong>Фильтры Conv/FC</strong>. Вторая распространенная стратегия заключается в визуализации весов. Обычно они наиболее интерпретируемы на первом слое <em>CONV</em>, который смотрит непосредственно на необработанные пиксельные данные, но также можно показать веса фильтров в более глубоких слоях сети. Весовые коэффициенты полезны для визуализации, потому что хорошо обученные сети обычно отображают красивые и плавные фильтры без каких-либо зашумленных узоров. Зашумленные паттерны могут быть индикатором сети, которая не обучалась достаточно долго, или, возможно, очень низкой интенсивности регуляризации, которая могла привести к переобучению.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnnvis/filt1.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/cnnvis/filt2.jpeg"><br>
Типичные фильтры на первом слое <em>CONV</em> (<strong>сверху</strong>) и на 2-м слое <em>CONV</em> (<strong>снизу</strong>) обученного <em>AlexNet</em>. Обратите внимание, что веса первого слоя очень красивые и гладкие, что указывает на хорошо сходящуюся сеть. Функции цвета/оттенков серого сгруппированы, потому что <em>AlexNet</em> содержит два отдельных потока обработки, и очевидным следствием такой архитектуры является то, что один поток развивает высокочастотные элементы оттенков серого, а другой — низкочастотные цветовые функции. Веса 2-го слоя <em>CONV</em> не так легко интерпретируемы, но очевидно, что они все еще гладкие, хорошо сформированные и лишены зашумленных узоров.  </p>
<hr>
<h3>Получение изображений, которые максимально активируют нейрон</h3>
<p>Еще один метод визуализации заключается в том, чтобы взять большой набор изображений, пропустить их через сеть и отслеживать, какие изображения максимально активируют тот или иной нейрон. Затем мы можем визуализировать изображения, чтобы понять, что нейрон ищет в своем рецептивном поле. Одна из таких визуализаций (среди прочих) показана в <a href="http://arxiv.org/abs/1311.2524">статье Богатые иерархии функций для точного обнаружения объектов и семантической сегментации</a> Росса Гиршика и др.:<br><img alt="" src="https://cs231n.github.io/assets/cnnvis/pool5max.jpeg"><br>
Максимально активизирующие изображения для некоторых нейронов <em>POOL5</em> (5-й слой пула) AlexNet. Значения активации и рецептивное поле конкретного нейрона показаны белым цветом. (В частности, обратите внимание, что нейроны <em>POOL5</em> являются функцией относительно большой части входного изображения!) Можно видеть, что некоторые нейроны реагируют на верхнюю часть тела, текст или зеркальные блики.  </p>
<hr>
<p>Одна из проблем с этим подходом заключается в том, что нейроны <em>ReLU</em> не обязательно имеют какое-либо семантическое значение сами по себе. Скорее, более уместно думать о множественных нейронах <em>ReLU</em> как о базисных векторах некоторого пространства, представленного в виде участков изображения. Другими словами, визуализация показывает участки на краю облака представлений, вдоль (произвольных) осей, которые соответствуют весам фильтра. Это также можно увидеть по тому факту, что нейроны в ConvNet работают линейно над входным пространством, поэтому любое произвольное вращение этого пространства является запретным. Этот момент был далее аргументирован в книге Сегеди и др. <a href="http://arxiv.org/abs/1312.6199">«Интригующие свойства нейронных сетей»</a>, где они выполняют аналогичную визуализацию вдоль произвольных направлений в пространстве представления.</p>
<h3>Встраивание кодов с помощью t-SNE</h3>
<p>ConvNet можно интерпретировать как постепенное преобразование изображений в представление, в котором классы разделяются линейным классификатором. Мы можем получить приблизительное представление о топологии этого пространства, встроив изображения в два измерения таким образом, чтобы их низкоразмерное представление имело примерно равные расстояния, чем их высокомерное представление. Существует множество методов вложения, которые были разработаны с помощью интуиции вложения векторов высокой размерности в пространство низкой размерности с сохранением парных расстояний точек. Среди них <a href="http://lvdmaaten.github.io/tsne/">t-SNE</a> является одним из самых известных методов, который неизменно дает визуально приятные результаты.  </p>
<p>Чтобы произвести встраивание, мы можем взять набор изображений и использовать ConvNet для извлечения кодов <em>CNN</em> (например, в <em>AlexNet</em> 4096-мерный вектор прямо перед классификатором, и, что особенно важно, включая нелинейность <em>ReLU</em>). Затем мы можем подключить их к <em>t-SNE</em> и получить двумерный вектор для каждого изображения. Соответствующие изображения могут быть визуализированы в виде сетки:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnnvis/tsne.jpeg"><br>
Встраивание набора изображений в <em>t-SNE</em> на основе их кодов <em>CNN</em>. Изображения, которые находятся рядом друг с другом, также близки в пространстве репрезентации <em>CNN</em>, что подразумевает, что <em>CNN</em> «видит» их как очень похожие. Обратите внимание, что сходства чаще всего основаны на классах и семантике, а не на пикселях и цветах. Для получения более подробной информации о том, как была создана эта визуализация, связанный код, а также другие связанные визуализации в разных масштабах см. <a href="http://cs.stanford.edu/people/karpathy/cnnembed/">Визуализация кодов CNN в t-SNE</a>.  </p>
<hr>
<h3>Окклюзия частей изображения</h3>
<p>Предположим, что <em>ConvNet</em> классифицирует изображение как собаку. Как мы можем быть уверены, что он на самом деле улавливает собаку на изображении, а не какие-то контекстуальные подсказки на фоне или какой-то другой объект? Одним из способов исследования того, из какой части изображения исходит предсказание классификации, является построение графика вероятности интересующего класса (например, класса собаки) в зависимости от положения объекта-окклюдера. То есть, мы перебираем области изображения, устанавливаем участок изображения равным нулю и смотрим на вероятность класса. Мы можем визуализировать вероятность в виде двумерной тепловой карты. Этот подход был использован в книге Мэтью Цайлера <a href="http://arxiv.org/abs/1311.2901">«Визуализация и понимание сверточных сетей»</a>:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnnvis/occlude.jpeg"><br>
Три входных изображения (<strong>вверху</strong>). Обратите внимание, что окклюдерная область показана серым цветом. Когда мы проводим окклюдером по изображению, мы записываем вероятность правильного класса, а затем визуализируем его в виде тепловой карты (<em>показанной под каждым изображением</em>). Например, на крайнем левом изображении мы видим, что вероятность померанского шпица резко падает, когда окклюдер закрывает морду собаки, что дает нам некоторую степень уверенности в том, что морда собаки в первую очередь ответственна за высокий балл классификации. И наоборот, обнуление других частей изображения имеет относительно незначительное влияние.  </p>
<hr>
<h3>Визуализация градиента данных и его друзей</h3>
<p><strong>Градиент данных.|</strong></p>
<p><a href="http://arxiv.org/abs/1312.6034">Глубоко внутри сверточных сетей: визуализация моделей классификации изображений и карт заметности</a></p>
<p><strong>DeconvNet.</strong></p>
<p><a href="http://arxiv.org/abs/1311.2901">Визуализация и понимание сверточных сетей</a></p>
<p><strong>Управляемое обратное распространение.</strong></p>
<p><a href="http://arxiv.org/abs/1412.6806">Стремление к простоте: Всесвёрточная сеть</a></p>
<h3>Восстановление оригинальных изображений на основе кодов CNN</h3>
<p><a href="http://arxiv.org/abs/1412.0035">Понимание глубоких представлений изображений путем их инвертирования</a></p>
<h3>Какой объем пространственной информации сохраняется?</h3>
<p><a href="http://papers.nips.cc/paper/5420-do-convnets-learn-correspondence.pdf">Учатся ли ConvNet переписываться?</a> (Вкратце: да)</p>
<h3>Производительность построения графиков в зависимости от атрибутов изображения</h3>
<p><a href="http://arxiv.org/abs/1409.0575">ImageNet Wide Scale Visual Recognition Challenge</a></p>
<h3>Обман ConvNet</h3>
<p><a href="http://arxiv.org/abs/1412.6572">Объяснение и использование состязательных примеров</a></p>
<h3>Сравнение ConvNet с людьми-маркировщиками</h3>
<p><a href="http://karpathy.github.io/2014/09/02/what-i-learned-from-competing-against-a-convnet-on-imagenet/">Что я узнал, соревнуясь с ConvNet на ImageNet</a></p>
                </div>
            </article><article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/architecture/" class="u-url">Архитектура нейросетей </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        <a href="authors/andrei-labintsev/">Андрей Лабинцев</a>
                    </span></p>
            <p class="dateline">
            <a href="posts/architecture/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-12T19:42:16+03:00" itemprop="datePublished" title="2025-03-12 19:42">2025-03-12 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Архитектура нейросетей</h2>
<p>Содержание:
- <a href="posts/architecture/">Обзор архитектуры</a>
- <a href="posts/architecture/">Слои ConvNet</a>
    - <a href="posts/architecture/">Сверточный слой</a>
    - <a href="posts/architecture/">Слой пула</a>
    - <a href="posts/architecture/">Слой нормализации</a>
    - <a href="posts/architecture/">Полностью подключенный слой</a>
    - <a href="posts/architecture/">Преобразование полносвязных слоев в сверточные слои</a>
- <a href="posts/architecture/">Архитектуры ConvNet</a>
     - <a href="posts/architecture/">Узоры слоев</a>
     - <a href="posts/architecture/">Шаблоны для определения размеров слоев</a>
     - <a href="posts/architecture/">Тематические исследования </a> (LeNet / AlexNet / ZFNet / GoogLeNet / VGGNet)
     - <a href="posts/architecture/">Вычислительные соображения</a>
- <a href="posts/architecture/">Дополнительные материалы</a>  </p>
<h3>Сверточные нейронные сети (CNNs / ConvNets)</h3>
<p>Сверточные нейронные сети очень похожи на обычные нейронные сети из предыдущей главы: они состоят из нейронов, которые имеют обучаемые веса и смещения. Каждый нейрон получает некоторые входные данные, выполняет скалярное произведение и опционально следует за ним с нелинейностью. Вся сеть по-прежнему выражает одну дифференцируемую функцию оценки: от пикселей необработанного изображения на одном конце до оценок классов на другом. И у них по-прежнему есть функция потерь (например, <em>SVM/Softmax</em>) на последнем (полностью подключенном) слое, и все советы/рекомендации, которые мы разработали для обучения обычным нейронным сетям, по-прежнему применимы.  </p>
<p>Так что же меняется? Архитектуры <em>ConvNet</em> явно предполагают, что входные данные являются изображениями, что позволяет нам закодировать определенные свойства в архитектуре. Это делает функцию <strong>forward</strong> более эффективной для реализации и значительно сокращает количество параметров в сети.  </p>
<h4>Обзор архитектуры</h4>
<p><em>Напомним: обычные нейронные сети</em>. Как мы видели в предыдущей главе, нейронные сети получают входные данные (один вектор) и преобразуют их через серию <em>скрытых слоев</em>. Каждый скрытый слой состоит из набора нейронов, где каждый нейрон полностью связан со всеми нейронами предыдущего слоя, и где нейроны в одном слое функционируют совершенно независимо и не имеют общих связей. Последний полносвязный слой называется «выходным слоем» и в настройках классификации представляет собой баллы класса.  </p>
<p><em>Обычные нейронные сети плохо масштабируются до полных изображений</em>. В CIFAR-10 изображения имеют размер всего <strong>32x32x3</strong> (<strong>32</strong> в ширину, <strong>32</strong> в высоту, <strong>3</strong> цветных канала), поэтому один полностью связанный нейрон в первом скрытом слое обычной нейронной сети будет иметь <strong>32 * 32 * 3 = 3072</strong> веса. Это количество все еще кажется управляемым, но очевидно, что эта полностью связанная структура не масштабируется до более крупных изображений. Например, изображение более приличного размера, например, <strong>200x200x3</strong>, приведет к нейронам с весом <strong>200<em>200</em>3 = 120 000</strong>. Более того, мы почти наверняка хотели бы иметь несколько таких нейронов, чтобы параметры быстро складывались! Очевидно, что такая полная связность является расточительной, а огромное количество параметров быстро приведет к переобучению.  </p>
<p><em>3D объемы нейронов</em>. Сверточные нейронные сети используют тот факт, что входные данные состоят из изображений, и они ограничивают архитектуру более разумным образом. В частности, в отличие от обычной нейронной сети, слои ConvNet имеют нейроны, расположенные в трех измерениях: <strong>ширина, высота, глубина</strong>. (Обратите внимание, что слово <em>«глубина»</em> здесь относится к третьему измерению объема активации, а не к глубине полной нейронной сети, которая может относиться к общему количеству слоев в сети.) Например, входные изображения в CIFAR-10 представляют собой входной объем активаций, а объем имеет размеры <strong>32х32х3</strong> (ширина, высота, глубина соответственно). Как мы вскоре увидим, нейроны в слое будут соединены только с небольшой областью слоя перед ним, а не со всеми нейронами в полном объеме. Более того, итоговый выходной слой для CIFAR-10 будет иметь размеры <strong>1x1x10</strong>, так как к концу архитектуры <em>ConvNet</em> мы сведем полное изображение к единому вектору оценок классов, расположенных по размерности глубины. Вот визуализация:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/neural_net2.jpeg"></p>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/cnn.jpeg"></p>
<p><strong>Сверху</strong>: обычная 3-слойная нейронная сеть. <br><strong>Снизу</strong>: <em>ConvNet</em> располагает свои нейроны в трех измерениях (ширина, высота, глубина), как это визуализировано в одном из слоев. Каждый слой ConvNet преобразует входной объем <strong>3D</strong> в объем активации нейронов на выходе <strong>3D</strong>. В этом примере красный входной слой содержит изображение, поэтому его ширина и высота будут соответствовать размерам изображения, а глубина будет равна <strong>3</strong> (красный, зеленый, синий каналы).  </p>
<hr>
<blockquote>
<p>ConvNet состоит из слоев. У каждого слоя есть простой API: он преобразует <em>входной 3D-объем</em> в <em>выходной 3D-объем</em> с помощью некоторой дифференцируемой функции, которая может иметь или не иметь параметры.  </p>
</blockquote>
<h3>Слои, используемые для построения ConvNet</h3>
<p>Как мы уже описывали выше, простая <em>ConvNet</em> представляет собой последовательность слоев, и каждый слой <em>ConvNet</em> преобразует один объем активаций в другой с помощью дифференцируемой функции. Мы используем три основных типа слоев для построения архитектур <em>ConvNet</em>: <strong>сверточный слой, слой пула</strong> и <strong>полносвязный слой</strong> (точно так же, как это видно в обычных нейронных сетях). Мы сложим эти слои, чтобы сформировать полноценную <strong>архитектуру</strong> <em>ConvNet</em>.  </p>
<p><em>Пример архитектуры</em>: обзор. Мы рассмотрим это более подробно ниже, но простой <em>ConvNet</em> для классификации CIFAR-10 может иметь архитектуру <strong>[INPUT - CONV - RELU - POOL - FC]</strong>. Более подробно:</p>
<ul>
<li>INPUT <strong>[32x32x3]</strong> будет содержать исходные значения пикселей изображения, в данном случае изображение шириной <strong>32</strong>, высотой <strong>32</strong> и с тремя цветовыми каналами <strong>R,G,B</strong>.</li>
<li>Слой <strong>CONV</strong> будет вычислять выходные данные нейронов, которые соединены с локальными областями на входных данных, каждый из которых вычисляет скалярное произведение между их весами и небольшой областью, к которой они подключены во входном объеме. Это может привести к объему <strong>[32x32x12]</strong>, если мы решили использовать <strong>12</strong> фильтров.</li>
<li>Слой <strong>RELU</strong> будет применять функцию поэлементной активации, такую как <strong>max(0,х)</strong> с пороговым значением на нуле. При этом размер тома остается неизменным (<strong>[32x32x12]</strong>).</li>
<li>Слой <strong>POOL</strong> выполнит операцию понижения дискретизации вдоль пространственных измерений (ширина, высота), в результате чего будет получен объем, такой как <strong>[16x16x12]</strong>.</li>
<li>Уровень <strong>FC</strong> (т.е. полностью подключенный) будет вычислять баллы класса, в результате чего будет получен объем размера <strong>[1x1x10]</strong>, где каждое из <strong>10</strong> чисел соответствует баллу класса, например, среди <strong>10</strong> категорий CIFAR-10. Как и в случае с обычными нейронными сетями и как следует из названия, каждый нейрон в этом слое будет связан со всеми числами в предыдущем объеме.  </li>
</ul>
<p>Таким образом, <em>ConvNet</em> слой за слоем преобразуют исходное изображение от исходных значений пикселей до итоговых оценок класса. Обратите внимание, что некоторые слои содержат параметры, а другие нет. В частности, слои <em>CONV/FC</em> выполняют преобразования, которые являются функцией не только активации входного объема, но и параметров (весов и смещений нейронов). С другой стороны, слои <em>RELU/POOL</em> будут реализовывать фиксированную функцию. Параметры в слоях <em>CONV/FC</em> будут обучаться с помощью градиентного спуска, чтобы оценки классов, вычисляемые <em>ConvNet</em>, соответствовали меткам в обучающем наборе для каждого изображения.  </p>
<p>Вкратце:  </p>
<ul>
<li>Архитектура <em>ConvNet</em> в простейшем случае представляет собой список слоев, которые преобразуют объем изображения в выходной объем (например, содержат оценки классов)</li>
<li>Существует несколько различных типов слоев (например, <em>CONV/FC/RELU/POOL</em> на сегодняшний день являются наиболее популярными)</li>
<li>Каждый слой принимает входной <strong>3D-объем</strong> и преобразует его в выходной 3D-объем с помощью дифференцируемой функции</li>
<li>Каждый слой может иметь или не иметь параметры (например, у <em>CONV/FC</em> есть, у <em>RELU/POOL</em> нет)</li>
<li>Каждый слой может иметь или не иметь дополнительные гиперпараметры (например, у <em>CONV/FC/POOL</em> есть, у <em>RELU</em> нет)  </li>
</ul>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/convnet.jpeg"><br>
Активация примера архитектуры <em>ConvNet</em>. Начальный том хранит необработанные пиксели изображения (<strong>слева</strong>), а последний том хранит оценки класса (<strong>справа</strong>). Каждый объем активаций на пути обработки отображается в виде столбца. Так как визуализировать <strong>3D</strong>-объемы сложно, мы выкладываем срезы каждого тома в ряды. Последний объем слоя содержит баллы для каждого класса, но здесь мы визуализируем только отсортированные <strong>5</strong> лучших баллов и печатаем этикетки каждого из них. Полный <a href="http://cs231n.stanford.edu/">прототип веб-версии</a> приведен в шапке нашего веб-сайта. Архитектура, показанная здесь, представляет собой крошечную сеть <em>VGG</em>, о которой мы поговорим позже.  </p>
<hr>
<p><em>Теперь мы опишем отдельные слои и детали их гиперпараметров и связуемости</em>.    </p>
<h4>Сверточный слой</h4>
<p>Уровень <em>Conv</em> является основным строительным блоком сверточной сети, который выполняет большую часть тяжелой вычислительной работы.</p>
<p><strong>Обзор и интуиция без мозгов</strong>. Давайте сначала обсудим, что вычисляет слой <em>CONV</em> без аналогий между мозгом и нейронами. Параметры слоя <em>CONV</em> состоят из набора обучаемых фильтров. Каждый фильтр имеет небольшие пространственные размеры (по ширине и высоте), но простирается на всю глубину входного объема. Например, типичный фильтр на первом слое ConvNet может иметь размер <strong>5x5x3</strong> (<em>т. е. 5 пикселей в ширину и высоту, и 3, поскольку изображения имеют глубину 3, цветовые каналы</em>). Во время прямого прохода мы скользим (точнее, свертываем) каждый фильтр по ширине и высоте входного объема и вычисляем точечные произведения между входами фильтра и входом в любом положении. Когда мы перемещаем фильтр по ширине и высоте входного объема, мы создадим двумерную карту активации, которая дает ответы этого фильтра в каждом пространственном положении. Интуитивно сеть будет изучать фильтры, которые активируются, когда они видят какой-либо визуальный признак, такой как край определенной ориентации или пятно определенного цвета на первом слое, или, в конечном итоге, целые соты или узоры, похожие на колеса, на более высоких слоях сети. Теперь у нас будет целый набор фильтров в каждом слое <em>CONV</em> (например, <strong>12</strong> фильтров), и каждый из них создаст отдельную двухмерную карту активации. Мы наложим эти карты активации вдоль измерения глубины и получим выходной объем.  </p>
<p><strong>Взгляд на мозг</strong>. Если вы являетесь поклонником аналогий между мозгом и нейронами, то каждая запись в <em>3D</em>-объеме вывода также может быть интерпретирована как выход нейрона, который смотрит только на небольшую область на входе и разделяет параметры со всеми нейронами слева и справа в пространстве (поскольку все эти числа являются результатом применения одного и того же фильтра).  </p>
<p>Теперь мы обсудим детали соединений нейронов, их расположение в пространстве и схему совместного использования параметров.  </p>
<p><strong>Местная связность</strong>. Когда речь идет о многомерных входных данных, таких как изображения, как мы видели выше, нецелесообразно соединять нейроны со всеми нейронами в предыдущем томе. Вместо этого мы будем подключать каждый нейрон только к локальной области входного объема. Пространственная протяженность этой связности является гиперпараметром, называемым <strong>рецептивным полем</strong> нейрона (эквивалентно размеру фильтра). Степень связности вдоль оси глубины всегда равна глубине входного объема. Важно еще раз подчеркнуть эту асимметрию в том, как мы трактуем пространственные размеры (ширину и высоту) и размеры глубины: соединения локальны в <em>2D</em>-пространстве (по ширине и высоте), но всегда полны по всей глубине входного объема.  </p>
<p><em>Пример 1</em>. Например, предположим, что входной объем имеет размер <strong>[32x32x3]</strong> (например, изображение <em>RGB</em> CIFAR-10). Если рецептивное поле (или размер фильтра) равно <em>5x5</em>, то каждый нейрон в слое Conv будет иметь веса в области <strong>[5x5x3]</strong> во входном объеме, что в сумме составляет <strong>5x5x3 = 75</strong> весов (и параметр смещения <strong>+1</strong>). Обратите внимание, что степень связности вдоль оси глубины должна быть равна <strong>3</strong>, так как это глубина входного объема.</p>
<p><em>Пример 2</em>. Предположим, что входной объем имеет размер <strong>[16x16x20]</strong>. Затем, используя пример с размером рецептивного поля <strong>3x3</strong>, каждый нейрон в слое Conv теперь будет иметь в общей сложности <strong>3x3x20 = 180</strong> соединений с входным объемом. Обратите внимание, что, опять же, связность является локальной в <strong>2D</strong>-пространстве (например, <strong>3x3</strong>), но полной по глубине ввода (<strong>20</strong>).  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/depthcol.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/nn1/neuron_model.jpeg"><br><strong>Сверху</strong>: Пример входного объема красным цветом (например, изображение CIFAR-10 размером <strong>32x32x3</strong>) и пример объема нейронов в первом сверточном слое. Каждый нейрон в сверточном слое пространственно связан только с локальной областью во входном объеме, но на всю глубину (<em>т.е. со всеми цветовыми каналами</em>). Обратите внимание, что в глубине есть несколько нейронов (<strong>5</strong> в этом примере), все они смотрят на одну и ту же область на входе: линии, которые соединяют этот столбец из <strong>5</strong> нейронов, не представляют веса (т.е. эти <strong>5</strong> нейронов не имеют одинаковых весов, но они связаны с <strong>5</strong> разными фильтрами), они просто указывают на то, что эти нейроны связаны или смотрят на одно и то же рецептивное поле или область входного объема. <em>т.е. они имеют одно и то же рецептивное поле, но не одинаковые веса.</em> <strong>Снизу</strong>: Нейроны из главы «Нейронные сети» остаются неизменными: они по-прежнему вычисляют скалярное произведение своих весов с последующим нелинейным значением, но их связность теперь ограничена локальными пространственными данными.  </p>
<hr>
<p><strong>Пространственное расположение</strong>. Мы объяснили связь каждого нейрона в слое Conv с входным объемом, но мы еще не обсуждали, сколько нейронов находится в выходном объеме или как они организованы. Три гиперпараметра контролируют размер выходного объема: <strong>глубина, шаг</strong> и <strong>нулевое отступление</strong>. Мы обсудим их далее:<br>
- <em>Во-первых</em>, <strong>глубина</strong> выходного объема — это гиперпараметр: он соответствует количеству фильтров, которые мы хотели бы использовать, каждый из которых учится искать что-то свое во входных данных. Например, если первый сверточный слой принимает в качестве входных данных исходное изображение, то различные нейроны в измерении глубины могут активироваться в присутствии различных ориентированных краев или цветовых пятен. Мы будем называть набор нейронов, которые смотрят на одну и ту же область входных данных, <strong>столбцом глубины</strong> (некоторые люди также предпочитают термин <em>«волокно»</em>).
-<em> Во-вторых</em>, мы должны указать <em>шаг</em>, с которым мы перемещаем фильтр. Когда шаг равен 1, мы перемещаем фильтры по одному пикселю за раз. Когда шаг равен 2 (или редко 3 или более, хотя на практике это редкость), фильтры прыгают на 2 пикселя за раз, когда мы их перемещаем. Это позволит производить меньшие объемы выпуска в пространственном отношении.
-<em> Как мы скоро увидим</em>, иногда будет удобно заполнять входной объем нулями по границе. Размер этого <strong>нулевого отступа</strong> является гиперпараметром. Приятная особенность нулевого заполнения заключается в том, что он позволяет нам контролировать пространственный размер выходных объемов (чаще всего, как мы скоро увидим, мы будем использовать его для точного сохранения пространственного размера входного объема, чтобы ширина и высота входного и выходного объема были одинаковыми).  </p>
<p>Мы можем вычислить пространственный размер выходного объема как функцию от размера входного объема (<strong>W</strong>), размер рецептивного поля нейронов Conv слоя (<strong>F</strong>), шаг, с которым они наносятся (<strong>S</strong>) и количество использованного нулевого заполнения (<strong>P</strong>) на границе. Вы можете убедиться в том, что правильная формула для расчета количества нейронов «поместится» по формуле <strong>(W−F+2P)/S+1</strong>. Например, для входа <strong>7x7</strong> и фильтра <strong>3x3</strong> со stride 1 и pad 0 мы получим выход <strong>5x5</strong>. С помощью шага <strong>2</strong> мы получим выход <strong>3x3</strong>. Давайте также посмотрим еще на один графический пример:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/stride.jpeg"></p>
<p>Иллюстрация пространственного расположения. В этом примере есть только одно пространственное измерение (<strong>ось x</strong>), один нейрон с размером рецептивного поля <strong>F = 3</strong>, входной размер <strong>W = 5</strong> и нулевое заполнение <strong>P = 1</strong>. <strong>Сверху</strong>: Нейрон шагал по входу с шагом S = 1, давая на выходе размер <strong>(5 - 3 + 2)/1 + 1 = 5</strong>. <strong>Снизу</strong>: Нейрон использует шаг <strong>S = 2</strong>, давая выход размера <strong>(5 - 3 + 2)/2 + 1 = 3</strong>. Обратите внимание, что шаг <strong>S = 3</strong> не может быть использован, так как он не будет аккуратно помещаться по объему. С точки зрения уравнения, это можно определить, так как <strong>(5 - 3 + 2) = 4</strong> не делится на <strong>3</strong>.
Веса нейронов в этом примере <strong>[1,0,-1]</strong> (<em>показаны справа</em>), и их смещение равно нулю. Эти веса являются общими для всех желтых нейронов (см. общие параметры ниже).  </p>
<hr>
<p><em>Использование нулевой набивки</em>. В приведенном выше примере слева обратите внимание, что входной размер был равен <strong>5</strong>, а выходной размер был равен: также <strong>5</strong>. Это сработало так, потому что наши рецептивные поля были равны <strong>3</strong>, и мы использовали нулевую набивку <strong>1</strong>. Если бы не использовалось заполнение нуля, то выходной объем имел бы пространственную размерность только <strong>3</strong>, потому что именно столько нейронов «поместилось» бы на исходном входе. Как правило, установка нулевого заполнения равным <strong>P=(F−1)/2</strong>. Когда шаг <strong>S=1</strong> гарантирует, что входной и выходной объем будут иметь одинаковый пространственный размер. Очень часто используется нулевое заполнение таким образом, и мы обсудим все причины, когда будем говорить больше об архитектурах ConvNet.</p>
<p><em>Ограничения на шаг</em>. Обратите внимание, что гиперпараметры пространственного расположения имеют взаимные ограничения. Например, когда входные данные имеют размер <strong>W=10</strong>, нулевой отступ не используется <strong>P=0</strong>, а размер фильтра равен <strong>F=3</strong>, то использовать stride было бы невозможно <strong>S=2__с </strong>(W−F+2P)/S+1=(10−3+0)/2+1=4.5__, т.е. не целое число, указывающее на то, что нейроны не «помещаются» аккуратно и симметрично на входе. Таким образом, эта настройка гиперпараметров считается недопустимой, и библиотека ConvNet может выдать исключение или обнулить заполнение оставшейся части, чтобы она поместилась, или обрезать входные данные, чтобы она поместилась, или что-то еще. Как мы увидим в разделе Архитектуры <em>ConvNet</em>, правильный выбор размеров ConvNet, чтобы все размеры «отрабатывались», может стать настоящей головной болью, которую использование нулевого заполнения и некоторые рекомендации по проектированию значительно облегчат.</p>
<p><strong>Пример из жизни</strong>.  <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Архитектура Крижевского и др.</a>, которая выиграла конкурс ImageNet в 2012 году, принимала изображения размером [227x227x3]. На первом сверточном слое использовались нейроны с размером рецептивного поля <strong>F=11__шаг __S=4</strong> и без нулевой набивки <strong>P=0</strong>. Так как <strong>(227 - 11)/4 + 1 = 55</strong>, и так как слой Conv имел глубину <strong>K=96</strong>
, выходной объем слоя Conv имел размер <strong>[55x55x96]</strong>. Каждый из <strong>55x55x96</strong> нейронов в этом объеме был соединен с областью размера <strong>[11x11x3]</strong> во входном объеме. Более того, все 96 нейронов в каждой глубинной колонке подключены к одной и той же области входного канала <strong>[11x11x3]</strong>, но, конечно, с разными весами. В качестве забавного отступления, если вы прочитаете реальную статью, она утверждает, что входные изображения были <strong>224x224</strong>, что, безусловно, неверно, потому что <strong>(224 - 11)/4 + 1</strong> совершенно очевидно не является целым числом. Это сбило с толку многих людей в истории <em>ConvNets</em>, и мало что известно о том, что произошло. Мое собственное предположение заключается в том, что Алекс использовал нулевое заполнение из <strong>3</strong> дополнительных пикселей, о которых он не упоминает в статье.    </p>
<p><strong>Совместное использование параметров</strong>. Схема совместного использования параметров используется в сверточных слоях для управления количеством параметров. Используя приведенный выше пример из реальной жизни, мы видим, что в первом слое <em>Conv</em> <strong>55 * 55 * 96 = 290 400</strong> нейронов, и каждый из них имеет <strong>11 * 11 * 3 = 363</strong> веса и 1 смещение. В совокупности это дает <strong>290400 * 364 = 105 705 600 параметров</strong> только на первом уровне <em>ConvNet</em>. Понятно, что это очень большое число.  </p>
<p>Оказывается, что мы можем значительно сократить число параметров, если сделать одно разумное допущение: если один признак полезен для вычисления в некотором пространственном положении (<strong>x,y</strong>), то он также должен быть полезен для вычисления в другом положении (<strong>\(x_2, y_2\)</strong>). Другими словами, обозначив один двумерный срез глубины как <strong>срез глубины</strong> (например, объем размером <strong>[55x55x96]</strong> имеет <strong>96</strong> срезов глубины, каждый размером <strong>[55x55]</strong>), мы собираемся ограничить нейроны в каждом срезе глубины, чтобы они использовали одни и те же веса и смещение. При такой схеме распределения параметров первый слой Conv в нашем примере теперь будет иметь только 96 уникальных наборов весов (по одному для каждого среза глубины), что в сумме составит <strong>96 * 11 * 11 * 3 = 34 848 уникальных весов</strong>, или <strong>34 944</strong> параметра (<em>+96 смещений</em>). В качестве альтернативы, все <strong>55*55</strong> нейронов в каждом срезе глубины теперь будут использовать одни и те же параметры. На практике во время обратного распространения каждый нейрон в объеме будет вычислять градиент для своих весов, но эти градиенты будут суммироваться для каждого среза глубины и обновлять только один набор весов для каждого среза.  </p>
<p>Обратите внимание, что если все нейроны в одном срезе глубины используют один и тот же вектор весов, то прямой проход слоя <em>CONV</em> в каждом глубинном срезе может быть вычислен как <strong>свертка</strong> весов нейрона с входным объемом (отсюда и название: сверточный слой). Вот почему принято называть наборы весов <strong>фильтром</strong> (или <strong>ядром</strong>), который свертывается с входными данными.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/weights.jpeg"><br>
Примеры фильтров, изученных Крижским и др. Каждый из <strong>96</strong> показанных здесь фильтров имеет размер <strong>[11x11x3]</strong>, и каждый из них является общим для нейронов <strong>55 * 55</strong> в одном глубинном срезе. Обратите внимание, что предположение о совместном использовании параметров относительно разумно: если обнаружение горизонтального края важно в каком-то месте изображения, оно должно быть интуитивно полезным и в каком-то другом месте из-за трансляционно-инвариантной структуры изображений. Таким образом, нет необходимости заново учиться обнаруживать горизонтальный ребро в каждом из <strong>55 * 55</strong> различных мест в выходном объеме слоя <em>Conv</em>.  </p>
<hr>
<p>Обратите внимание, что иногда предположение о совместном использовании параметров может не иметь смысла. Это особенно верно в том случае, когда входные изображения в <em>ConvNet</em> имеют некоторую специфическую центрированную структуру, где мы должны ожидать, например, что на одной стороне изображения должны быть изучены совершенно разные функции, чем на другой. Одним из практических примеров является ситуация, когда входными данными являются лица, которые были центрированы на изображении. Можно ожидать, что различные особенности, специфичные для глаз или волос, могут (и должны) быть изучены в разных пространственных местах. В этом случае обычно ослабляют схему совместного использования параметров и вместо этого просто называют слой <strong>локально подключенным слоем</strong>.</p>
<p><strong>Нумерные примеры</strong>. Чтобы сделать обсуждение выше более конкретным, давайте выразим те же идеи, но в коде и на конкретном примере. Предположим, что входной объем представляет собой массив <strong>numpy</strong>. Тогда:<code>X</code>
- Колонка глубины (или волокно) в позиции будет активацией.<code>(x,y)</code> <code>X[x,y,:]</code>
- Глубинным срезом или, что эквивалентно<code>d</code>, картой активации на глубине были бы активации <code>X[:,:,d]</code> .  </p>
<p><em>Пример слоя conv</em>. Предположим, что входной объем имеет форму . Предположим далее, что мы не используем нулевое заполнение (<code>X</code> <code>X.shape: (11,11,4)</code><strong>P=0</strong>), что размер фильтра равен <strong>F=5</strong>, и что шаг является <strong>S=2</strong>. Таким образом, выходной объем будет иметь пространственный размер <strong>(11-5)/2+1 = 4</strong>, что дает объем с шириной и высотой 4. Карта активации в выходном объеме (назовем его ) будет выглядеть следующим образом (в этом примере вычисляются только некоторые элементы):<code>V</code>
- <code>V[0,0,0] = np.sum(X[:5,:5,:] * W0) + b0</code>
- <code>V[1,0,0] = np.sum(X[2:7,:5,:] * W0) + b0</code>
- <code>V[2,0,0] = np.sum(X[4:9,:5,:] * W0) + b0</code> 
- <code>V[3,0,0] = np.sum(X[6:11,:5,:] * W0) + b0</code>  </p>
<p>Помните, что в numpy приведенная выше операция обозначает поэлементное умножение между массивами. Заметьте также, что вектор веса — это вектор веса этого нейрона и смещение. Здесь предполагается, что он имеет форму , так как размер фильтра равен <strong>5</strong>, а глубина входного объема равна <strong>4</strong>. Обратите внимание, что в каждой точке мы вычисляем скалярное произведение, как это было показано ранее в обычных нейронных сетях. Кроме того, мы видим, что мы используем тот же вес и смещение (из-за совместного использования параметров), и где размеры по ширине увеличиваются с шагом <strong>2</strong> (<em>т.е. шаг</em>). Чтобы построить вторую карту активации в выходном объеме, у нас есть:<code>*</code> <code>W0</code> <code>b0</code> <code>W0</code> <code>W0.shape: (5,5,4)</code><br>
- <code>V[0,0,1] = np.sum(X[:5,:5,:] * W1) + b1</code>
- <code>V[1,0,1] = np.sum(X[2:7,:5,:] * W1) + b1</code>
- <code>V[2,0,1] = np.sum(X[4:9,:5,:] * W1) + b1</code>
- <code>V[3,0,1] = np.sum(X[6:11,:5,:] * W1) + b1</code>
- <code>V[0,1,1] = np.sum(X[:5,2:7,:] * W1) + b1</code> (пример перехода по y)
- <code>V[2,3,1] = np.sum(X[4:9,6:11,:] * W1) + b1</code> (<em>или по обоим</em>)  </p>
<p>где мы видим, что мы индексируем второе измерение глубины в <code>V</code> (по индексу <em>1</em>), потому что мы вычисляем вторую карту активации, и что теперь используется другой набор параметров (<code>W1</code>). В приведенном выше примере мы для краткости опускаем некоторые другие операции, которые <em>Conv Layer</em> выполнил бы для заполнения других частей выходного массива <code>V</code>. Кроме того, вспомните, что эти карты активации часто отслеживаются по элементам с помощью функции активации, такой как <strong>ReLU</strong>, но здесь это не показано.  </p>
<p><strong>Резюме</strong>. Подводя итог, можно сказать, что слой Conv:</p>
<ul>
<li>Принимает объем любого размера <strong>\(W_1 \times H_1 \times D_1\)</strong>
</li>
<li>Требуется четыре гиперпараметра:<ul>
<li>Количество фильтров <strong>K</strong>,</li>
<li>их пространственная протяженность <strong>F</strong>,</li>
<li>Шаг вперед <strong>S</strong>,</li>
<li>Величина нулевого отступа <strong>P</strong>.</li>
</ul>
</li>
<li>Производит объем большого размера <strong>\(W_2 \times H_2 \times D_2\)</strong> где:<ul>
<li><strong>W2=(W1−F+2P)/S+1</strong></li>
<li>
<strong>H2=(H1−F+2P)/S+1</strong> (т.е. ширина и высота вычисляются поровну по симметрии)</li>
<li><strong>D2=K</strong></li>
</ul>
</li>
<li>Благодаря совместному использованию параметров он вводит <strong>\(F \cdot F \cdot D_1\)</strong> веса на фильтр, итого <strong>\((F \cdot F \cdot D_1) \cdot K\)</strong> веса и <strong>K</strong> cмещений.</li>
<li>В выходном объеме метод <strong>d</strong>-я глубина среза (размера <strong>\(W_2 \times H_2\)</strong> ) является результатом выполнения валидной свертки <strong>d</strong>-й фильтр по входной громкости с шагом <strong>S</strong>, а затем сместить на <strong>d</strong>-ое смещение.  </li>
</ul>
<p>Общая настройка гиперпараметров выглядит следующим образом: <strong>F=3,S=1,P=1</strong>. Тем не менее, существуют общие условности и эмпирические правила, которые мотивируют эти гиперпараметры. Смотрите раздел <a href="https://cs231n.github.io/convolutional-networks/#architectures">Архитектуры ConvNet</a> ниже.</p>
<p><strong>Демо свертки</strong>. Ниже приведена бегущая демонстрация слоя CONV. Поскольку <strong>3D</strong>-объемы трудно визуализировать, все объемы (входной объем (синий), весовой объем (красный), выходной объем (зеленый)) визуализируются с каждым срезом глубины, уложенным в ряды. Входной объем имеет размер  <strong>\(W_1 = 5, H_1 = 5, D_1 = 3\)</strong>, а параметры слоя <em>CONV</em> равны <strong>\(K = 2, F = 3, S = 2, P = 1\)</strong>. То есть у нас есть два фильтра размера <strong>3×3</strong>, и наносятся они с шагом <strong>2</strong>. Следовательно, размер выходного объема имеет пространственный размер <strong>(5 - 3 + 2)/2 + 1 = 3</strong>. Кроме того, обратите внимание, что отступ <strong>P=1</strong> применяется к входному объему, при этом внешняя граница входного объема обнуляется. На приведенной ниже визуализации перебираются выходные активации (<em>зеленый</em>) и показано, что каждый элемент вычисляется путем поэлементного умножения выделенных входных данных (<em>синий</em>) на фильтр (<em>красный</em>), суммирования его и последующего смещения результата.  </p>
<hr>
<p><img alt="" src="posts/architecture/">
- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- </p>
<div class="fig figcenter fighighlight">
  <iframe src="assets/conv-demo/index.html" width="100%" height="700px;" style="border:none;"></iframe>
  <div class="figcaption"></div>
</div>
<ul>
<li>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  </li>
</ul>
<hr>
<p><strong>Реализация в виде умножения матриц</strong>. Обратите внимание, что операция свертки по сути выполняет скалярное произведение между фильтрами и локальными областями входных данных. Общий шаблон реализации слоя <em>CONV</em> заключается в том, чтобы воспользоваться этим фактом и сформулировать прямой проход сверточного слоя в виде умножения одной большой матрицы следующим образом:
_ Локальные регионы на входном изображении растягиваются в столбцы с помощью операции, обычно называемой <strong>im2col</strong>. Например, если входной параметр имеет размер <strong>[227x227x3]</strong> и он должен быть свернут с помощью фильтров <strong>11x11x3</strong> на шаге <strong>4</strong>, то мы возьмем <strong>[11x11x3]</strong> блоков пикселей на входе и растянем каждый блок в вектор-столбец размером <strong>11<em>11</em>3 = 363</strong>. Повторение этого процесса на входе с шагом <strong>4</strong> дает <strong>(227-11)/4+1 = 55</strong> позиций как по ширине, так и по высоте, что приводит к выходной матрице <em>im2col</em> размера <strong>[363 x 3025</strong>], где каждый столбец представляет собой растянутое восприимчивое поле, и всего их <strong>55 x 55 = 3025</strong>. Обратите внимание, что поскольку рецептивные поля перекрываются, каждое число во входном объеме может дублироваться в нескольких отдельных столбцах.<code>X_col</code>
- Грузы слоя <em>CONV</em> аналогичным образом растягиваются в ряды. Например, если имеется <strong>96</strong> фильтров размера <strong>[11x11x3]</strong>, то получится матрица размера <strong>[96 x 363]</strong>. <code>W_row</code>
- Результат свертки теперь эквивалентен выполнению одного умножения большой матрицы , которое вычисляет скалярное произведение между каждым фильтром и каждым местоположением восприимчивого поля. В нашем примере результатом этой операции будет <strong>[96 x 3025]</strong>, что дает выходные данные скалярного произведения каждого фильтра в каждом месте.<code>np.dot(W_row, X_col)</code>
- В конечном итоге результат должен быть возвращен к его надлежащему выходному размеру <strong>[55x55x96]</strong>.  </p>
<p>У этого подхода есть недостаток, заключающийся в том, что он может использовать много памяти, так как некоторые значения во входном объеме многократно реплицируются в . Тем не менее, преимущество заключается в том, что существует множество очень эффективных реализаций матричного умножения, которыми мы можем воспользоваться (например, в широко используемом <a href="http://www.netlib.org/blas/">BLAS</a> <em>API</em>). Более того, та же идея <em>im2col</em> может быть повторно использована для выполнения операции объединения, о которой мы поговорим далее.<code>X_col</code>  </p>
<p><strong>Обратное распространение</strong>. Обратный проход для операции свертки (как для данных, так и для весов) также является сверткой (но с пространственно перевернутыми фильтрами). Это легко вывести в одномерном случае с помощью примера с игрушкой (пока не раскрывается).</p>
<p><strong>Свертка 1х1</strong>. В качестве отступления, в нескольких работах используются свертки <strong>1x1</strong>, впервые исследованные <a href="http://arxiv.org/abs/1312.4400">Network in Network</a>. Некоторые люди поначалу путаются, видя свертки <strong>1x1</strong>, особенно когда они исходят из фона обработки сигналов. Обычно сигналы двумерны, поэтому свертки 1x1 не имеют смысла (это просто поточечное масштабирование). Однако в <em>ConvNet</em> это не так, потому что необходимо помнить, что мы работаем с трехмерными объемами и что фильтры всегда распространяются на всю глубину входного объема. Например, если входные данные равны <strong>[32x32x3]</strong>, то выполнение сверток <em>1x1</em> фактически будет выполнением трехмерных скалярных произведений (поскольку глубина входных данных равна <strong>3</strong> каналам).  </p>
<p><strong>Расширенные извилины</strong>. Недавняя разработка (<a href="https://arxiv.org/abs/1511.07122">см., например, статью Фишера Ю. и Владлена Колтуна</a>) заключается в введении еще одного гиперпараметра в слой <em>CONV</em>, называемого <em>дилатацией</em>. До сих пор мы обсуждали только непрерывные фильтры <em>CONV</em>. Тем не менее, можно иметь фильтры, которые имеют промежутки между каждой клеткой, называемые расширением. Например, в одном измерении фильтр размера <strong>3</strong> будет вычислять на входных данных следующее: . Это расширение до <strong>0</strong>. Для расширения <strong>1</strong> фильтр вместо этого будет вычислять ; Другими словами, между заявками есть разрыв в <strong>1</strong>. Это может быть очень полезно в некоторых настройках для использования в сочетании с фильтрами <strong>0-расширения</strong>, поскольку это позволяет объединять пространственную информацию по входным данным гораздо более агрессивно с меньшим количеством слоев. Например, если вы наложите два слоя <em>CONV</em> <strong>3x3</strong> друг на друга, то вы можете убедить себя, что нейроны на втором слое являются функцией участка входного сигнала <strong>5x5</strong> (мы бы сказали, что <em>эффективное рецептивное поле</em> этих нейронов равно <strong>5x5</strong>). Если мы будем использовать расширенные извилины, то это эффективное рецептивное поле будет расти гораздо быстрее.<code>w</code> <code>x</code> <code>w[0]*x[0] + w[1]*x[1] + w[2]*x[2]w[0]*x[0] + w[1]*x[2] + w[2]*x[4]</code>  </p>
<h4>Слой пула</h4>
<p>В архитектуре <em>ConvNet</em> обычно периодически вставляется слой Pooling между последовательными слоями <em>Conv</em>. Его функция состоит в том, чтобы постепенно уменьшать пространственный размер представления для уменьшения количества параметров и вычислений в сети и, следовательно, также контролировать переобучение. Слой пулинга работает независимо на каждом срезе глубины входных данных и изменяет его пространственный размер с помощью операции <strong>MAX</strong>. Наиболее распространенной формой является пулинговый слой с фильтрами размером <strong>2x2</strong>, применяемыми с шагом <strong>2</strong> вниздискретизации каждого глубинного среза на входе на <strong>2</strong> по ширине и высоте, отбрасывая <strong>75%</strong> активаций. Каждая операция <strong>MAX</strong> в этом случае будет принимать максимум более 4 чисел (маленькая область <strong>2x2</strong> в некотором глубинном срезе). Размер глубины остается неизменным. В более общем смысле, пуловый слой:
- Принимает объем любого размера <strong>W1×H1×D1</strong>
- Требуется два гиперпараметра:
    - их пространственная протяженность <strong>F</strong>,
    - Шаг вперед <strong>S</strong>,
- Производит объем большого размера <strong>\(W_2 \times H_2 \times D_2\)</strong> где:
    - <strong>\(W_2 = (W_1 - F)/S + 1\)</strong>
    - <strong>\(H_2 = (H_1 - F)/S + 1\)</strong>
    - <strong>\(D_2 = D_1\)</strong>
- Вводит нулевые параметры, так как вычисляет фиксированную функцию входных данных
- Для слоев <em>Pooling</em> заполнение входных данных не является обычным способом с использованием нулевого отступа.  </p>
<p>Стоит отметить, что на практике встречаются только два распространенных варианта максимального слоя пула: Слой пулинга с <strong>F=3,S=2</strong> (также называемое перекрывающимся пулом) и чаще <strong>F=2,S=2</strong>. Объединение размеров с большими рецептивными полями слишком разрушительно.  </p>
<p><strong>Общий пул</strong>. В дополнение к максимальному объединению, единицы объединения могут выполнять и другие функции, такие как <em>усредненное объединение</em> или даже <em>объединение по L2-норме</em>. Исторически часто использовалось среднее объединение, но в последнее время оно вышло из моды по сравнению с операцией максимального объединения, которая, как было показано, работает лучше на практике.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/pool.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/cnn/maxpool.jpeg"><br>
Пулинг слоя понижает дискретизацию объема пространственно, независимо в каждом глубинном срезе входного объема. <strong>Сверху</strong>: В этом примере входной объем размера <strong>[224x224x64]</strong> объединяется с фильтром размера 2, шаг 2 в выходной объем размера <strong>[112x112x64]</strong>. Обратите внимание, что глубина объема сохраняется. <strong>Снизу</strong>: Наиболее распространенной операцией понижения дискретизации является max, что приводит к <strong>максимальному объединению</strong>, показанному здесь с шагом <strong>2</strong>. То есть, каждый макс берется над 4 числами (маленький квадратик <strong>2х2</strong>).  </p>
<hr>
<p><strong>Обратное распространение</strong>. Вспомните из главы об обратном распространении, что обратный проход для операции <strong>max(x, y)</strong> имеет простую интерпретацию как только маршрутизацию градиента на вход, который имел наибольшее значение в прямом проходе. Следовательно, во время прямого прохождения пулового слоя обычно отслеживают индекс максимальной активации (иногда также называемый <em>переключателями</em>), чтобы градиентная маршрутизация была эффективной во время обратного распространения.</p>
<p><strong>Избавление от пулов</strong>. Многим людям не нравится операция по объединению, и они думают, что мы можем обойтись без нее. Например, <a href="http://arxiv.org/abs/1412.6806">Pursuit for Simplicity: The All Convolutional Net</a> предлагает отказаться от пулового слоя в пользу архитектуры, состоящей только из повторяющихся слоев <em>CONV</em>. Чтобы уменьшить размер представления, они предлагают время от времени использовать больший шаг в слое <em>CONV</em>. Также было обнаружено, что отказ от слоев пула важен для обучения хороших генеративных моделей, таких как вариационные автоэнкодеры (<em>VAE</em>) или генеративно-состязательные сети (<em>GAN</em>). Вполне вероятно, что в будущих архитектурах будет очень мало или вообще не будет слоев пула.  </p>
<h4>Слой нормализации</h4>
<p>Многие типы уровней нормализации были предложены для использования в архитектурах <em>ConvNet</em>, иногда с намерением реализовать схемы торможения, наблюдаемые в биологическом мозге. Однако с тех пор эти слои вышли из моды, потому что на практике их вклад был минимальным, если вообще был. О различных типах нормализации см. обсуждение в <a href="http://code.google.com/p/cuda-convnet/wiki/LayerParams#Local_response_normalization_layer_(same_map)">API библиотеки cuda-convnet</a> Алекса Крижевского.  </p>
<h4>Полносвязный слой</h4>
<p>Нейроны в полностью связном слое имеют полные связи со всеми активациями в предыдущем слое, как это видно в обычных нейронных сетях. Таким образом, их активации могут быть вычислены с помощью умножения матриц с последующим смещением смещения. Дополнительные сведения см. в разделе <em>«Нейронные сети»</em> примечаний.  </p>
<h4>Преобразование слоев FC в слои CONV</h4>
<p>Стоит отметить, что единственное различие между слоями <em>FC</em> и <em>CONV</em> заключается в том, что нейроны в слое <em>CONV</em> связаны только с локальной областью на входе, и что многие нейроны в объеме <em>CONV</em> имеют общие параметры. Тем не менее, нейроны в обоих слоях по-прежнему вычисляют точечные произведения, поэтому их функциональная форма идентична. Таким образом, оказывается, что можно преобразовывать между слоями <em>FC</em> и <em>CONV</em>:
- Для любого слоя <em>CONV</em> существует слой <em>FC</em>, реализующий ту же прямую функцию. Матрица весов будет большой матрицей, которая в основном равна нулю, за исключением некоторых блоков (из-за локальной связности), где веса во многих блоках равны (из-за совместного использования параметров).
- И наоборот, любой слой <em>FC</em> может быть преобразован в слой <em>CONV</em>. Например, слой <em>FC</em> с <strong>K=4096</strong>, то есть с учетом некоторого входного объема размера <strong>7×7×512</strong> может быть эквивалентно выражен в виде слоя CONV с помощью <strong>F=7,P=0,S=1,K=4096</strong>. Другими словами, мы устанавливаем размер фильтра точно равным размеру входного объема, и, следовательно, на выходе будет просто <strong>1×1×4096</strong> так как только один столбец глубины «помещается» поперек входного объема, давая тот же результат, что и исходный слой FC.  </p>
<p><strong>Конверсия FC-&gt;CONV</strong>. Из этих двух преобразований возможность преобразования слоя FC в слой CONV особенно полезна на практике. Рассмотрим архитектуру ConvNet, которая берет изображение размером <strong>224x224x3</strong>, а затем использует ряд слоев <em>CONV</em> и слоев <em>POOL</em> для уменьшения объема активации до размера <strong>7x7x512</strong> (в архитектуре <em>AlexNet</em>, которую мы увидим позже, это делается с помощью <strong>5</strong> слоев пула, которые каждый раз уменьшают пространственную дискретизацию входных данных в два раза). Получаем итоговый пространственный размер <strong>224/2/2/2/2/2 = 7</strong>). После этого <em>AlexNet</em> использует два слоя <em>FC</em> размера <strong>4096</strong> и, наконец, последний слой <em>FC</em> с <strong>1000</strong> нейронами, которые вычисляют баллы класса. Мы можем преобразовать каждый из этих трех слоев <em>FC</em> в слои <em>CONV</em>, как описано выше:
- Замените первый слой <em>FC</em>, который смотрит на объем <strong>[7x7x512]</strong>, на слой <em>CONV</em>, использующий размер фильтра <strong>F=7</strong>, дающий выходной объем <strong>[1x1x4096]</strong>.
- Замените второй слой FC на слой <em>CONV</em>, использующий размер фильтра <strong>F=1</strong>, дающий выходной объем <strong>[1x1x4096]</strong>
- Замените последний слой <em>FC</em> аналогичным образом, на <strong>F=1</strong>, выдающий итоговый вывод <strong>[1x1x1000]</strong>  </p>
<p>Каждое из этих преобразований на практике может включать в себя манипуляции (например, изменение формы) матрицей весов <strong>W</strong> в каждом слое <em>FC</em> в фильтры слоя <em>CONV</em>. Оказывается, что это преобразование позволяет нам очень эффективно «скользить» по исходной <em>ConvNet</em> через множество пространственных положений в более крупном изображении за один проход вперед.  </p>
<p>Например, если образ <strong>224x224</strong> дает объем размера <strong>[7x7x512]</strong> - т.е. уменьшение на <strong>32</strong>, то пересылка образа размера <strong>384x384</strong> через преобразованную архитектуру даст эквивалентный объем в размере <strong>[12x12x512]</strong>, так как <em>384/32 = 12</em>. Последующие <strong>3</strong> слоя <em>CONV</em>, которые мы только что преобразовали из слоев FC, теперь дадут окончательный объем размера <strong>[6x6x1000]</strong>, поскольку <strong>(12 - 7)/1 + 1 = 6</strong>. Обратите внимание, что вместо одного вектора оценок классов размера <strong>[1x1x1000]</strong> мы теперь получаем целый массив оценок классов <strong>6x6</strong> на изображении <strong>384x384</strong>.</p>
<blockquote>
<p>Независимая оценка исходной ConvNet (со слоями FC) по кадрам 224x224 изображения 384x384 с шагом 32 пикселя дает результат, идентичный однократной пересылке преобразованной ConvNet.</p>
</blockquote>
<p>Естественно, пересылка преобразованной <em>ConvNet</em> за один раз гораздо эффективнее, чем итерация исходной ConvNet по всем этим <strong>36</strong> местоположениям, поскольку <strong>36</strong> оценок используют общие вычисления. Этот трюк часто используется на практике для повышения производительности, когда, например, обычно изменяют размер изображения, чтобы сделать его больше, используют преобразованный <em>ConvNet</em> для оценки оценок класса во многих пространственных положениях, а затем усредняют баллы класса.  </p>
<p>Наконец, что, если мы хотим эффективно применить исходную <em>ConvNet</em> поверх изображения, но с шагом меньше <strong>32</strong> пикселей? Мы могли бы добиться этого с помощью нескольких передач вперед. Например, обратите внимание, что если бы мы хотели использовать шаг в <strong>16</strong> пикселей, мы могли бы сделать это, объединив объемы, полученные при пересылке преобразованной <em>ConvNet</em> дважды: сначала над исходным изображением, а затем над изображением, но с пространственным сдвигом изображения на <strong>16</strong> пикселей как по ширине, так и по высоте.</p>
<ul>
<li>Блокнот IPython по <a href="https://github.com/BVLC/caffe/blob/master/examples/net_surgery.ipynb">сетевой хирургии</a> показывает, как выполнить преобразование на практике, в коде (с использованием <em>Caffe</em>)  </li>
</ul>
<h2>Архитектуры ConvNet</h2>
<p>Мы видели, что сверточные сети обычно состоят только из трех типов слоев: <em>CONV</em>, <em>POOL</em> (мы предполагаем <em>Max</em> <em>pool</em>, если не указано иное) и <em>FC</em> (сокращение от <em>fully</em> <em>connected</em>). Мы также явно напишем функцию активации <em>RELU</em> в виде слоя, который применяет элементную нелинейность. В этом разделе мы обсудим, как они обычно складываются в целые <em>ConvNet</em>.  </p>
<h3>Узоры слоев</h3>
<p>Наиболее распространенная форма архитектуры <em>ConvNet</em> состоит из нескольких слоев <em>CONV</em>-<em>RELU</em>, затем за ними следуют слои <em>POOL</em> и повторяет этот шаблон до тех пор, пока изображение не будет объединено в пространстве до небольшого размера. В какой-то момент часто происходит переход к полносвязным слоям. Последний полносвязный слой содержит выходные данные, такие как баллы класса. Другими словами, наиболее распространенная архитектура <em>ConvNet</em> следует шаблону:</p>
<p><code>INPUT -&gt; [[CONV -&gt; RELU]*N -&gt; POOL?]*M -&gt; [FC -&gt; RELU]*K -&gt; FC</code></p>
<p>где <code>*</code> указывает на повторение, а <code>POOL?</code> указывает на необязательный слой пула. Более того, <code>N &gt;= 0</code> (и обычно  <code>N &lt;= 3</code> <code>M &gt;= 0</code> <code>K &gt;= 0</code>), , (и обычно <code>K &lt; 3</code> ). Например, вот некоторые распространенные архитектуры ConvNet, которые следуют этому шаблону:<br>
- <code>INPUT -&gt; FC</code> реализует линейный классификатор. Здесь <code>N = M = K = 0</code>
- <code>INPUT -&gt; CONV -&gt; RELU -&gt; FC</code>
- <code>INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC</code>. Здесь мы видим, что между каждым слоем POOL есть один слой CONV.
 -<code>INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC</code>. Здесь мы видим два слоя <em>CONV</em>, расположенных перед каждым слоем <em>POOL</em>. Как правило, это хорошая идея для более крупных и глубоких сетей, поскольку несколько слоев <em>CONV</em> могут привести к более сложным характеристикам входного объема перед деструктивной операцией объединения.  </p>
<p><em>Отдайте предпочтение стеку небольших фильтров CONV одному большому слою рецептивного поля CONV</em>. Предположим, что вы накладываете три слоя <em>CONV</em> <strong>3x3</strong> друг на друга (конечно, с нелинейностями между ними). При таком расположении каждый нейрон на первом слое <em>CONV</em> имеет представление входного объема <strong>3x3</strong>. Нейрон на втором слое <em>CONV</em> имеет представление <strong>3x3</strong> первого слоя <em>CONV</em> и, следовательно, представление входного объема <strong>5x5</strong>. Аналогично, нейрон на третьем слое <em>CONV</em> имеет представление <strong>3x3</strong> на 2-й слой <em>CONV</em> и, следовательно, на входной объем <strong>7x7</strong>. Предположим, что вместо этих трех слоев <strong>3x3</strong> <em>CONV</em> мы хотим использовать только один слой <em>CONV</em> с рецептивными полями <strong>7x7</strong>. Эти нейроны будут иметь размер рецептивного поля входного объема, идентичный в пространственном масштабе (<strong>7x7</strong>), но с некоторыми недостатками.
- Во-первых, нейроны будут вычислять линейную функцию над входными данными, в то время как три стека слоев <em>CONV</em> содержат нелинейности, которые делают их особенности более выразительными. 
- Во-вторых, если мы предположим, что все тома имеют <strong>C</strong> каналов, то можно видеть, что один слой <strong>7x7</strong> <em>CONV</em> будет содержать <strong>\(C \times (7 \times 7 \times C) = 49 C^2\)</strong> параметры, в то время как три слоя <strong>3x3</strong> <em>CONV</em> будут содержать только <strong>\(3 \times (C \times (3 \times 3 \times C)) = 27 C^2\)</strong> параметры. Интуитивно понятно, что наложение слоев <em>CONV</em> с маленькими фильтрами в отличие от одного слоя <em>CONV</em> с большими фильтрами позволяет нам выразить более мощные функции входных данных с меньшим количеством параметров. В качестве практического недостатка нам может потребоваться больше памяти для хранения всех результатов промежуточного слоя <em>CONV</em>, если мы планируем использовать обратное распространение.  </p>
<p><strong>Недавние уходы</strong>. Следует отметить, что традиционная парадигма линейного списка слоев в последнее время была поставлена под сомнение в архитектурах <em>Google Inception</em>, а также в современных (современных) <em>Residual Networks</em> от <em>Microsoft Research Asia</em>. Оба они (см. подробности ниже в разделе тематических исследований) имеют более сложные и разные структуры подключения.</p>
<p>__На практике: используйте то, что лучше всего работает на <em>ImageNet__</em>. Если вы чувствуете некоторую усталость, думая об архитектурных решениях, вам будет приятно узнать, что в <strong>90%</strong> или более приложений вам не нужно беспокоиться об этом. Я предпочитаю резюмировать этот момент как <em>«не будьте героем»</em> : вместо того, чтобы создавать свою собственную архитектуру для решения проблемы, вы должны посмотреть, какая архитектура в настоящее время лучше всего работает на <em>ImageNet</em>, загрузить предварительно обученную модель и настроить ее на основе ваших данных. В редких случаях приходится обучать <em>ConvNet</em> с нуля или проектировать его с нуля. Я также говорил об этом в <a href="https://www.youtube.com/watch?v=u6aEYuemt0M">школе Deep Learning</a>.  </p>
<h3>Шаблоны для определения размеров слоев</h3>
<p>До сих пор мы опускали упоминания об общих гиперпараметрах, используемых на каждом из уровней ConvNet. Сначала мы изложим общие эмпирические правила для определения размеров архитектур, а затем будем следовать правилам, обсуждая нотацию:</p>
<p><strong>Входной слой</strong> (содержащий изображение) должен быть кратен <strong>2</strong> много раз. К распространенным номерам относятся 32 (например, CIFAR-10), <strong>64</strong>, <strong>96</strong> (например, <strong>STL-10</strong>) или <strong>224</strong> (например, общие <em>ImageNet</em> <em>ConvNet</em>), <strong>384</strong> и <strong>512</strong>.  </p>
<p><strong>Для конвальных слоев</strong> следует использовать небольшие фильтры (например, <strong>3x3</strong> или максимум <strong>5x5</strong>), с шагом <strong>S=1</strong> и, что особенно важно, заполнение входного объема нулями таким образом, чтобы слой conv не изменял пространственные размеры входных данных. То есть, когда <strong>F=3</strong>, то с помощью <strong>P=1</strong> сохранит исходный размер входных данных. Когда <strong>F=5</strong>, <strong>P=2</strong>. Для генерала <strong>F</strong>, видно, что <strong>P=(F−1)/2</strong> cохраняет размер ввода. Если вам нужно использовать фильтры большего размера (например, <strong>7x7</strong> или около того), это обычно можно увидеть только на самом первом выпуклом слое, который смотрит на входное изображение.  </p>
<p><strong>Слои пула</strong> отвечают за понижение дискретизации пространственных размеров входных данных. Наиболее распространенной настройкой является использование max-pooling с рецептивными полями <strong>2x2</strong> (т.е. <strong>F=2</strong>), и с шагом <strong>2</strong> (т.е. <strong>S=2</strong>). Обратите внимание, что при этом отбрасывается ровно <strong>75%</strong> активаций входного объема (из-за уменьшения дискретизации на <strong>2</strong> раза как по ширине, так и по высоте). Другой, чуть менее распространенный вариант — использование рецептивных полей <strong>3x3</strong> с шагом <strong>2</strong>, но это делает «подгонку» более сложной (например, слой <strong>32x32x3</strong> потребует нулевого заполнения для использования с максимальным объединением полей с рецептивным полем <strong>3x3</strong> и шагом <strong>2</strong>). Очень редко можно увидеть, что размеры рецептивных полей для максимального пула больше <strong>3</strong>, потому что в этом случае пулинг слишком потерян и агрессивен. Обычно это приводит к ухудшению производительности.  </p>
<p><strong>Уменьшение головной боли при уменьшении размера</strong>. Представленная выше схема радует тем, что все слои <em>CONV</em> сохраняют пространственный размер входных данных, в то время как только слои <em>POOL</em> отвечают за пространственное понижение объемов. В альтернативной схеме, где мы используем шаги больше <strong>1</strong> или не обнуляем входные данные в слоях <em>CONV</em>, нам пришлось бы очень тщательно отслеживать входные объемы по всей архитектуре <em>CNN</em> и убедиться, что все шаги и фильтры  <em>«работают»</em> , и что архитектура <em>ConvNet</em> хорошо и симметрично связана.  </p>
<p><strong>Зачем использовать strace of 1 в CONV?</strong> Меньшие шаги лучше работают на практике. Кроме того, как уже упоминалось, шаг <strong>1</strong> позволяет нам оставить всю пространственную понижение дискретизации слоям <em>POOL</em>, при этом слои <em>CONV</em> преобразуют только входной объем по глубине.  </p>
<p><strong>Зачем использовать набивку?</strong> В дополнение к вышеупомянутому преимуществу сохранения постоянных пространственных размеров после <em>CONV</em>, это фактически повышает производительность. Если бы слои <em>CONV</em> не обнуляли входные данные, а выполняли только корректные свертки, то размер объемов уменьшался бы на небольшую величину после каждого <em>CONV</em>, а информация на границах <em>«смывалась»</em> бы слишком быстро.</p>
<p><strong>Компрометация из-за ограничений памяти</strong>. В некоторых случаях (особенно на ранних этапах архитектуры ConvNet) объем памяти может очень быстро увеличиваться с помощью эмпирических правил, представленных выше. Например, фильтрация изображения размером <strong>224x224x3</strong> с тремя слоями <em>CONV</em> <strong>3x3</strong> с <strong>64</strong> фильтрами каждый и отступом <strong>1</strong> создаст три объема активации размером <strong>[224x224x64]</strong>. Это составляет в общей сложности около <strong>10</strong> миллионов активаций, или 72 МБ памяти (на изображение, как для активаций, так и для градиентов). Поскольку графические процессоры часто имеют узкие места из-за памяти, может потребоваться пойти на компромисс. На практике люди предпочитают идти на компромисс только на первом уровне <em>CONV</em> сети. Например, одним из компромиссов может быть использование первого слоя <em>CONV</em> с размерами фильтра <strong>7x7</strong> и шагом <strong>2</strong> (как в сети ZF). В качестве другого примера, <em>AlexNet</em> использует размеры фильтров <strong>11x11</strong> и <em>stride 4</em>.</p>
<h3>Тематические исследования</h3>
<p>В области сверточных сетей существует несколько архитектур, которые имеют название. Наиболее распространенными являются:</p>
<ul>
<li>
<strong>LeNet</strong>. Первые успешные приложения сверточных сетей были разработаны Яном Лекуном в 1990-х годах. Из них наиболее известной является архитектура <a href="http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf">LeNet</a>, которая использовалась для чтения почтовых индексов, цифр и т. д.</li>
<li>
<strong>AlexNet</strong>. Первой работой, которая популяризировала сверточные сети в компьютерном зрении, стала <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">сеть AlexNet</a>, разработанная Алексом Крижевским, Ильей Суцкевером и Джеффом Хинтоном. В 2012 году AlexNet был представлен на <a href="http://www.image-net.org/challenges/LSVRC/2014/">конкурс ImageNet ILSVRC</a> и значительно превзошел занявшего второе место (ошибка в топ-5 <strong>16%</strong> по сравнению с ошибкой в <strong>26%</strong>, занявшей второе место). Сеть имела очень похожую архитектуру на <em>LeNet</em>, но была глубже, больше и включала сверточные слои, наложенные друг на друга (ранее было обычным делом иметь только один слой <em>CONV</em>, за которым всегда следовал слой <em>POOL</em>).</li>
<li>
<strong>ZF Net</strong>. Победителем <em>ILSVRC 2013</em> стала сверточная сеть от Мэтью Зейлера и Роба Фергуса. Она стала известна как <a href="http://arxiv.org/abs/1311.2901">ZFNet</a> (сокращение от Zeiler &amp; Fergus Net). Это было усовершенствование AlexNet за счет настройки гиперпараметров архитектуры, в частности, за счет увеличения размера средних сверточных слоев и уменьшения размера шага и фильтра на первом слое.</li>
<li>
<strong>GoogLeNet</strong>. Победителем <em>ILSVRC 2014</em> стала сверточная сеть от <a href="http://arxiv.org/abs/1409.4842">Сегеди и др.</a> от Google. Ее основным вкладом стала разработка модуля Inception, который значительно сократил количество параметров в сети (<strong>4M</strong>, по сравнению с <em>AlexNet</em> с <strong>60M</strong>). Кроме того, в этой статье используется <em>Average Pooling</em> вместо <em>Fully Connected layers</em> в верхней части <em>ConvNet</em>, что устраняет большое количество параметров, которые не имеют большого значения. Существует также несколько последующих версий <em>GoogLeNet</em>, последняя из которых <a href="http://arxiv.org/abs/1602.07261">Inception-v4</a>.</li>
<li>
<strong>VGGNet</strong>. Второе место на <em>ILSVRC 2014</em> заняла сеть Карена Симоняна и Эндрю Зиссермана, которая стала известна как <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">VGGNet</a>. Его основной вклад заключался в том, что он показал, что глубина сети является критически важным компонентом для хорошей производительности. Их окончательная лучшая сеть содержит 16 слоев <em>CONV</em>/<em>FC</em> и, что привлекательно, отличается чрезвычайно однородной архитектурой, которая выполняет только свертки 3x3 и пул <strong>2x2</strong> от начала до конца. Их <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">предварительно обученная модель</a> доступна для использования в <em>Caffe</em> по принципу «подключи и работай». Недостатком <em>VGGNet</em> является то, что он дороже в оценке и использует гораздо больше памяти и параметров (<em>140M</em>). Большинство этих параметров находятся в первом полностью связанном слое, и с тех пор было обнаружено, что эти слои <em>FC</em> могут быть удалены без снижения производительности, что значительно сокращает количество необходимых параметров.</li>
<li>
<strong>ResNet</strong>.. <a href="http://arxiv.org/abs/1512.03385">Остаточная сеть</a>, разработанная Каим Хе и др., стала победителем <em>ILSVRC 2015</em>. Она оснащена <em>специальными соединениями для пропуска</em> и интенсивным использованием <a href="http://arxiv.org/abs/1502.03167">пакетной нормализации</a>. В архитектуре также отсутствуют полностью связанные слои в конце сети. Читателю также предлагается ознакомиться с презентацией Кайминга (<a href="https://www.youtube.com/watch?v=1PGLj-uKT1w">видео</a>, <a href="http://research.microsoft.com/en-us/um/people/kahe/ilsvrc15/ilsvrc2015_deep_residual_learning_kaiminghe.pdf">слайды</a>) и некоторыми <a href="https://github.com/gcr/torch-residual-networks">недавними экспериментами</a>, которые воспроизводят эти сети в Torch. В настоящее время ResNet являются самыми современными моделями сверточных нейронных сетей и являются выбором по умолчанию для использования <em>ConvNet</em> на практике (по состоянию на <em>10 мая 2016 года</em>). В частности, см. более поздние разработки, которые корректируют исходную архитектуру, из <a href="https://arxiv.org/abs/1603.05027">книги Каим Хе и др. IСопоставления идентификационных данных в глубоких остаточных сетях</a> (опубликована <em>в марте 2016 г.</em>).  </li>
</ul>
<p><strong>VGGNet в деталях</strong>. Давайте разберем <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">VGGNet</a> более подробно в качестве тематического исследования. Вся сеть <em>VGGNet</em> состоит из слоев <em>CONV</em>, которые выполняют свертки <strong>3x3</strong> со <em>stride 1 и pad 1</em>, и из слоев <em>POOL</em>, которые выполняют <strong>2x2</strong> <em>max</em> <em>pooling</em> с <em>stride</em> <em>2</em> (и без отступа). Мы можем записывать размер представления на каждом шаге обработки и отслеживать как размер представления, так и общее количество весов:  </p>
<div class="code"><pre class="code literal-block">INPUT: [224x224x3]        memory:  224*224*3=150K   weights: 0
CONV3-64: [224x224x64]  memory:  224*224*64=3.2M   weights: (3*3*3)*64 = 1,728
CONV3-64: [224x224x64]  memory:  224*224*64=3.2M   weights: (3*3*64)*64 = 36,864
POOL2: [112x112x64]  memory:  112*112*64=800K   weights: 0
CONV3-128: [112x112x128]  memory:  112*112*128=1.6M   weights: (3*3*64)*128 = 73,728
CONV3-128: [112x112x128]  memory:  112*112*128=1.6M   weights: (3*3*128)*128 = 147,456
POOL2: [56x56x128]  memory:  56*56*128=400K   weights: 0
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*128)*256 = 294,912
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*256)*256 = 589,824
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*256)*256 = 589,824
POOL2: [28x28x256]  memory:  28*28*256=200K   weights: 0
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*256)*512 = 1,179,648
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*512)*512 = 2,359,296
POOL2: [14x14x512]  memory:  14*14*512=100K   weights: 0
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
POOL2: [7x7x512]  memory:  7*7*512=25K  weights: 0
FC: [1x1x4096]  memory:  4096  weights: 7*7*512*4096 = 102,760,448
FC: [1x1x4096]  memory:  4096  weights: 4096*4096 = 16,777,216
FC: [1x1x1000]  memory:  1000 weights: 4096*1000 = 4,096,000

TOTAL memory: 24M * 4 bytes ~= 93MB / image (only forward! ~*2 for bwd)
TOTAL params: 138M parameters  
</pre></div>

<p>Как и в случае со сверточными сетями, обратите внимание, что большая часть памяти (а также вычислительного времени) используется в ранних слоях <em>CONV</em>, а большинство параметров — в последних слоях <em>FC</em>. В данном конкретном случае первый слой <em>FC</em> содержит 100 м грузов из общего числа 140 м.</p>
<h3>Вычислительные соображения</h3>
<p>Самым большим узким местом, о котором следует знать при создании архитектур ConvNet, является узкое место памяти. Многие современные графические процессоры имеют ограничение в <strong>3/4/6 ГБ</strong> памяти, а лучшие графические процессоры имеют около <strong>12 ГБ</strong> памяти. Существует три основных источника памяти, которые необходимо отслеживать:  </p>
<ul>
<li>Из промежуточных размеров объемов: Это исходное количество <strong>активаций</strong> на каждом уровне ConvNet, а также их градиенты (одинакового размера). Как правило, большая часть активаций происходит на более ранних уровнях <em>ConvNet</em> (т.е. на первых уровнях <em>Conv</em>). Они сохраняются, потому что они нужны для обратного распространения, но умная реализация, которая запускает <em>ConvNet</em> только во время тестирования, в принципе могла бы значительно сократить это, сохраняя только текущие активации на любом уровне и отбрасывая предыдущие активации на уровнях ниже.</li>
<li>Из размеров параметров: Это числа, которые содержат <strong>параметры</strong> сети, их градиенты во время обратного распространения и, как правило, также кэш шагов, если оптимизация выполняется с использованием momentum, <em>Adagrad</em> или <em>RMSProp</em>. Следовательно, память для хранения только вектора параметров обычно должна быть умножена по крайней мере на <strong>3</strong> или около того.</li>
<li>Каждая реализация <em>ConvNet</em> должна поддерживать <strong>различную</strong> память, такую как пакеты данных изображений, возможно, их дополненные версии и т.д.  </li>
</ul>
<p>После того, как вы получили приблизительную оценку общего количества значений (для активаций, градиентов и разного), это число следует преобразовать в размер в ГБ. Возьмите количество значений, умножьте на 4, чтобы получить исходное количество байтов (поскольку каждая плавающая точка равна 4 байтам, или, возможно, на 8 для двойной точности), а затем разделите на 1024 несколько раз, чтобы получить объем памяти в КБ, МБ и, наконец, в ГБ. Если ваша сеть не подходит, обычной эвристикой для «подгонки» является уменьшение размера пакета, поскольку большая часть памяти обычно потребляется активациями.  </p>
<h2>Дополнительные материалы</h2>
<p>Дополнительные ресурсы, связанные с реализацией:</p>
<ul>
<li><a href="https://github.com/soumith/convnet-benchmarks">Бенчмарки Soumith для производительности CONV</a></li>
<li>
<a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/cifar10.html">Демонстрация ConvNetJS CIFAR-10</a> позволяет экспериментировать с архитектурами ConvNet и видеть результаты и вычисления в режиме реального времени, в браузере.</li>
<li>
<a href="http://caffe.berkeleyvision.org/">Caffe</a>, одна из популярных библиотек ConvNet.</li>
<li><a href="http://torch.ch/blog/2016/02/04/resnets.html">Современные ResNet в Torch7</a></li>
</ul>
</div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="." rel="prev">Новые записи</a></li>
            <li class="next"><a href="index-1.html" rel="next">Старые записи</a></li>
        </ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\\(","\\\)"] ],
        displayMath: [ ['$$','$$'], ["\\\[","\\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
