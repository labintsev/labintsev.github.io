<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " lang="ru">
<head>
<meta charset="utf-8">
<meta name="description" content="Заметки по machine learning, deep learning.">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Заметки по ML, DL (2 страница со старыми записями) | Заметки по ML, DL</title>
<link href="assets/css/all-nocdn.css" rel="stylesheet" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Playfair+Display:700,900" rel="stylesheet">
<meta name="theme-color" content="#5670d4">
<meta name="generator" content="Nikola (getnikola.com)">
<link rel="alternate" type="application/rss+xml" title="RSS" hreflang="ru" href="rss.xml">
<link rel="canonical" href="https://mldl.ru/index-2.html">
<link rel="prev" href="." type="text/html">
<link rel="next" href="index-1.html" type="text/html">
<!--[if lt IE 9]><script src="assets/js/html5.js"></script><![endif]-->
</head>
<body>
<a href="#content" class="sr-only sr-only-focusable">Перейти к главному содержимому</a>

<!-- Header and menu bar -->
<div class="container">
      <header class="blog-header py-3"><div class="row nbb-header align-items-center">
          <div class="col-md-3 col-xs-2 col-sm-2" style="width: auto;">
            <button class="navbar-toggler navbar-light bg-light nbb-navbar-toggler" type="button" data-toggle="collapse" data-target=".bs-nav-collapsible" aria-controls="bs-navbar" aria-expanded="false" aria-label="Toggle navigation">
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="collapse bs-nav-collapsible bootblog4-search-form-holder">
                
            </div>
        </div>
          <div class="col-md-6 col-xs-10 col-sm-10 bootblog4-brand" style="width: auto;">
            <a class="navbar-brand blog-header-logo text-dark" href=".">

            <span id="blog-title">Заметки по ML, DL</span>
        </a>
          </div>
            <div class="col-md-3 justify-content-end align-items-center bs-nav-collapsible collapse flex-collapse bootblog4-right-nav">
            <nav class="navbar navbar-light bg-white"><ul class="navbar-nav bootblog4-right-nav"></ul></nav>
</div>
    </div>
</header><nav class="navbar navbar-expand-md navbar-light bg-white static-top"><div class="collapse navbar-collapse bs-nav-collapsible" id="bs-navbar">
            <ul class="navbar-nav nav-fill d-flex w-100">
<li class="nav-item">
<a href="archive.html" class="nav-link">Archive</a>
                </li>
<li class="nav-item">
<a href="categories/" class="nav-link">Tags</a>

                
            </li>
</ul>
</div>
<!-- /.navbar-collapse -->
</nav>
</div>

<div class="container" id="content" role="main">
    <div class="body-content">
        <!--Body content-->
        
        
        
    
        

    
        
    <div class="postindex">
            <article class="h-entry post-text" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="p-name entry-title"><a href="posts/architecture/" class="u-url">Архитектура нейросетей </a></h1>
                <div class="metadata">
                    <p class="byline author vcard"><span class="byline-name fn" itemprop="author">
                        Андрей Лабинцев
                    </span></p>
            <p class="dateline">
            <a href="posts/architecture/" rel="bookmark">
            <time class="published dt-published" datetime="2025-03-12T19:42:16+03:00" itemprop="datePublished" title="2025-03-12 19:42">2025-03-12 19:42</time></a>
            </p>
                </div>
            </header><div class="e-content entry-content">
                    <h2>Архитектура нейросетей</h2>
<p>Содержание:
- <a href="posts/architecture/">Обзор архитектуры</a>
- <a href="posts/architecture/">Слои ConvNet</a>
    - <a href="posts/architecture/">Сверточный слой</a>
    - <a href="posts/architecture/">Слой пула</a>
    - <a href="posts/architecture/">Слой нормализации</a>
    - <a href="posts/architecture/">Полностью подключенный слой</a>
    - <a href="posts/architecture/">Преобразование полносвязных слоев в сверточные слои</a>
- <a href="posts/architecture/">Архитектуры ConvNet</a>
     - <a href="posts/architecture/">Узоры слоев</a>
     - <a href="posts/architecture/">Шаблоны для определения размеров слоев</a>
     - <a href="posts/architecture/">Тематические исследования </a> (LeNet / AlexNet / ZFNet / GoogLeNet / VGGNet)
     - <a href="posts/architecture/">Вычислительные соображения</a>
- <a href="posts/architecture/">Дополнительные материалы</a>  </p>
<h3>Сверточные нейронные сети (CNNs / ConvNets)</h3>
<p>Сверточные нейронные сети очень похожи на обычные нейронные сети из предыдущей главы: они состоят из нейронов, которые имеют обучаемые веса и смещения. Каждый нейрон получает некоторые входные данные, выполняет скалярное произведение и опционально следует за ним с нелинейностью. Вся сеть по-прежнему выражает одну дифференцируемую функцию оценки: от пикселей необработанного изображения на одном конце до оценок классов на другом. И у них по-прежнему есть функция потерь (например, <em>SVM/Softmax</em>) на последнем (полностью подключенном) слое, и все советы/рекомендации, которые мы разработали для обучения обычным нейронным сетям, по-прежнему применимы.  </p>
<p>Так что же меняется? Архитектуры <em>ConvNet</em> явно предполагают, что входные данные являются изображениями, что позволяет нам закодировать определенные свойства в архитектуре. Это делает функцию <strong>forward</strong> более эффективной для реализации и значительно сокращает количество параметров в сети.  </p>
<h4>Обзор архитектуры</h4>
<p><em>Напомним: обычные нейронные сети</em>. Как мы видели в предыдущей главе, нейронные сети получают входные данные (один вектор) и преобразуют их через серию <em>скрытых слоев</em>. Каждый скрытый слой состоит из набора нейронов, где каждый нейрон полностью связан со всеми нейронами предыдущего слоя, и где нейроны в одном слое функционируют совершенно независимо и не имеют общих связей. Последний полносвязный слой называется «выходным слоем» и в настройках классификации представляет собой баллы класса.  </p>
<p><em>Обычные нейронные сети плохо масштабируются до полных изображений</em>. В CIFAR-10 изображения имеют размер всего <strong>32x32x3</strong> (<strong>32</strong> в ширину, <strong>32</strong> в высоту, <strong>3</strong> цветных канала), поэтому один полностью связанный нейрон в первом скрытом слое обычной нейронной сети будет иметь <strong>32 * 32 * 3 = 3072</strong> веса. Это количество все еще кажется управляемым, но очевидно, что эта полностью связанная структура не масштабируется до более крупных изображений. Например, изображение более приличного размера, например, <strong>200x200x3</strong>, приведет к нейронам с весом <strong>200<em>200</em>3 = 120 000</strong>. Более того, мы почти наверняка хотели бы иметь несколько таких нейронов, чтобы параметры быстро складывались! Очевидно, что такая полная связность является расточительной, а огромное количество параметров быстро приведет к переобучению.  </p>
<p><em>3D объемы нейронов</em>. Сверточные нейронные сети используют тот факт, что входные данные состоят из изображений, и они ограничивают архитектуру более разумным образом. В частности, в отличие от обычной нейронной сети, слои ConvNet имеют нейроны, расположенные в трех измерениях: <strong>ширина, высота, глубина</strong>. (Обратите внимание, что слово <em>«глубина»</em> здесь относится к третьему измерению объема активации, а не к глубине полной нейронной сети, которая может относиться к общему количеству слоев в сети.) Например, входные изображения в CIFAR-10 представляют собой входной объем активаций, а объем имеет размеры <strong>32х32х3</strong> (ширина, высота, глубина соответственно). Как мы вскоре увидим, нейроны в слое будут соединены только с небольшой областью слоя перед ним, а не со всеми нейронами в полном объеме. Более того, итоговый выходной слой для CIFAR-10 будет иметь размеры <strong>1x1x10</strong>, так как к концу архитектуры <em>ConvNet</em> мы сведем полное изображение к единому вектору оценок классов, расположенных по размерности глубины. Вот визуализация:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/nn1/neural_net2.jpeg"></p>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/cnn.jpeg"></p>
<p><strong>Сверху</strong>: обычная 3-слойная нейронная сеть. <br><strong>Снизу</strong>: <em>ConvNet</em> располагает свои нейроны в трех измерениях (ширина, высота, глубина), как это визуализировано в одном из слоев. Каждый слой ConvNet преобразует входной объем <strong>3D</strong> в объем активации нейронов на выходе <strong>3D</strong>. В этом примере красный входной слой содержит изображение, поэтому его ширина и высота будут соответствовать размерам изображения, а глубина будет равна <strong>3</strong> (красный, зеленый, синий каналы).  </p>
<hr>
<blockquote>
<p>ConvNet состоит из слоев. У каждого слоя есть простой API: он преобразует <em>входной 3D-объем</em> в <em>выходной 3D-объем</em> с помощью некоторой дифференцируемой функции, которая может иметь или не иметь параметры.  </p>
</blockquote>
<h3>Слои, используемые для построения ConvNet</h3>
<p>Как мы уже описывали выше, простая <em>ConvNet</em> представляет собой последовательность слоев, и каждый слой <em>ConvNet</em> преобразует один объем активаций в другой с помощью дифференцируемой функции. Мы используем три основных типа слоев для построения архитектур <em>ConvNet</em>: <strong>сверточный слой, слой пула</strong> и <strong>полносвязный слой</strong> (точно так же, как это видно в обычных нейронных сетях). Мы сложим эти слои, чтобы сформировать полноценную <strong>архитектуру</strong> <em>ConvNet</em>.  </p>
<p><em>Пример архитектуры</em>: обзор. Мы рассмотрим это более подробно ниже, но простой <em>ConvNet</em> для классификации CIFAR-10 может иметь архитектуру <strong>[INPUT - CONV - RELU - POOL - FC]</strong>. Более подробно:</p>
<ul>
<li>INPUT <strong>[32x32x3]</strong> будет содержать исходные значения пикселей изображения, в данном случае изображение шириной <strong>32</strong>, высотой <strong>32</strong> и с тремя цветовыми каналами <strong>R,G,B</strong>.</li>
<li>Слой <strong>CONV</strong> будет вычислять выходные данные нейронов, которые соединены с локальными областями на входных данных, каждый из которых вычисляет скалярное произведение между их весами и небольшой областью, к которой они подключены во входном объеме. Это может привести к объему <strong>[32x32x12]</strong>, если мы решили использовать <strong>12</strong> фильтров.</li>
<li>Слой <strong>RELU</strong> будет применять функцию поэлементной активации, такую как <strong>max(0,х)</strong> с пороговым значением на нуле. При этом размер тома остается неизменным (<strong>[32x32x12]</strong>).</li>
<li>Слой <strong>POOL</strong> выполнит операцию понижения дискретизации вдоль пространственных измерений (ширина, высота), в результате чего будет получен объем, такой как <strong>[16x16x12]</strong>.</li>
<li>Уровень <strong>FC</strong> (т.е. полностью подключенный) будет вычислять баллы класса, в результате чего будет получен объем размера <strong>[1x1x10]</strong>, где каждое из <strong>10</strong> чисел соответствует баллу класса, например, среди <strong>10</strong> категорий CIFAR-10. Как и в случае с обычными нейронными сетями и как следует из названия, каждый нейрон в этом слое будет связан со всеми числами в предыдущем объеме.  </li>
</ul>
<p>Таким образом, <em>ConvNet</em> слой за слоем преобразуют исходное изображение от исходных значений пикселей до итоговых оценок класса. Обратите внимание, что некоторые слои содержат параметры, а другие нет. В частности, слои <em>CONV/FC</em> выполняют преобразования, которые являются функцией не только активации входного объема, но и параметров (весов и смещений нейронов). С другой стороны, слои <em>RELU/POOL</em> будут реализовывать фиксированную функцию. Параметры в слоях <em>CONV/FC</em> будут обучаться с помощью градиентного спуска, чтобы оценки классов, вычисляемые <em>ConvNet</em>, соответствовали меткам в обучающем наборе для каждого изображения.  </p>
<p>Вкратце:  </p>
<ul>
<li>Архитектура <em>ConvNet</em> в простейшем случае представляет собой список слоев, которые преобразуют объем изображения в выходной объем (например, содержат оценки классов)</li>
<li>Существует несколько различных типов слоев (например, <em>CONV/FC/RELU/POOL</em> на сегодняшний день являются наиболее популярными)</li>
<li>Каждый слой принимает входной <strong>3D-объем</strong> и преобразует его в выходной 3D-объем с помощью дифференцируемой функции</li>
<li>Каждый слой может иметь или не иметь параметры (например, у <em>CONV/FC</em> есть, у <em>RELU/POOL</em> нет)</li>
<li>Каждый слой может иметь или не иметь дополнительные гиперпараметры (например, у <em>CONV/FC/POOL</em> есть, у <em>RELU</em> нет)  </li>
</ul>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/convnet.jpeg"><br>
Активация примера архитектуры <em>ConvNet</em>. Начальный том хранит необработанные пиксели изображения (<strong>слева</strong>), а последний том хранит оценки класса (<strong>справа</strong>). Каждый объем активаций на пути обработки отображается в виде столбца. Так как визуализировать <strong>3D</strong>-объемы сложно, мы выкладываем срезы каждого тома в ряды. Последний объем слоя содержит баллы для каждого класса, но здесь мы визуализируем только отсортированные <strong>5</strong> лучших баллов и печатаем этикетки каждого из них. Полный <a href="http://cs231n.stanford.edu/">прототип веб-версии</a> приведен в шапке нашего веб-сайта. Архитектура, показанная здесь, представляет собой крошечную сеть <em>VGG</em>, о которой мы поговорим позже.  </p>
<hr>
<p><em>Теперь мы опишем отдельные слои и детали их гиперпараметров и связуемости</em>.    </p>
<h4>Сверточный слой</h4>
<p>Уровень <em>Conv</em> является основным строительным блоком сверточной сети, который выполняет большую часть тяжелой вычислительной работы.</p>
<p><strong>Обзор и интуиция без мозгов</strong>. Давайте сначала обсудим, что вычисляет слой <em>CONV</em> без аналогий между мозгом и нейронами. Параметры слоя <em>CONV</em> состоят из набора обучаемых фильтров. Каждый фильтр имеет небольшие пространственные размеры (по ширине и высоте), но простирается на всю глубину входного объема. Например, типичный фильтр на первом слое ConvNet может иметь размер <strong>5x5x3</strong> (<em>т. е. 5 пикселей в ширину и высоту, и 3, поскольку изображения имеют глубину 3, цветовые каналы</em>). Во время прямого прохода мы скользим (точнее, свертываем) каждый фильтр по ширине и высоте входного объема и вычисляем точечные произведения между входами фильтра и входом в любом положении. Когда мы перемещаем фильтр по ширине и высоте входного объема, мы создадим двумерную карту активации, которая дает ответы этого фильтра в каждом пространственном положении. Интуитивно сеть будет изучать фильтры, которые активируются, когда они видят какой-либо визуальный признак, такой как край определенной ориентации или пятно определенного цвета на первом слое, или, в конечном итоге, целые соты или узоры, похожие на колеса, на более высоких слоях сети. Теперь у нас будет целый набор фильтров в каждом слое <em>CONV</em> (например, <strong>12</strong> фильтров), и каждый из них создаст отдельную двухмерную карту активации. Мы наложим эти карты активации вдоль измерения глубины и получим выходной объем.  </p>
<p><strong>Взгляд на мозг</strong>. Если вы являетесь поклонником аналогий между мозгом и нейронами, то каждая запись в <em>3D</em>-объеме вывода также может быть интерпретирована как выход нейрона, который смотрит только на небольшую область на входе и разделяет параметры со всеми нейронами слева и справа в пространстве (поскольку все эти числа являются результатом применения одного и того же фильтра).  </p>
<p>Теперь мы обсудим детали соединений нейронов, их расположение в пространстве и схему совместного использования параметров.  </p>
<p><strong>Местная связность</strong>. Когда речь идет о многомерных входных данных, таких как изображения, как мы видели выше, нецелесообразно соединять нейроны со всеми нейронами в предыдущем томе. Вместо этого мы будем подключать каждый нейрон только к локальной области входного объема. Пространственная протяженность этой связности является гиперпараметром, называемым <strong>рецептивным полем</strong> нейрона (эквивалентно размеру фильтра). Степень связности вдоль оси глубины всегда равна глубине входного объема. Важно еще раз подчеркнуть эту асимметрию в том, как мы трактуем пространственные размеры (ширину и высоту) и размеры глубины: соединения локальны в <em>2D</em>-пространстве (по ширине и высоте), но всегда полны по всей глубине входного объема.  </p>
<p><em>Пример 1</em>. Например, предположим, что входной объем имеет размер <strong>[32x32x3]</strong> (например, изображение <em>RGB</em> CIFAR-10). Если рецептивное поле (или размер фильтра) равно <em>5x5</em>, то каждый нейрон в слое Conv будет иметь веса в области <strong>[5x5x3]</strong> во входном объеме, что в сумме составляет <strong>5x5x3 = 75</strong> весов (и параметр смещения <strong>+1</strong>). Обратите внимание, что степень связности вдоль оси глубины должна быть равна <strong>3</strong>, так как это глубина входного объема.</p>
<p><em>Пример 2</em>. Предположим, что входной объем имеет размер <strong>[16x16x20]</strong>. Затем, используя пример с размером рецептивного поля <strong>3x3</strong>, каждый нейрон в слое Conv теперь будет иметь в общей сложности <strong>3x3x20 = 180</strong> соединений с входным объемом. Обратите внимание, что, опять же, связность является локальной в <strong>2D</strong>-пространстве (например, <strong>3x3</strong>), но полной по глубине ввода (<strong>20</strong>).  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/depthcol.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/nn1/neuron_model.jpeg"><br><strong>Сверху</strong>: Пример входного объема красным цветом (например, изображение CIFAR-10 размером <strong>32x32x3</strong>) и пример объема нейронов в первом сверточном слое. Каждый нейрон в сверточном слое пространственно связан только с локальной областью во входном объеме, но на всю глубину (<em>т.е. со всеми цветовыми каналами</em>). Обратите внимание, что в глубине есть несколько нейронов (<strong>5</strong> в этом примере), все они смотрят на одну и ту же область на входе: линии, которые соединяют этот столбец из <strong>5</strong> нейронов, не представляют веса (т.е. эти <strong>5</strong> нейронов не имеют одинаковых весов, но они связаны с <strong>5</strong> разными фильтрами), они просто указывают на то, что эти нейроны связаны или смотрят на одно и то же рецептивное поле или область входного объема. <em>т.е. они имеют одно и то же рецептивное поле, но не одинаковые веса.</em> <strong>Снизу</strong>: Нейроны из главы «Нейронные сети» остаются неизменными: они по-прежнему вычисляют скалярное произведение своих весов с последующим нелинейным значением, но их связность теперь ограничена локальными пространственными данными.  </p>
<hr>
<p><strong>Пространственное расположение</strong>. Мы объяснили связь каждого нейрона в слое Conv с входным объемом, но мы еще не обсуждали, сколько нейронов находится в выходном объеме или как они организованы. Три гиперпараметра контролируют размер выходного объема: <strong>глубина, шаг</strong> и <strong>нулевое отступление</strong>. Мы обсудим их далее:<br>
- <em>Во-первых</em>, <strong>глубина</strong> выходного объема — это гиперпараметр: он соответствует количеству фильтров, которые мы хотели бы использовать, каждый из которых учится искать что-то свое во входных данных. Например, если первый сверточный слой принимает в качестве входных данных исходное изображение, то различные нейроны в измерении глубины могут активироваться в присутствии различных ориентированных краев или цветовых пятен. Мы будем называть набор нейронов, которые смотрят на одну и ту же область входных данных, <strong>столбцом глубины</strong> (некоторые люди также предпочитают термин <em>«волокно»</em>).
-<em> Во-вторых</em>, мы должны указать <em>шаг</em>, с которым мы перемещаем фильтр. Когда шаг равен 1, мы перемещаем фильтры по одному пикселю за раз. Когда шаг равен 2 (или редко 3 или более, хотя на практике это редкость), фильтры прыгают на 2 пикселя за раз, когда мы их перемещаем. Это позволит производить меньшие объемы выпуска в пространственном отношении.
-<em> Как мы скоро увидим</em>, иногда будет удобно заполнять входной объем нулями по границе. Размер этого <strong>нулевого отступа</strong> является гиперпараметром. Приятная особенность нулевого заполнения заключается в том, что он позволяет нам контролировать пространственный размер выходных объемов (чаще всего, как мы скоро увидим, мы будем использовать его для точного сохранения пространственного размера входного объема, чтобы ширина и высота входного и выходного объема были одинаковыми).  </p>
<p>Мы можем вычислить пространственный размер выходного объема как функцию от размера входного объема (<strong>W</strong>), размер рецептивного поля нейронов Conv слоя (<strong>F</strong>), шаг, с которым они наносятся (<strong>S</strong>) и количество использованного нулевого заполнения (<strong>P</strong>) на границе. Вы можете убедиться в том, что правильная формула для расчета количества нейронов «поместится» по формуле <strong>(W−F+2P)/S+1</strong>. Например, для входа <strong>7x7</strong> и фильтра <strong>3x3</strong> со stride 1 и pad 0 мы получим выход <strong>5x5</strong>. С помощью шага <strong>2</strong> мы получим выход <strong>3x3</strong>. Давайте также посмотрим еще на один графический пример:  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/stride.jpeg"></p>
<p>Иллюстрация пространственного расположения. В этом примере есть только одно пространственное измерение (<strong>ось x</strong>), один нейрон с размером рецептивного поля <strong>F = 3</strong>, входной размер <strong>W = 5</strong> и нулевое заполнение <strong>P = 1</strong>. <strong>Сверху</strong>: Нейрон шагал по входу с шагом S = 1, давая на выходе размер <strong>(5 - 3 + 2)/1 + 1 = 5</strong>. <strong>Снизу</strong>: Нейрон использует шаг <strong>S = 2</strong>, давая выход размера <strong>(5 - 3 + 2)/2 + 1 = 3</strong>. Обратите внимание, что шаг <strong>S = 3</strong> не может быть использован, так как он не будет аккуратно помещаться по объему. С точки зрения уравнения, это можно определить, так как <strong>(5 - 3 + 2) = 4</strong> не делится на <strong>3</strong>.
Веса нейронов в этом примере <strong>[1,0,-1]</strong> (<em>показаны справа</em>), и их смещение равно нулю. Эти веса являются общими для всех желтых нейронов (см. общие параметры ниже).  </p>
<hr>
<p><em>Использование нулевой набивки</em>. В приведенном выше примере слева обратите внимание, что входной размер был равен <strong>5</strong>, а выходной размер был равен: также <strong>5</strong>. Это сработало так, потому что наши рецептивные поля были равны <strong>3</strong>, и мы использовали нулевую набивку <strong>1</strong>. Если бы не использовалось заполнение нуля, то выходной объем имел бы пространственную размерность только <strong>3</strong>, потому что именно столько нейронов «поместилось» бы на исходном входе. Как правило, установка нулевого заполнения равным <strong>P=(F−1)/2</strong>. Когда шаг <strong>S=1</strong> гарантирует, что входной и выходной объем будут иметь одинаковый пространственный размер. Очень часто используется нулевое заполнение таким образом, и мы обсудим все причины, когда будем говорить больше об архитектурах ConvNet.</p>
<p><em>Ограничения на шаг</em>. Обратите внимание, что гиперпараметры пространственного расположения имеют взаимные ограничения. Например, когда входные данные имеют размер <strong>W=10</strong>, нулевой отступ не используется <strong>P=0</strong>, а размер фильтра равен <strong>F=3</strong>, то использовать stride было бы невозможно <strong>S=2__с </strong>(W−F+2P)/S+1=(10−3+0)/2+1=4.5__, т.е. не целое число, указывающее на то, что нейроны не «помещаются» аккуратно и симметрично на входе. Таким образом, эта настройка гиперпараметров считается недопустимой, и библиотека ConvNet может выдать исключение или обнулить заполнение оставшейся части, чтобы она поместилась, или обрезать входные данные, чтобы она поместилась, или что-то еще. Как мы увидим в разделе Архитектуры <em>ConvNet</em>, правильный выбор размеров ConvNet, чтобы все размеры «отрабатывались», может стать настоящей головной болью, которую использование нулевого заполнения и некоторые рекомендации по проектированию значительно облегчат.</p>
<p><strong>Пример из жизни</strong>.  <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">Архитектура Крижевского и др.</a>, которая выиграла конкурс ImageNet в 2012 году, принимала изображения размером [227x227x3]. На первом сверточном слое использовались нейроны с размером рецептивного поля <strong>F=11__шаг __S=4</strong> и без нулевой набивки <strong>P=0</strong>. Так как <strong>(227 - 11)/4 + 1 = 55</strong>, и так как слой Conv имел глубину <strong>K=96</strong>
, выходной объем слоя Conv имел размер <strong>[55x55x96]</strong>. Каждый из <strong>55x55x96</strong> нейронов в этом объеме был соединен с областью размера <strong>[11x11x3]</strong> во входном объеме. Более того, все 96 нейронов в каждой глубинной колонке подключены к одной и той же области входного канала <strong>[11x11x3]</strong>, но, конечно, с разными весами. В качестве забавного отступления, если вы прочитаете реальную статью, она утверждает, что входные изображения были <strong>224x224</strong>, что, безусловно, неверно, потому что <strong>(224 - 11)/4 + 1</strong> совершенно очевидно не является целым числом. Это сбило с толку многих людей в истории <em>ConvNets</em>, и мало что известно о том, что произошло. Мое собственное предположение заключается в том, что Алекс использовал нулевое заполнение из <strong>3</strong> дополнительных пикселей, о которых он не упоминает в статье.    </p>
<p><strong>Совместное использование параметров</strong>. Схема совместного использования параметров используется в сверточных слоях для управления количеством параметров. Используя приведенный выше пример из реальной жизни, мы видим, что в первом слое <em>Conv</em> <strong>55 * 55 * 96 = 290 400</strong> нейронов, и каждый из них имеет <strong>11 * 11 * 3 = 363</strong> веса и 1 смещение. В совокупности это дает <strong>290400 * 364 = 105 705 600 параметров</strong> только на первом уровне <em>ConvNet</em>. Понятно, что это очень большое число.  </p>
<p>Оказывается, что мы можем значительно сократить число параметров, если сделать одно разумное допущение: если один признак полезен для вычисления в некотором пространственном положении (<strong>x,y</strong>), то он также должен быть полезен для вычисления в другом положении (<strong>\(x_2, y_2\)</strong>). Другими словами, обозначив один двумерный срез глубины как <strong>срез глубины</strong> (например, объем размером <strong>[55x55x96]</strong> имеет <strong>96</strong> срезов глубины, каждый размером <strong>[55x55]</strong>), мы собираемся ограничить нейроны в каждом срезе глубины, чтобы они использовали одни и те же веса и смещение. При такой схеме распределения параметров первый слой Conv в нашем примере теперь будет иметь только 96 уникальных наборов весов (по одному для каждого среза глубины), что в сумме составит <strong>96 * 11 * 11 * 3 = 34 848 уникальных весов</strong>, или <strong>34 944</strong> параметра (<em>+96 смещений</em>). В качестве альтернативы, все <strong>55*55</strong> нейронов в каждом срезе глубины теперь будут использовать одни и те же параметры. На практике во время обратного распространения каждый нейрон в объеме будет вычислять градиент для своих весов, но эти градиенты будут суммироваться для каждого среза глубины и обновлять только один набор весов для каждого среза.  </p>
<p>Обратите внимание, что если все нейроны в одном срезе глубины используют один и тот же вектор весов, то прямой проход слоя <em>CONV</em> в каждом глубинном срезе может быть вычислен как <strong>свертка</strong> весов нейрона с входным объемом (отсюда и название: сверточный слой). Вот почему принято называть наборы весов <strong>фильтром</strong> (или <strong>ядром</strong>), который свертывается с входными данными.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/weights.jpeg"><br>
Примеры фильтров, изученных Крижским и др. Каждый из <strong>96</strong> показанных здесь фильтров имеет размер <strong>[11x11x3]</strong>, и каждый из них является общим для нейронов <strong>55 * 55</strong> в одном глубинном срезе. Обратите внимание, что предположение о совместном использовании параметров относительно разумно: если обнаружение горизонтального края важно в каком-то месте изображения, оно должно быть интуитивно полезным и в каком-то другом месте из-за трансляционно-инвариантной структуры изображений. Таким образом, нет необходимости заново учиться обнаруживать горизонтальный ребро в каждом из <strong>55 * 55</strong> различных мест в выходном объеме слоя <em>Conv</em>.  </p>
<hr>
<p>Обратите внимание, что иногда предположение о совместном использовании параметров может не иметь смысла. Это особенно верно в том случае, когда входные изображения в <em>ConvNet</em> имеют некоторую специфическую центрированную структуру, где мы должны ожидать, например, что на одной стороне изображения должны быть изучены совершенно разные функции, чем на другой. Одним из практических примеров является ситуация, когда входными данными являются лица, которые были центрированы на изображении. Можно ожидать, что различные особенности, специфичные для глаз или волос, могут (и должны) быть изучены в разных пространственных местах. В этом случае обычно ослабляют схему совместного использования параметров и вместо этого просто называют слой <strong>локально подключенным слоем</strong>.</p>
<p><strong>Нумерные примеры</strong>. Чтобы сделать обсуждение выше более конкретным, давайте выразим те же идеи, но в коде и на конкретном примере. Предположим, что входной объем представляет собой массив <strong>numpy</strong>. Тогда:<code>X</code>
- Колонка глубины (или волокно) в позиции будет активацией.<code>(x,y)</code> <code>X[x,y,:]</code>
- Глубинным срезом или, что эквивалентно<code>d</code>, картой активации на глубине были бы активации <code>X[:,:,d]</code> .  </p>
<p><em>Пример слоя conv</em>. Предположим, что входной объем имеет форму . Предположим далее, что мы не используем нулевое заполнение (<code>X</code> <code>X.shape: (11,11,4)</code><strong>P=0</strong>), что размер фильтра равен <strong>F=5</strong>, и что шаг является <strong>S=2</strong>. Таким образом, выходной объем будет иметь пространственный размер <strong>(11-5)/2+1 = 4</strong>, что дает объем с шириной и высотой 4. Карта активации в выходном объеме (назовем его ) будет выглядеть следующим образом (в этом примере вычисляются только некоторые элементы):<code>V</code>
- <code>V[0,0,0] = np.sum(X[:5,:5,:] * W0) + b0</code>
- <code>V[1,0,0] = np.sum(X[2:7,:5,:] * W0) + b0</code>
- <code>V[2,0,0] = np.sum(X[4:9,:5,:] * W0) + b0</code> 
- <code>V[3,0,0] = np.sum(X[6:11,:5,:] * W0) + b0</code>  </p>
<p>Помните, что в numpy приведенная выше операция обозначает поэлементное умножение между массивами. Заметьте также, что вектор веса — это вектор веса этого нейрона и смещение. Здесь предполагается, что он имеет форму , так как размер фильтра равен <strong>5</strong>, а глубина входного объема равна <strong>4</strong>. Обратите внимание, что в каждой точке мы вычисляем скалярное произведение, как это было показано ранее в обычных нейронных сетях. Кроме того, мы видим, что мы используем тот же вес и смещение (из-за совместного использования параметров), и где размеры по ширине увеличиваются с шагом <strong>2</strong> (<em>т.е. шаг</em>). Чтобы построить вторую карту активации в выходном объеме, у нас есть:<code>*</code> <code>W0</code> <code>b0</code> <code>W0</code> <code>W0.shape: (5,5,4)</code><br>
- <code>V[0,0,1] = np.sum(X[:5,:5,:] * W1) + b1</code>
- <code>V[1,0,1] = np.sum(X[2:7,:5,:] * W1) + b1</code>
- <code>V[2,0,1] = np.sum(X[4:9,:5,:] * W1) + b1</code>
- <code>V[3,0,1] = np.sum(X[6:11,:5,:] * W1) + b1</code>
- <code>V[0,1,1] = np.sum(X[:5,2:7,:] * W1) + b1</code> (пример перехода по y)
- <code>V[2,3,1] = np.sum(X[4:9,6:11,:] * W1) + b1</code> (<em>или по обоим</em>)  </p>
<p>где мы видим, что мы индексируем второе измерение глубины в <code>V</code> (по индексу <em>1</em>), потому что мы вычисляем вторую карту активации, и что теперь используется другой набор параметров (<code>W1</code>). В приведенном выше примере мы для краткости опускаем некоторые другие операции, которые <em>Conv Layer</em> выполнил бы для заполнения других частей выходного массива <code>V</code>. Кроме того, вспомните, что эти карты активации часто отслеживаются по элементам с помощью функции активации, такой как <strong>ReLU</strong>, но здесь это не показано.  </p>
<p><strong>Резюме</strong>. Подводя итог, можно сказать, что слой Conv:</p>
<ul>
<li>Принимает объем любого размера <strong>\(W_1 \times H_1 \times D_1\)</strong>
</li>
<li>Требуется четыре гиперпараметра:<ul>
<li>Количество фильтров <strong>K</strong>,</li>
<li>их пространственная протяженность <strong>F</strong>,</li>
<li>Шаг вперед <strong>S</strong>,</li>
<li>Величина нулевого отступа <strong>P</strong>.</li>
</ul>
</li>
<li>Производит объем большого размера <strong>\(W_2 \times H_2 \times D_2\)</strong> где:<ul>
<li><strong>W2=(W1−F+2P)/S+1</strong></li>
<li>
<strong>H2=(H1−F+2P)/S+1</strong> (т.е. ширина и высота вычисляются поровну по симметрии)</li>
<li><strong>D2=K</strong></li>
</ul>
</li>
<li>Благодаря совместному использованию параметров он вводит <strong>\(F \cdot F \cdot D_1\)</strong> веса на фильтр, итого <strong>\((F \cdot F \cdot D_1) \cdot K\)</strong> веса и <strong>K</strong> cмещений.</li>
<li>В выходном объеме метод <strong>d</strong>-я глубина среза (размера <strong>\(W_2 \times H_2\)</strong> ) является результатом выполнения валидной свертки <strong>d</strong>-й фильтр по входной громкости с шагом <strong>S</strong>, а затем сместить на <strong>d</strong>-ое смещение.  </li>
</ul>
<p>Общая настройка гиперпараметров выглядит следующим образом: <strong>F=3,S=1,P=1</strong>. Тем не менее, существуют общие условности и эмпирические правила, которые мотивируют эти гиперпараметры. Смотрите раздел <a href="https://cs231n.github.io/convolutional-networks/#architectures">Архитектуры ConvNet</a> ниже.</p>
<p><strong>Демо свертки</strong>. Ниже приведена бегущая демонстрация слоя CONV. Поскольку <strong>3D</strong>-объемы трудно визуализировать, все объемы (входной объем (синий), весовой объем (красный), выходной объем (зеленый)) визуализируются с каждым срезом глубины, уложенным в ряды. Входной объем имеет размер  <strong>\(W_1 = 5, H_1 = 5, D_1 = 3\)</strong>, а параметры слоя <em>CONV</em> равны <strong>\(K = 2, F = 3, S = 2, P = 1\)</strong>. То есть у нас есть два фильтра размера <strong>3×3</strong>, и наносятся они с шагом <strong>2</strong>. Следовательно, размер выходного объема имеет пространственный размер <strong>(5 - 3 + 2)/2 + 1 = 3</strong>. Кроме того, обратите внимание, что отступ <strong>P=1</strong> применяется к входному объему, при этом внешняя граница входного объема обнуляется. На приведенной ниже визуализации перебираются выходные активации (<em>зеленый</em>) и показано, что каждый элемент вычисляется путем поэлементного умножения выделенных входных данных (<em>синий</em>) на фильтр (<em>красный</em>), суммирования его и последующего смещения результата.  </p>
<hr>
<p><img alt="" src="posts/architecture/">
- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
- </p>
<div class="fig figcenter fighighlight">
  <iframe src="assets/conv-demo/index.html" width="100%" height="700px;" style="border:none;"></iframe>
  <div class="figcaption"></div>
</div>
<ul>
<li>!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!  </li>
</ul>
<hr>
<p><strong>Реализация в виде умножения матриц</strong>. Обратите внимание, что операция свертки по сути выполняет скалярное произведение между фильтрами и локальными областями входных данных. Общий шаблон реализации слоя <em>CONV</em> заключается в том, чтобы воспользоваться этим фактом и сформулировать прямой проход сверточного слоя в виде умножения одной большой матрицы следующим образом:
_ Локальные регионы на входном изображении растягиваются в столбцы с помощью операции, обычно называемой <strong>im2col</strong>. Например, если входной параметр имеет размер <strong>[227x227x3]</strong> и он должен быть свернут с помощью фильтров <strong>11x11x3</strong> на шаге <strong>4</strong>, то мы возьмем <strong>[11x11x3]</strong> блоков пикселей на входе и растянем каждый блок в вектор-столбец размером <strong>11<em>11</em>3 = 363</strong>. Повторение этого процесса на входе с шагом <strong>4</strong> дает <strong>(227-11)/4+1 = 55</strong> позиций как по ширине, так и по высоте, что приводит к выходной матрице <em>im2col</em> размера <strong>[363 x 3025</strong>], где каждый столбец представляет собой растянутое восприимчивое поле, и всего их <strong>55 x 55 = 3025</strong>. Обратите внимание, что поскольку рецептивные поля перекрываются, каждое число во входном объеме может дублироваться в нескольких отдельных столбцах.<code>X_col</code>
- Грузы слоя <em>CONV</em> аналогичным образом растягиваются в ряды. Например, если имеется <strong>96</strong> фильтров размера <strong>[11x11x3]</strong>, то получится матрица размера <strong>[96 x 363]</strong>. <code>W_row</code>
- Результат свертки теперь эквивалентен выполнению одного умножения большой матрицы , которое вычисляет скалярное произведение между каждым фильтром и каждым местоположением восприимчивого поля. В нашем примере результатом этой операции будет <strong>[96 x 3025]</strong>, что дает выходные данные скалярного произведения каждого фильтра в каждом месте.<code>np.dot(W_row, X_col)</code>
- В конечном итоге результат должен быть возвращен к его надлежащему выходному размеру <strong>[55x55x96]</strong>.  </p>
<p>У этого подхода есть недостаток, заключающийся в том, что он может использовать много памяти, так как некоторые значения во входном объеме многократно реплицируются в . Тем не менее, преимущество заключается в том, что существует множество очень эффективных реализаций матричного умножения, которыми мы можем воспользоваться (например, в широко используемом <a href="http://www.netlib.org/blas/">BLAS</a> <em>API</em>). Более того, та же идея <em>im2col</em> может быть повторно использована для выполнения операции объединения, о которой мы поговорим далее.<code>X_col</code>  </p>
<p><strong>Обратное распространение</strong>. Обратный проход для операции свертки (как для данных, так и для весов) также является сверткой (но с пространственно перевернутыми фильтрами). Это легко вывести в одномерном случае с помощью примера с игрушкой (пока не раскрывается).</p>
<p><strong>Свертка 1х1</strong>. В качестве отступления, в нескольких работах используются свертки <strong>1x1</strong>, впервые исследованные <a href="http://arxiv.org/abs/1312.4400">Network in Network</a>. Некоторые люди поначалу путаются, видя свертки <strong>1x1</strong>, особенно когда они исходят из фона обработки сигналов. Обычно сигналы двумерны, поэтому свертки 1x1 не имеют смысла (это просто поточечное масштабирование). Однако в <em>ConvNet</em> это не так, потому что необходимо помнить, что мы работаем с трехмерными объемами и что фильтры всегда распространяются на всю глубину входного объема. Например, если входные данные равны <strong>[32x32x3]</strong>, то выполнение сверток <em>1x1</em> фактически будет выполнением трехмерных скалярных произведений (поскольку глубина входных данных равна <strong>3</strong> каналам).  </p>
<p><strong>Расширенные извилины</strong>. Недавняя разработка (<a href="https://arxiv.org/abs/1511.07122">см., например, статью Фишера Ю. и Владлена Колтуна</a>) заключается в введении еще одного гиперпараметра в слой <em>CONV</em>, называемого <em>дилатацией</em>. До сих пор мы обсуждали только непрерывные фильтры <em>CONV</em>. Тем не менее, можно иметь фильтры, которые имеют промежутки между каждой клеткой, называемые расширением. Например, в одном измерении фильтр размера <strong>3</strong> будет вычислять на входных данных следующее: . Это расширение до <strong>0</strong>. Для расширения <strong>1</strong> фильтр вместо этого будет вычислять ; Другими словами, между заявками есть разрыв в <strong>1</strong>. Это может быть очень полезно в некоторых настройках для использования в сочетании с фильтрами <strong>0-расширения</strong>, поскольку это позволяет объединять пространственную информацию по входным данным гораздо более агрессивно с меньшим количеством слоев. Например, если вы наложите два слоя <em>CONV</em> <strong>3x3</strong> друг на друга, то вы можете убедить себя, что нейроны на втором слое являются функцией участка входного сигнала <strong>5x5</strong> (мы бы сказали, что <em>эффективное рецептивное поле</em> этих нейронов равно <strong>5x5</strong>). Если мы будем использовать расширенные извилины, то это эффективное рецептивное поле будет расти гораздо быстрее.<code>w</code> <code>x</code> <code>w[0]*x[0] + w[1]*x[1] + w[2]*x[2]w[0]*x[0] + w[1]*x[2] + w[2]*x[4]</code>  </p>
<h4>Слой пула</h4>
<p>В архитектуре <em>ConvNet</em> обычно периодически вставляется слой Pooling между последовательными слоями <em>Conv</em>. Его функция состоит в том, чтобы постепенно уменьшать пространственный размер представления для уменьшения количества параметров и вычислений в сети и, следовательно, также контролировать переобучение. Слой пулинга работает независимо на каждом срезе глубины входных данных и изменяет его пространственный размер с помощью операции <strong>MAX</strong>. Наиболее распространенной формой является пулинговый слой с фильтрами размером <strong>2x2</strong>, применяемыми с шагом <strong>2</strong> вниздискретизации каждого глубинного среза на входе на <strong>2</strong> по ширине и высоте, отбрасывая <strong>75%</strong> активаций. Каждая операция <strong>MAX</strong> в этом случае будет принимать максимум более 4 чисел (маленькая область <strong>2x2</strong> в некотором глубинном срезе). Размер глубины остается неизменным. В более общем смысле, пуловый слой:
- Принимает объем любого размера <strong>W1×H1×D1</strong>
- Требуется два гиперпараметра:
    - их пространственная протяженность <strong>F</strong>,
    - Шаг вперед <strong>S</strong>,
- Производит объем большого размера <strong>\(W_2 \times H_2 \times D_2\)</strong> где:
    - <strong>\(W_2 = (W_1 - F)/S + 1\)</strong>
    - <strong>\(H_2 = (H_1 - F)/S + 1\)</strong>
    - <strong>\(D_2 = D_1\)</strong>
- Вводит нулевые параметры, так как вычисляет фиксированную функцию входных данных
- Для слоев <em>Pooling</em> заполнение входных данных не является обычным способом с использованием нулевого отступа.  </p>
<p>Стоит отметить, что на практике встречаются только два распространенных варианта максимального слоя пула: Слой пулинга с <strong>F=3,S=2</strong> (также называемое перекрывающимся пулом) и чаще <strong>F=2,S=2</strong>. Объединение размеров с большими рецептивными полями слишком разрушительно.  </p>
<p><strong>Общий пул</strong>. В дополнение к максимальному объединению, единицы объединения могут выполнять и другие функции, такие как <em>усредненное объединение</em> или даже <em>объединение по L2-норме</em>. Исторически часто использовалось среднее объединение, но в последнее время оно вышло из моды по сравнению с операцией максимального объединения, которая, как было показано, работает лучше на практике.  </p>
<hr>
<p><img alt="" src="https://cs231n.github.io/assets/cnn/pool.jpeg"><br><img alt="" src="https://cs231n.github.io/assets/cnn/maxpool.jpeg"><br>
Пулинг слоя понижает дискретизацию объема пространственно, независимо в каждом глубинном срезе входного объема. <strong>Сверху</strong>: В этом примере входной объем размера <strong>[224x224x64]</strong> объединяется с фильтром размера 2, шаг 2 в выходной объем размера <strong>[112x112x64]</strong>. Обратите внимание, что глубина объема сохраняется. <strong>Снизу</strong>: Наиболее распространенной операцией понижения дискретизации является max, что приводит к <strong>максимальному объединению</strong>, показанному здесь с шагом <strong>2</strong>. То есть, каждый макс берется над 4 числами (маленький квадратик <strong>2х2</strong>).  </p>
<hr>
<p><strong>Обратное распространение</strong>. Вспомните из главы об обратном распространении, что обратный проход для операции <strong>max(x, y)</strong> имеет простую интерпретацию как только маршрутизацию градиента на вход, который имел наибольшее значение в прямом проходе. Следовательно, во время прямого прохождения пулового слоя обычно отслеживают индекс максимальной активации (иногда также называемый <em>переключателями</em>), чтобы градиентная маршрутизация была эффективной во время обратного распространения.</p>
<p><strong>Избавление от пулов</strong>. Многим людям не нравится операция по объединению, и они думают, что мы можем обойтись без нее. Например, <a href="http://arxiv.org/abs/1412.6806">Pursuit for Simplicity: The All Convolutional Net</a> предлагает отказаться от пулового слоя в пользу архитектуры, состоящей только из повторяющихся слоев <em>CONV</em>. Чтобы уменьшить размер представления, они предлагают время от времени использовать больший шаг в слое <em>CONV</em>. Также было обнаружено, что отказ от слоев пула важен для обучения хороших генеративных моделей, таких как вариационные автоэнкодеры (<em>VAE</em>) или генеративно-состязательные сети (<em>GAN</em>). Вполне вероятно, что в будущих архитектурах будет очень мало или вообще не будет слоев пула.  </p>
<h4>Слой нормализации</h4>
<p>Многие типы уровней нормализации были предложены для использования в архитектурах <em>ConvNet</em>, иногда с намерением реализовать схемы торможения, наблюдаемые в биологическом мозге. Однако с тех пор эти слои вышли из моды, потому что на практике их вклад был минимальным, если вообще был. О различных типах нормализации см. обсуждение в <a href="http://code.google.com/p/cuda-convnet/wiki/LayerParams#Local_response_normalization_layer_(same_map)">API библиотеки cuda-convnet</a> Алекса Крижевского.  </p>
<h4>Полносвязный слой</h4>
<p>Нейроны в полностью связном слое имеют полные связи со всеми активациями в предыдущем слое, как это видно в обычных нейронных сетях. Таким образом, их активации могут быть вычислены с помощью умножения матриц с последующим смещением смещения. Дополнительные сведения см. в разделе <em>«Нейронные сети»</em> примечаний.  </p>
<h4>Преобразование слоев FC в слои CONV</h4>
<p>Стоит отметить, что единственное различие между слоями <em>FC</em> и <em>CONV</em> заключается в том, что нейроны в слое <em>CONV</em> связаны только с локальной областью на входе, и что многие нейроны в объеме <em>CONV</em> имеют общие параметры. Тем не менее, нейроны в обоих слоях по-прежнему вычисляют точечные произведения, поэтому их функциональная форма идентична. Таким образом, оказывается, что можно преобразовывать между слоями <em>FC</em> и <em>CONV</em>:
- Для любого слоя <em>CONV</em> существует слой <em>FC</em>, реализующий ту же прямую функцию. Матрица весов будет большой матрицей, которая в основном равна нулю, за исключением некоторых блоков (из-за локальной связности), где веса во многих блоках равны (из-за совместного использования параметров).
- И наоборот, любой слой <em>FC</em> может быть преобразован в слой <em>CONV</em>. Например, слой <em>FC</em> с <strong>K=4096</strong>, то есть с учетом некоторого входного объема размера <strong>7×7×512</strong> может быть эквивалентно выражен в виде слоя CONV с помощью <strong>F=7,P=0,S=1,K=4096</strong>. Другими словами, мы устанавливаем размер фильтра точно равным размеру входного объема, и, следовательно, на выходе будет просто <strong>1×1×4096</strong> так как только один столбец глубины «помещается» поперек входного объема, давая тот же результат, что и исходный слой FC.  </p>
<p><strong>Конверсия FC-&gt;CONV</strong>. Из этих двух преобразований возможность преобразования слоя FC в слой CONV особенно полезна на практике. Рассмотрим архитектуру ConvNet, которая берет изображение размером <strong>224x224x3</strong>, а затем использует ряд слоев <em>CONV</em> и слоев <em>POOL</em> для уменьшения объема активации до размера <strong>7x7x512</strong> (в архитектуре <em>AlexNet</em>, которую мы увидим позже, это делается с помощью <strong>5</strong> слоев пула, которые каждый раз уменьшают пространственную дискретизацию входных данных в два раза). Получаем итоговый пространственный размер <strong>224/2/2/2/2/2 = 7</strong>). После этого <em>AlexNet</em> использует два слоя <em>FC</em> размера <strong>4096</strong> и, наконец, последний слой <em>FC</em> с <strong>1000</strong> нейронами, которые вычисляют баллы класса. Мы можем преобразовать каждый из этих трех слоев <em>FC</em> в слои <em>CONV</em>, как описано выше:
- Замените первый слой <em>FC</em>, который смотрит на объем <strong>[7x7x512]</strong>, на слой <em>CONV</em>, использующий размер фильтра <strong>F=7</strong>, дающий выходной объем <strong>[1x1x4096]</strong>.
- Замените второй слой FC на слой <em>CONV</em>, использующий размер фильтра <strong>F=1</strong>, дающий выходной объем <strong>[1x1x4096]</strong>
- Замените последний слой <em>FC</em> аналогичным образом, на <strong>F=1</strong>, выдающий итоговый вывод <strong>[1x1x1000]</strong>  </p>
<p>Каждое из этих преобразований на практике может включать в себя манипуляции (например, изменение формы) матрицей весов <strong>W</strong> в каждом слое <em>FC</em> в фильтры слоя <em>CONV</em>. Оказывается, что это преобразование позволяет нам очень эффективно «скользить» по исходной <em>ConvNet</em> через множество пространственных положений в более крупном изображении за один проход вперед.  </p>
<p>Например, если образ <strong>224x224</strong> дает объем размера <strong>[7x7x512]</strong> - т.е. уменьшение на <strong>32</strong>, то пересылка образа размера <strong>384x384</strong> через преобразованную архитектуру даст эквивалентный объем в размере <strong>[12x12x512]</strong>, так как <em>384/32 = 12</em>. Последующие <strong>3</strong> слоя <em>CONV</em>, которые мы только что преобразовали из слоев FC, теперь дадут окончательный объем размера <strong>[6x6x1000]</strong>, поскольку <strong>(12 - 7)/1 + 1 = 6</strong>. Обратите внимание, что вместо одного вектора оценок классов размера <strong>[1x1x1000]</strong> мы теперь получаем целый массив оценок классов <strong>6x6</strong> на изображении <strong>384x384</strong>.</p>
<blockquote>
<p>Независимая оценка исходной ConvNet (со слоями FC) по кадрам 224x224 изображения 384x384 с шагом 32 пикселя дает результат, идентичный однократной пересылке преобразованной ConvNet.</p>
</blockquote>
<p>Естественно, пересылка преобразованной <em>ConvNet</em> за один раз гораздо эффективнее, чем итерация исходной ConvNet по всем этим <strong>36</strong> местоположениям, поскольку <strong>36</strong> оценок используют общие вычисления. Этот трюк часто используется на практике для повышения производительности, когда, например, обычно изменяют размер изображения, чтобы сделать его больше, используют преобразованный <em>ConvNet</em> для оценки оценок класса во многих пространственных положениях, а затем усредняют баллы класса.  </p>
<p>Наконец, что, если мы хотим эффективно применить исходную <em>ConvNet</em> поверх изображения, но с шагом меньше <strong>32</strong> пикселей? Мы могли бы добиться этого с помощью нескольких передач вперед. Например, обратите внимание, что если бы мы хотели использовать шаг в <strong>16</strong> пикселей, мы могли бы сделать это, объединив объемы, полученные при пересылке преобразованной <em>ConvNet</em> дважды: сначала над исходным изображением, а затем над изображением, но с пространственным сдвигом изображения на <strong>16</strong> пикселей как по ширине, так и по высоте.</p>
<ul>
<li>Блокнот IPython по <a href="https://github.com/BVLC/caffe/blob/master/examples/net_surgery.ipynb">сетевой хирургии</a> показывает, как выполнить преобразование на практике, в коде (с использованием <em>Caffe</em>)  </li>
</ul>
<h2>Архитектуры ConvNet</h2>
<p>Мы видели, что сверточные сети обычно состоят только из трех типов слоев: <em>CONV</em>, <em>POOL</em> (мы предполагаем <em>Max</em> <em>pool</em>, если не указано иное) и <em>FC</em> (сокращение от <em>fully</em> <em>connected</em>). Мы также явно напишем функцию активации <em>RELU</em> в виде слоя, который применяет элементную нелинейность. В этом разделе мы обсудим, как они обычно складываются в целые <em>ConvNet</em>.  </p>
<h3>Узоры слоев</h3>
<p>Наиболее распространенная форма архитектуры <em>ConvNet</em> состоит из нескольких слоев <em>CONV</em>-<em>RELU</em>, затем за ними следуют слои <em>POOL</em> и повторяет этот шаблон до тех пор, пока изображение не будет объединено в пространстве до небольшого размера. В какой-то момент часто происходит переход к полносвязным слоям. Последний полносвязный слой содержит выходные данные, такие как баллы класса. Другими словами, наиболее распространенная архитектура <em>ConvNet</em> следует шаблону:</p>
<p><code>INPUT -&gt; [[CONV -&gt; RELU]*N -&gt; POOL?]*M -&gt; [FC -&gt; RELU]*K -&gt; FC</code></p>
<p>где <code>*</code> указывает на повторение, а <code>POOL?</code> указывает на необязательный слой пула. Более того, <code>N &gt;= 0</code> (и обычно  <code>N &lt;= 3</code> <code>M &gt;= 0</code> <code>K &gt;= 0</code>), , (и обычно <code>K &lt; 3</code> ). Например, вот некоторые распространенные архитектуры ConvNet, которые следуют этому шаблону:<br>
- <code>INPUT -&gt; FC</code> реализует линейный классификатор. Здесь <code>N = M = K = 0</code>
- <code>INPUT -&gt; CONV -&gt; RELU -&gt; FC</code>
- <code>INPUT -&gt; [CONV -&gt; RELU -&gt; POOL]*2 -&gt; FC -&gt; RELU -&gt; FC</code>. Здесь мы видим, что между каждым слоем POOL есть один слой CONV.
 -<code>INPUT -&gt; [CONV -&gt; RELU -&gt; CONV -&gt; RELU -&gt; POOL]*3 -&gt; [FC -&gt; RELU]*2 -&gt; FC</code>. Здесь мы видим два слоя <em>CONV</em>, расположенных перед каждым слоем <em>POOL</em>. Как правило, это хорошая идея для более крупных и глубоких сетей, поскольку несколько слоев <em>CONV</em> могут привести к более сложным характеристикам входного объема перед деструктивной операцией объединения.  </p>
<p><em>Отдайте предпочтение стеку небольших фильтров CONV одному большому слою рецептивного поля CONV</em>. Предположим, что вы накладываете три слоя <em>CONV</em> <strong>3x3</strong> друг на друга (конечно, с нелинейностями между ними). При таком расположении каждый нейрон на первом слое <em>CONV</em> имеет представление входного объема <strong>3x3</strong>. Нейрон на втором слое <em>CONV</em> имеет представление <strong>3x3</strong> первого слоя <em>CONV</em> и, следовательно, представление входного объема <strong>5x5</strong>. Аналогично, нейрон на третьем слое <em>CONV</em> имеет представление <strong>3x3</strong> на 2-й слой <em>CONV</em> и, следовательно, на входной объем <strong>7x7</strong>. Предположим, что вместо этих трех слоев <strong>3x3</strong> <em>CONV</em> мы хотим использовать только один слой <em>CONV</em> с рецептивными полями <strong>7x7</strong>. Эти нейроны будут иметь размер рецептивного поля входного объема, идентичный в пространственном масштабе (<strong>7x7</strong>), но с некоторыми недостатками.
- Во-первых, нейроны будут вычислять линейную функцию над входными данными, в то время как три стека слоев <em>CONV</em> содержат нелинейности, которые делают их особенности более выразительными. 
- Во-вторых, если мы предположим, что все тома имеют <strong>C</strong> каналов, то можно видеть, что один слой <strong>7x7</strong> <em>CONV</em> будет содержать <strong>\(C \times (7 \times 7 \times C) = 49 C^2\)</strong> параметры, в то время как три слоя <strong>3x3</strong> <em>CONV</em> будут содержать только <strong>\(3 \times (C \times (3 \times 3 \times C)) = 27 C^2\)</strong> параметры. Интуитивно понятно, что наложение слоев <em>CONV</em> с маленькими фильтрами в отличие от одного слоя <em>CONV</em> с большими фильтрами позволяет нам выразить более мощные функции входных данных с меньшим количеством параметров. В качестве практического недостатка нам может потребоваться больше памяти для хранения всех результатов промежуточного слоя <em>CONV</em>, если мы планируем использовать обратное распространение.  </p>
<p><strong>Недавние уходы</strong>. Следует отметить, что традиционная парадигма линейного списка слоев в последнее время была поставлена под сомнение в архитектурах <em>Google Inception</em>, а также в современных (современных) <em>Residual Networks</em> от <em>Microsoft Research Asia</em>. Оба они (см. подробности ниже в разделе тематических исследований) имеют более сложные и разные структуры подключения.</p>
<p>__На практике: используйте то, что лучше всего работает на <em>ImageNet__</em>. Если вы чувствуете некоторую усталость, думая об архитектурных решениях, вам будет приятно узнать, что в <strong>90%</strong> или более приложений вам не нужно беспокоиться об этом. Я предпочитаю резюмировать этот момент как <em>«не будьте героем»</em> : вместо того, чтобы создавать свою собственную архитектуру для решения проблемы, вы должны посмотреть, какая архитектура в настоящее время лучше всего работает на <em>ImageNet</em>, загрузить предварительно обученную модель и настроить ее на основе ваших данных. В редких случаях приходится обучать <em>ConvNet</em> с нуля или проектировать его с нуля. Я также говорил об этом в <a href="https://www.youtube.com/watch?v=u6aEYuemt0M">школе Deep Learning</a>.  </p>
<h3>Шаблоны для определения размеров слоев</h3>
<p>До сих пор мы опускали упоминания об общих гиперпараметрах, используемых на каждом из уровней ConvNet. Сначала мы изложим общие эмпирические правила для определения размеров архитектур, а затем будем следовать правилам, обсуждая нотацию:</p>
<p><strong>Входной слой</strong> (содержащий изображение) должен быть кратен <strong>2</strong> много раз. К распространенным номерам относятся 32 (например, CIFAR-10), <strong>64</strong>, <strong>96</strong> (например, <strong>STL-10</strong>) или <strong>224</strong> (например, общие <em>ImageNet</em> <em>ConvNet</em>), <strong>384</strong> и <strong>512</strong>.  </p>
<p><strong>Для конвальных слоев</strong> следует использовать небольшие фильтры (например, <strong>3x3</strong> или максимум <strong>5x5</strong>), с шагом <strong>S=1</strong> и, что особенно важно, заполнение входного объема нулями таким образом, чтобы слой conv не изменял пространственные размеры входных данных. То есть, когда <strong>F=3</strong>, то с помощью <strong>P=1</strong> сохранит исходный размер входных данных. Когда <strong>F=5</strong>, <strong>P=2</strong>. Для генерала <strong>F</strong>, видно, что <strong>P=(F−1)/2</strong> cохраняет размер ввода. Если вам нужно использовать фильтры большего размера (например, <strong>7x7</strong> или около того), это обычно можно увидеть только на самом первом выпуклом слое, который смотрит на входное изображение.  </p>
<p><strong>Слои пула</strong> отвечают за понижение дискретизации пространственных размеров входных данных. Наиболее распространенной настройкой является использование max-pooling с рецептивными полями <strong>2x2</strong> (т.е. <strong>F=2</strong>), и с шагом <strong>2</strong> (т.е. <strong>S=2</strong>). Обратите внимание, что при этом отбрасывается ровно <strong>75%</strong> активаций входного объема (из-за уменьшения дискретизации на <strong>2</strong> раза как по ширине, так и по высоте). Другой, чуть менее распространенный вариант — использование рецептивных полей <strong>3x3</strong> с шагом <strong>2</strong>, но это делает «подгонку» более сложной (например, слой <strong>32x32x3</strong> потребует нулевого заполнения для использования с максимальным объединением полей с рецептивным полем <strong>3x3</strong> и шагом <strong>2</strong>). Очень редко можно увидеть, что размеры рецептивных полей для максимального пула больше <strong>3</strong>, потому что в этом случае пулинг слишком потерян и агрессивен. Обычно это приводит к ухудшению производительности.  </p>
<p><strong>Уменьшение головной боли при уменьшении размера</strong>. Представленная выше схема радует тем, что все слои <em>CONV</em> сохраняют пространственный размер входных данных, в то время как только слои <em>POOL</em> отвечают за пространственное понижение объемов. В альтернативной схеме, где мы используем шаги больше <strong>1</strong> или не обнуляем входные данные в слоях <em>CONV</em>, нам пришлось бы очень тщательно отслеживать входные объемы по всей архитектуре <em>CNN</em> и убедиться, что все шаги и фильтры  <em>«работают»</em> , и что архитектура <em>ConvNet</em> хорошо и симметрично связана.  </p>
<p><strong>Зачем использовать strace of 1 в CONV?</strong> Меньшие шаги лучше работают на практике. Кроме того, как уже упоминалось, шаг <strong>1</strong> позволяет нам оставить всю пространственную понижение дискретизации слоям <em>POOL</em>, при этом слои <em>CONV</em> преобразуют только входной объем по глубине.  </p>
<p><strong>Зачем использовать набивку?</strong> В дополнение к вышеупомянутому преимуществу сохранения постоянных пространственных размеров после <em>CONV</em>, это фактически повышает производительность. Если бы слои <em>CONV</em> не обнуляли входные данные, а выполняли только корректные свертки, то размер объемов уменьшался бы на небольшую величину после каждого <em>CONV</em>, а информация на границах <em>«смывалась»</em> бы слишком быстро.</p>
<p><strong>Компрометация из-за ограничений памяти</strong>. В некоторых случаях (особенно на ранних этапах архитектуры ConvNet) объем памяти может очень быстро увеличиваться с помощью эмпирических правил, представленных выше. Например, фильтрация изображения размером <strong>224x224x3</strong> с тремя слоями <em>CONV</em> <strong>3x3</strong> с <strong>64</strong> фильтрами каждый и отступом <strong>1</strong> создаст три объема активации размером <strong>[224x224x64]</strong>. Это составляет в общей сложности около <strong>10</strong> миллионов активаций, или 72 МБ памяти (на изображение, как для активаций, так и для градиентов). Поскольку графические процессоры часто имеют узкие места из-за памяти, может потребоваться пойти на компромисс. На практике люди предпочитают идти на компромисс только на первом уровне <em>CONV</em> сети. Например, одним из компромиссов может быть использование первого слоя <em>CONV</em> с размерами фильтра <strong>7x7</strong> и шагом <strong>2</strong> (как в сети ZF). В качестве другого примера, <em>AlexNet</em> использует размеры фильтров <strong>11x11</strong> и <em>stride 4</em>.</p>
<h3>Тематические исследования</h3>
<p>В области сверточных сетей существует несколько архитектур, которые имеют название. Наиболее распространенными являются:</p>
<ul>
<li>
<strong>LeNet</strong>. Первые успешные приложения сверточных сетей были разработаны Яном Лекуном в 1990-х годах. Из них наиболее известной является архитектура <a href="http://yann.lecun.com/exdb/publis/pdf/lecun-98.pdf">LeNet</a>, которая использовалась для чтения почтовых индексов, цифр и т. д.</li>
<li>
<strong>AlexNet</strong>. Первой работой, которая популяризировала сверточные сети в компьютерном зрении, стала <a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks">сеть AlexNet</a>, разработанная Алексом Крижевским, Ильей Суцкевером и Джеффом Хинтоном. В 2012 году AlexNet был представлен на <a href="http://www.image-net.org/challenges/LSVRC/2014/">конкурс ImageNet ILSVRC</a> и значительно превзошел занявшего второе место (ошибка в топ-5 <strong>16%</strong> по сравнению с ошибкой в <strong>26%</strong>, занявшей второе место). Сеть имела очень похожую архитектуру на <em>LeNet</em>, но была глубже, больше и включала сверточные слои, наложенные друг на друга (ранее было обычным делом иметь только один слой <em>CONV</em>, за которым всегда следовал слой <em>POOL</em>).</li>
<li>
<strong>ZF Net</strong>. Победителем <em>ILSVRC 2013</em> стала сверточная сеть от Мэтью Зейлера и Роба Фергуса. Она стала известна как <a href="http://arxiv.org/abs/1311.2901">ZFNet</a> (сокращение от Zeiler &amp; Fergus Net). Это было усовершенствование AlexNet за счет настройки гиперпараметров архитектуры, в частности, за счет увеличения размера средних сверточных слоев и уменьшения размера шага и фильтра на первом слое.</li>
<li>
<strong>GoogLeNet</strong>. Победителем <em>ILSVRC 2014</em> стала сверточная сеть от <a href="http://arxiv.org/abs/1409.4842">Сегеди и др.</a> от Google. Ее основным вкладом стала разработка модуля Inception, который значительно сократил количество параметров в сети (<strong>4M</strong>, по сравнению с <em>AlexNet</em> с <strong>60M</strong>). Кроме того, в этой статье используется <em>Average Pooling</em> вместо <em>Fully Connected layers</em> в верхней части <em>ConvNet</em>, что устраняет большое количество параметров, которые не имеют большого значения. Существует также несколько последующих версий <em>GoogLeNet</em>, последняя из которых <a href="http://arxiv.org/abs/1602.07261">Inception-v4</a>.</li>
<li>
<strong>VGGNet</strong>. Второе место на <em>ILSVRC 2014</em> заняла сеть Карена Симоняна и Эндрю Зиссермана, которая стала известна как <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">VGGNet</a>. Его основной вклад заключался в том, что он показал, что глубина сети является критически важным компонентом для хорошей производительности. Их окончательная лучшая сеть содержит 16 слоев <em>CONV</em>/<em>FC</em> и, что привлекательно, отличается чрезвычайно однородной архитектурой, которая выполняет только свертки 3x3 и пул <strong>2x2</strong> от начала до конца. Их <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">предварительно обученная модель</a> доступна для использования в <em>Caffe</em> по принципу «подключи и работай». Недостатком <em>VGGNet</em> является то, что он дороже в оценке и использует гораздо больше памяти и параметров (<em>140M</em>). Большинство этих параметров находятся в первом полностью связанном слое, и с тех пор было обнаружено, что эти слои <em>FC</em> могут быть удалены без снижения производительности, что значительно сокращает количество необходимых параметров.</li>
<li>
<strong>ResNet</strong>.. <a href="http://arxiv.org/abs/1512.03385">Остаточная сеть</a>, разработанная Каим Хе и др., стала победителем <em>ILSVRC 2015</em>. Она оснащена <em>специальными соединениями для пропуска</em> и интенсивным использованием <a href="http://arxiv.org/abs/1502.03167">пакетной нормализации</a>. В архитектуре также отсутствуют полностью связанные слои в конце сети. Читателю также предлагается ознакомиться с презентацией Кайминга (<a href="https://www.youtube.com/watch?v=1PGLj-uKT1w">видео</a>, <a href="http://research.microsoft.com/en-us/um/people/kahe/ilsvrc15/ilsvrc2015_deep_residual_learning_kaiminghe.pdf">слайды</a>) и некоторыми <a href="https://github.com/gcr/torch-residual-networks">недавними экспериментами</a>, которые воспроизводят эти сети в Torch. В настоящее время ResNet являются самыми современными моделями сверточных нейронных сетей и являются выбором по умолчанию для использования <em>ConvNet</em> на практике (по состоянию на <em>10 мая 2016 года</em>). В частности, см. более поздние разработки, которые корректируют исходную архитектуру, из <a href="https://arxiv.org/abs/1603.05027">книги Каим Хе и др. IСопоставления идентификационных данных в глубоких остаточных сетях</a> (опубликована <em>в марте 2016 г.</em>).  </li>
</ul>
<p><strong>VGGNet в деталях</strong>. Давайте разберем <a href="http://www.robots.ox.ac.uk/~vgg/research/very_deep/">VGGNet</a> более подробно в качестве тематического исследования. Вся сеть <em>VGGNet</em> состоит из слоев <em>CONV</em>, которые выполняют свертки <strong>3x3</strong> со <em>stride 1 и pad 1</em>, и из слоев <em>POOL</em>, которые выполняют <strong>2x2</strong> <em>max</em> <em>pooling</em> с <em>stride</em> <em>2</em> (и без отступа). Мы можем записывать размер представления на каждом шаге обработки и отслеживать как размер представления, так и общее количество весов:  </p>
<div class="code"><pre class="code literal-block">INPUT: [224x224x3]        memory:  224*224*3=150K   weights: 0
CONV3-64: [224x224x64]  memory:  224*224*64=3.2M   weights: (3*3*3)*64 = 1,728
CONV3-64: [224x224x64]  memory:  224*224*64=3.2M   weights: (3*3*64)*64 = 36,864
POOL2: [112x112x64]  memory:  112*112*64=800K   weights: 0
CONV3-128: [112x112x128]  memory:  112*112*128=1.6M   weights: (3*3*64)*128 = 73,728
CONV3-128: [112x112x128]  memory:  112*112*128=1.6M   weights: (3*3*128)*128 = 147,456
POOL2: [56x56x128]  memory:  56*56*128=400K   weights: 0
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*128)*256 = 294,912
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*256)*256 = 589,824
CONV3-256: [56x56x256]  memory:  56*56*256=800K   weights: (3*3*256)*256 = 589,824
POOL2: [28x28x256]  memory:  28*28*256=200K   weights: 0
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*256)*512 = 1,179,648
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [28x28x512]  memory:  28*28*512=400K   weights: (3*3*512)*512 = 2,359,296
POOL2: [14x14x512]  memory:  14*14*512=100K   weights: 0
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
CONV3-512: [14x14x512]  memory:  14*14*512=100K   weights: (3*3*512)*512 = 2,359,296
POOL2: [7x7x512]  memory:  7*7*512=25K  weights: 0
FC: [1x1x4096]  memory:  4096  weights: 7*7*512*4096 = 102,760,448
FC: [1x1x4096]  memory:  4096  weights: 4096*4096 = 16,777,216
FC: [1x1x1000]  memory:  1000 weights: 4096*1000 = 4,096,000

TOTAL memory: 24M * 4 bytes ~= 93MB / image (only forward! ~*2 for bwd)
TOTAL params: 138M parameters  
</pre></div>

<p>Как и в случае со сверточными сетями, обратите внимание, что большая часть памяти (а также вычислительного времени) используется в ранних слоях <em>CONV</em>, а большинство параметров — в последних слоях <em>FC</em>. В данном конкретном случае первый слой <em>FC</em> содержит 100 м грузов из общего числа 140 м.</p>
<h3>Вычислительные соображения</h3>
<p>Самым большим узким местом, о котором следует знать при создании архитектур ConvNet, является узкое место памяти. Многие современные графические процессоры имеют ограничение в <strong>3/4/6 ГБ</strong> памяти, а лучшие графические процессоры имеют около <strong>12 ГБ</strong> памяти. Существует три основных источника памяти, которые необходимо отслеживать:  </p>
<ul>
<li>Из промежуточных размеров объемов: Это исходное количество <strong>активаций</strong> на каждом уровне ConvNet, а также их градиенты (одинакового размера). Как правило, большая часть активаций происходит на более ранних уровнях <em>ConvNet</em> (т.е. на первых уровнях <em>Conv</em>). Они сохраняются, потому что они нужны для обратного распространения, но умная реализация, которая запускает <em>ConvNet</em> только во время тестирования, в принципе могла бы значительно сократить это, сохраняя только текущие активации на любом уровне и отбрасывая предыдущие активации на уровнях ниже.</li>
<li>Из размеров параметров: Это числа, которые содержат <strong>параметры</strong> сети, их градиенты во время обратного распространения и, как правило, также кэш шагов, если оптимизация выполняется с использованием momentum, <em>Adagrad</em> или <em>RMSProp</em>. Следовательно, память для хранения только вектора параметров обычно должна быть умножена по крайней мере на <strong>3</strong> или около того.</li>
<li>Каждая реализация <em>ConvNet</em> должна поддерживать <strong>различную</strong> память, такую как пакеты данных изображений, возможно, их дополненные версии и т.д.  </li>
</ul>
<p>После того, как вы получили приблизительную оценку общего количества значений (для активаций, градиентов и разного), это число следует преобразовать в размер в ГБ. Возьмите количество значений, умножьте на 4, чтобы получить исходное количество байтов (поскольку каждая плавающая точка равна 4 байтам, или, возможно, на 8 для двойной точности), а затем разделите на 1024 несколько раз, чтобы получить объем памяти в КБ, МБ и, наконец, в ГБ. Если ваша сеть не подходит, обычной эвристикой для «подгонки» является уменьшение размера пакета, поскольку большая часть памяти обычно потребляется активациями.  </p>
<h2>Дополнительные материалы</h2>
<p>Дополнительные ресурсы, связанные с реализацией:</p>
<ul>
<li><a href="https://github.com/soumith/convnet-benchmarks">Бенчмарки Soumith для производительности CONV</a></li>
<li>
<a href="http://cs.stanford.edu/people/karpathy/convnetjs/demo/cifar10.html">Демонстрация ConvNetJS CIFAR-10</a> позволяет экспериментировать с архитектурами ConvNet и видеть результаты и вычисления в режиме реального времени, в браузере.</li>
<li>
<a href="http://caffe.berkeleyvision.org/">Caffe</a>, одна из популярных библиотек ConvNet.</li>
<li><a href="http://torch.ch/blog/2016/02/04/resnets.html">Современные ResNet в Torch7</a></li>
</ul>
</div>
            </article>
</div>
    
        <ul class="pager postindexpager clearfix">
<li class="previous"><a href="." rel="prev">Новые записи</a></li>
            <li class="next"><a href="index-1.html" rel="next">Старые записи</a></li>
        </ul>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" integrity="sha384-3lJUsx1TJHt7BA4udB5KPnDrlkO8T6J6v/op7ui0BbCjvZ9WqV4Xm6DTP6kQ/iBH" crossorigin="anonymous"></script><script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\\(","\\\)"] ],
        displayMath: [ ['$$','$$'], ["\\\[","\\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--End of body content--><footer id="footer">
            Contents © 2025         <a href="mailto:andrej.labintsev@yandex.ru">Андрей Лабинцев</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
            
            
        </footer>
</div>
</div>


        <script src="assets/js/all-nocdn.js"></script><script>
    baguetteBox.run('div#content', {
        ignoreClass: 'islink',
        captions: function(element){var i=element.getElementsByTagName('img')[0];return i===undefined?'':i.alt;}});
    </script>
</body>
</html>
